// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_database.dart';

// ignore_for_file: type=lint
class $AdminsTable extends Admins with TableInfo<$AdminsTable, AdminRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AdminsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _firstNameMeta = const VerificationMeta(
    'firstName',
  );
  @override
  late final GeneratedColumn<String> firstName = GeneratedColumn<String>(
    'first_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastNameMeta = const VerificationMeta(
    'lastName',
  );
  @override
  late final GeneratedColumn<String> lastName = GeneratedColumn<String>(
    'last_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    phone,
    firstName,
    lastName,
    email,
    updatedAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'admins';
  @override
  VerificationContext validateIntegrity(
    Insertable<AdminRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    } else if (isInserting) {
      context.missing(_phoneMeta);
    }
    if (data.containsKey('first_name')) {
      context.handle(
        _firstNameMeta,
        firstName.isAcceptableOrUnknown(data['first_name']!, _firstNameMeta),
      );
    }
    if (data.containsKey('last_name')) {
      context.handle(
        _lastNameMeta,
        lastName.isAcceptableOrUnknown(data['last_name']!, _lastNameMeta),
      );
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
    {phone},
  ];
  @override
  AdminRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AdminRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      )!,
      firstName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}first_name'],
      ),
      lastName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_name'],
      ),
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $AdminsTable createAlias(String alias) {
    return $AdminsTable(attachedDatabase, alias);
  }
}

class AdminRecord extends DataClass implements Insertable<AdminRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String phone;
  final String? firstName;
  final String? lastName;
  final String? email;
  final DateTime updatedAt;
  final DateTime createdAt;
  const AdminRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.phone,
    this.firstName,
    this.lastName,
    this.email,
    required this.updatedAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['phone'] = Variable<String>(phone);
    if (!nullToAbsent || firstName != null) {
      map['first_name'] = Variable<String>(firstName);
    }
    if (!nullToAbsent || lastName != null) {
      map['last_name'] = Variable<String>(lastName);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  AdminsCompanion toCompanion(bool nullToAbsent) {
    return AdminsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      phone: Value(phone),
      firstName: firstName == null && nullToAbsent
          ? const Value.absent()
          : Value(firstName),
      lastName: lastName == null && nullToAbsent
          ? const Value.absent()
          : Value(lastName),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      updatedAt: Value(updatedAt),
      createdAt: Value(createdAt),
    );
  }

  factory AdminRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AdminRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      phone: serializer.fromJson<String>(json['phone']),
      firstName: serializer.fromJson<String?>(json['firstName']),
      lastName: serializer.fromJson<String?>(json['lastName']),
      email: serializer.fromJson<String?>(json['email']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'phone': serializer.toJson<String>(phone),
      'firstName': serializer.toJson<String?>(firstName),
      'lastName': serializer.toJson<String?>(lastName),
      'email': serializer.toJson<String?>(email),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  AdminRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? phone,
    Value<String?> firstName = const Value.absent(),
    Value<String?> lastName = const Value.absent(),
    Value<String?> email = const Value.absent(),
    DateTime? updatedAt,
    DateTime? createdAt,
  }) => AdminRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    phone: phone ?? this.phone,
    firstName: firstName.present ? firstName.value : this.firstName,
    lastName: lastName.present ? lastName.value : this.lastName,
    email: email.present ? email.value : this.email,
    updatedAt: updatedAt ?? this.updatedAt,
    createdAt: createdAt ?? this.createdAt,
  );
  AdminRecord copyWithCompanion(AdminsCompanion data) {
    return AdminRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      phone: data.phone.present ? data.phone.value : this.phone,
      firstName: data.firstName.present ? data.firstName.value : this.firstName,
      lastName: data.lastName.present ? data.lastName.value : this.lastName,
      email: data.email.present ? data.email.value : this.email,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AdminRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('phone: $phone, ')
          ..write('firstName: $firstName, ')
          ..write('lastName: $lastName, ')
          ..write('email: $email, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    phone,
    firstName,
    lastName,
    email,
    updatedAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AdminRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.phone == this.phone &&
          other.firstName == this.firstName &&
          other.lastName == this.lastName &&
          other.email == this.email &&
          other.updatedAt == this.updatedAt &&
          other.createdAt == this.createdAt);
}

class AdminsCompanion extends UpdateCompanion<AdminRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> phone;
  final Value<String?> firstName;
  final Value<String?> lastName;
  final Value<String?> email;
  final Value<DateTime> updatedAt;
  final Value<DateTime> createdAt;
  const AdminsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.phone = const Value.absent(),
    this.firstName = const Value.absent(),
    this.lastName = const Value.absent(),
    this.email = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  AdminsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String phone,
    this.firstName = const Value.absent(),
    this.lastName = const Value.absent(),
    this.email = const Value.absent(),
    required DateTime updatedAt,
    required DateTime createdAt,
  }) : uid = Value(uid),
       phone = Value(phone),
       updatedAt = Value(updatedAt),
       createdAt = Value(createdAt);
  static Insertable<AdminRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? phone,
    Expression<String>? firstName,
    Expression<String>? lastName,
    Expression<String>? email,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (phone != null) 'phone': phone,
      if (firstName != null) 'first_name': firstName,
      if (lastName != null) 'last_name': lastName,
      if (email != null) 'email': email,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  AdminsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? phone,
    Value<String?>? firstName,
    Value<String?>? lastName,
    Value<String?>? email,
    Value<DateTime>? updatedAt,
    Value<DateTime>? createdAt,
  }) {
    return AdminsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      phone: phone ?? this.phone,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      email: email ?? this.email,
      updatedAt: updatedAt ?? this.updatedAt,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (firstName.present) {
      map['first_name'] = Variable<String>(firstName.value);
    }
    if (lastName.present) {
      map['last_name'] = Variable<String>(lastName.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AdminsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('phone: $phone, ')
          ..write('firstName: $firstName, ')
          ..write('lastName: $lastName, ')
          ..write('email: $email, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $SyncQueueTable extends SyncQueue
    with TableInfo<$SyncQueueTable, SyncQueueRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncQueueTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityUidMeta = const VerificationMeta(
    'entityUid',
  );
  @override
  late final GeneratedColumn<String> entityUid = GeneratedColumn<String>(
    'entity_uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
    'action',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _payloadMeta = const VerificationMeta(
    'payload',
  );
  @override
  late final GeneratedColumn<String> payload = GeneratedColumn<String>(
    'payload',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priorityMeta = const VerificationMeta(
    'priority',
  );
  @override
  late final GeneratedColumn<int> priority = GeneratedColumn<int>(
    'priority',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _retryCountMeta = const VerificationMeta(
    'retryCount',
  );
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
    'retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _errorMeta = const VerificationMeta('error');
  @override
  late final GeneratedColumn<String> error = GeneratedColumn<String>(
    'error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scheduledAtMeta = const VerificationMeta(
    'scheduledAt',
  );
  @override
  late final GeneratedColumn<DateTime> scheduledAt = GeneratedColumn<DateTime>(
    'scheduled_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isProcessedMeta = const VerificationMeta(
    'isProcessed',
  );
  @override
  late final GeneratedColumn<bool> isProcessed = GeneratedColumn<bool>(
    'is_processed',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_processed" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityUid,
    action,
    payload,
    priority,
    retryCount,
    error,
    createdAt,
    scheduledAt,
    isProcessed,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_queue';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncQueueRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_uid')) {
      context.handle(
        _entityUidMeta,
        entityUid.isAcceptableOrUnknown(data['entity_uid']!, _entityUidMeta),
      );
    } else if (isInserting) {
      context.missing(_entityUidMeta);
    }
    if (data.containsKey('action')) {
      context.handle(
        _actionMeta,
        action.isAcceptableOrUnknown(data['action']!, _actionMeta),
      );
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('payload')) {
      context.handle(
        _payloadMeta,
        payload.isAcceptableOrUnknown(data['payload']!, _payloadMeta),
      );
    }
    if (data.containsKey('priority')) {
      context.handle(
        _priorityMeta,
        priority.isAcceptableOrUnknown(data['priority']!, _priorityMeta),
      );
    }
    if (data.containsKey('retry_count')) {
      context.handle(
        _retryCountMeta,
        retryCount.isAcceptableOrUnknown(data['retry_count']!, _retryCountMeta),
      );
    }
    if (data.containsKey('error')) {
      context.handle(
        _errorMeta,
        error.isAcceptableOrUnknown(data['error']!, _errorMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('scheduled_at')) {
      context.handle(
        _scheduledAtMeta,
        scheduledAt.isAcceptableOrUnknown(
          data['scheduled_at']!,
          _scheduledAtMeta,
        ),
      );
    }
    if (data.containsKey('is_processed')) {
      context.handle(
        _isProcessedMeta,
        isProcessed.isAcceptableOrUnknown(
          data['is_processed']!,
          _isProcessedMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncQueueRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncQueueRecord(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityUid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_uid'],
      )!,
      action: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action'],
      )!,
      payload: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payload'],
      ),
      priority: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}priority'],
      )!,
      retryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry_count'],
      )!,
      error: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}error'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      scheduledAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}scheduled_at'],
      ),
      isProcessed: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_processed'],
      )!,
    );
  }

  @override
  $SyncQueueTable createAlias(String alias) {
    return $SyncQueueTable(attachedDatabase, alias);
  }
}

class SyncQueueRecord extends DataClass implements Insertable<SyncQueueRecord> {
  final int id;
  final String entityType;
  final String entityUid;
  final String action;
  final String? payload;
  final int priority;
  final int retryCount;
  final String? error;
  final DateTime createdAt;
  final DateTime? scheduledAt;
  final bool isProcessed;
  const SyncQueueRecord({
    required this.id,
    required this.entityType,
    required this.entityUid,
    required this.action,
    this.payload,
    required this.priority,
    required this.retryCount,
    this.error,
    required this.createdAt,
    this.scheduledAt,
    required this.isProcessed,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_uid'] = Variable<String>(entityUid);
    map['action'] = Variable<String>(action);
    if (!nullToAbsent || payload != null) {
      map['payload'] = Variable<String>(payload);
    }
    map['priority'] = Variable<int>(priority);
    map['retry_count'] = Variable<int>(retryCount);
    if (!nullToAbsent || error != null) {
      map['error'] = Variable<String>(error);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || scheduledAt != null) {
      map['scheduled_at'] = Variable<DateTime>(scheduledAt);
    }
    map['is_processed'] = Variable<bool>(isProcessed);
    return map;
  }

  SyncQueueCompanion toCompanion(bool nullToAbsent) {
    return SyncQueueCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityUid: Value(entityUid),
      action: Value(action),
      payload: payload == null && nullToAbsent
          ? const Value.absent()
          : Value(payload),
      priority: Value(priority),
      retryCount: Value(retryCount),
      error: error == null && nullToAbsent
          ? const Value.absent()
          : Value(error),
      createdAt: Value(createdAt),
      scheduledAt: scheduledAt == null && nullToAbsent
          ? const Value.absent()
          : Value(scheduledAt),
      isProcessed: Value(isProcessed),
    );
  }

  factory SyncQueueRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncQueueRecord(
      id: serializer.fromJson<int>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityUid: serializer.fromJson<String>(json['entityUid']),
      action: serializer.fromJson<String>(json['action']),
      payload: serializer.fromJson<String?>(json['payload']),
      priority: serializer.fromJson<int>(json['priority']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      error: serializer.fromJson<String?>(json['error']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      scheduledAt: serializer.fromJson<DateTime?>(json['scheduledAt']),
      isProcessed: serializer.fromJson<bool>(json['isProcessed']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityUid': serializer.toJson<String>(entityUid),
      'action': serializer.toJson<String>(action),
      'payload': serializer.toJson<String?>(payload),
      'priority': serializer.toJson<int>(priority),
      'retryCount': serializer.toJson<int>(retryCount),
      'error': serializer.toJson<String?>(error),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'scheduledAt': serializer.toJson<DateTime?>(scheduledAt),
      'isProcessed': serializer.toJson<bool>(isProcessed),
    };
  }

  SyncQueueRecord copyWith({
    int? id,
    String? entityType,
    String? entityUid,
    String? action,
    Value<String?> payload = const Value.absent(),
    int? priority,
    int? retryCount,
    Value<String?> error = const Value.absent(),
    DateTime? createdAt,
    Value<DateTime?> scheduledAt = const Value.absent(),
    bool? isProcessed,
  }) => SyncQueueRecord(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityUid: entityUid ?? this.entityUid,
    action: action ?? this.action,
    payload: payload.present ? payload.value : this.payload,
    priority: priority ?? this.priority,
    retryCount: retryCount ?? this.retryCount,
    error: error.present ? error.value : this.error,
    createdAt: createdAt ?? this.createdAt,
    scheduledAt: scheduledAt.present ? scheduledAt.value : this.scheduledAt,
    isProcessed: isProcessed ?? this.isProcessed,
  );
  SyncQueueRecord copyWithCompanion(SyncQueueCompanion data) {
    return SyncQueueRecord(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityUid: data.entityUid.present ? data.entityUid.value : this.entityUid,
      action: data.action.present ? data.action.value : this.action,
      payload: data.payload.present ? data.payload.value : this.payload,
      priority: data.priority.present ? data.priority.value : this.priority,
      retryCount: data.retryCount.present
          ? data.retryCount.value
          : this.retryCount,
      error: data.error.present ? data.error.value : this.error,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      scheduledAt: data.scheduledAt.present
          ? data.scheduledAt.value
          : this.scheduledAt,
      isProcessed: data.isProcessed.present
          ? data.isProcessed.value
          : this.isProcessed,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueRecord(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityUid: $entityUid, ')
          ..write('action: $action, ')
          ..write('payload: $payload, ')
          ..write('priority: $priority, ')
          ..write('retryCount: $retryCount, ')
          ..write('error: $error, ')
          ..write('createdAt: $createdAt, ')
          ..write('scheduledAt: $scheduledAt, ')
          ..write('isProcessed: $isProcessed')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityUid,
    action,
    payload,
    priority,
    retryCount,
    error,
    createdAt,
    scheduledAt,
    isProcessed,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncQueueRecord &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityUid == this.entityUid &&
          other.action == this.action &&
          other.payload == this.payload &&
          other.priority == this.priority &&
          other.retryCount == this.retryCount &&
          other.error == this.error &&
          other.createdAt == this.createdAt &&
          other.scheduledAt == this.scheduledAt &&
          other.isProcessed == this.isProcessed);
}

class SyncQueueCompanion extends UpdateCompanion<SyncQueueRecord> {
  final Value<int> id;
  final Value<String> entityType;
  final Value<String> entityUid;
  final Value<String> action;
  final Value<String?> payload;
  final Value<int> priority;
  final Value<int> retryCount;
  final Value<String?> error;
  final Value<DateTime> createdAt;
  final Value<DateTime?> scheduledAt;
  final Value<bool> isProcessed;
  const SyncQueueCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityUid = const Value.absent(),
    this.action = const Value.absent(),
    this.payload = const Value.absent(),
    this.priority = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.error = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.scheduledAt = const Value.absent(),
    this.isProcessed = const Value.absent(),
  });
  SyncQueueCompanion.insert({
    this.id = const Value.absent(),
    required String entityType,
    required String entityUid,
    required String action,
    this.payload = const Value.absent(),
    this.priority = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.error = const Value.absent(),
    required DateTime createdAt,
    this.scheduledAt = const Value.absent(),
    this.isProcessed = const Value.absent(),
  }) : entityType = Value(entityType),
       entityUid = Value(entityUid),
       action = Value(action),
       createdAt = Value(createdAt);
  static Insertable<SyncQueueRecord> custom({
    Expression<int>? id,
    Expression<String>? entityType,
    Expression<String>? entityUid,
    Expression<String>? action,
    Expression<String>? payload,
    Expression<int>? priority,
    Expression<int>? retryCount,
    Expression<String>? error,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? scheduledAt,
    Expression<bool>? isProcessed,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityUid != null) 'entity_uid': entityUid,
      if (action != null) 'action': action,
      if (payload != null) 'payload': payload,
      if (priority != null) 'priority': priority,
      if (retryCount != null) 'retry_count': retryCount,
      if (error != null) 'error': error,
      if (createdAt != null) 'created_at': createdAt,
      if (scheduledAt != null) 'scheduled_at': scheduledAt,
      if (isProcessed != null) 'is_processed': isProcessed,
    });
  }

  SyncQueueCompanion copyWith({
    Value<int>? id,
    Value<String>? entityType,
    Value<String>? entityUid,
    Value<String>? action,
    Value<String?>? payload,
    Value<int>? priority,
    Value<int>? retryCount,
    Value<String?>? error,
    Value<DateTime>? createdAt,
    Value<DateTime?>? scheduledAt,
    Value<bool>? isProcessed,
  }) {
    return SyncQueueCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityUid: entityUid ?? this.entityUid,
      action: action ?? this.action,
      payload: payload ?? this.payload,
      priority: priority ?? this.priority,
      retryCount: retryCount ?? this.retryCount,
      error: error ?? this.error,
      createdAt: createdAt ?? this.createdAt,
      scheduledAt: scheduledAt ?? this.scheduledAt,
      isProcessed: isProcessed ?? this.isProcessed,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityUid.present) {
      map['entity_uid'] = Variable<String>(entityUid.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (payload.present) {
      map['payload'] = Variable<String>(payload.value);
    }
    if (priority.present) {
      map['priority'] = Variable<int>(priority.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (error.present) {
      map['error'] = Variable<String>(error.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (scheduledAt.present) {
      map['scheduled_at'] = Variable<DateTime>(scheduledAt.value);
    }
    if (isProcessed.present) {
      map['is_processed'] = Variable<bool>(isProcessed.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityUid: $entityUid, ')
          ..write('action: $action, ')
          ..write('payload: $payload, ')
          ..write('priority: $priority, ')
          ..write('retryCount: $retryCount, ')
          ..write('error: $error, ')
          ..write('createdAt: $createdAt, ')
          ..write('scheduledAt: $scheduledAt, ')
          ..write('isProcessed: $isProcessed')
          ..write(')'))
        .toString();
  }
}

class $ImageSyncQueueTable extends ImageSyncQueue
    with TableInfo<$ImageSyncQueueTable, ImageSyncQueueRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ImageSyncQueueTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityUIDMeta = const VerificationMeta(
    'entityUID',
  );
  @override
  late final GeneratedColumn<String> entityUID = GeneratedColumn<String>(
    'entity_u_i_d',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contextFieldMeta = const VerificationMeta(
    'contextField',
  );
  @override
  late final GeneratedColumn<String> contextField = GeneratedColumn<String>(
    'context_field',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sequenceMeta = const VerificationMeta(
    'sequence',
  );
  @override
  late final GeneratedColumn<int> sequence = GeneratedColumn<int>(
    'sequence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _localFilePathMeta = const VerificationMeta(
    'localFilePath',
  );
  @override
  late final GeneratedColumn<String> localFilePath = GeneratedColumn<String>(
    'local_file_path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fileNameMeta = const VerificationMeta(
    'fileName',
  );
  @override
  late final GeneratedColumn<String> fileName = GeneratedColumn<String>(
    'file_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _mimeTypeMeta = const VerificationMeta(
    'mimeType',
  );
  @override
  late final GeneratedColumn<String> mimeType = GeneratedColumn<String>(
    'mime_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fileSizeMeta = const VerificationMeta(
    'fileSize',
  );
  @override
  late final GeneratedColumn<int> fileSize = GeneratedColumn<int>(
    'file_size',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _companyUIDMeta = const VerificationMeta(
    'companyUID',
  );
  @override
  late final GeneratedColumn<String> companyUID = GeneratedColumn<String>(
    'company_u_i_d',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _uploadedByUIDMeta = const VerificationMeta(
    'uploadedByUID',
  );
  @override
  late final GeneratedColumn<String> uploadedByUID = GeneratedColumn<String>(
    'uploaded_by_u_i_d',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncStatusMeta = const VerificationMeta(
    'syncStatus',
  );
  @override
  late final GeneratedColumn<String> syncStatus = GeneratedColumn<String>(
    'sync_status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _retryCountMeta = const VerificationMeta(
    'retryCount',
  );
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
    'retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _maxRetriesMeta = const VerificationMeta(
    'maxRetries',
  );
  @override
  late final GeneratedColumn<int> maxRetries = GeneratedColumn<int>(
    'max_retries',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(5),
  );
  static const VerificationMeta _fileUIDMeta = const VerificationMeta(
    'fileUID',
  );
  @override
  late final GeneratedColumn<String> fileUID = GeneratedColumn<String>(
    'file_u_i_d',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _s3KeyMeta = const VerificationMeta('s3Key');
  @override
  late final GeneratedColumn<String> s3Key = GeneratedColumn<String>(
    's3_key',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _s3UrlMeta = const VerificationMeta('s3Url');
  @override
  late final GeneratedColumn<String> s3Url = GeneratedColumn<String>(
    's3_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _errorMeta = const VerificationMeta('error');
  @override
  late final GeneratedColumn<String> error = GeneratedColumn<String>(
    'error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _lastAttemptAtMeta = const VerificationMeta(
    'lastAttemptAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastAttemptAt =
      GeneratedColumn<DateTime>(
        'last_attempt_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityUID,
    contextField,
    sequence,
    localFilePath,
    fileName,
    mimeType,
    fileSize,
    companyUID,
    uploadedByUID,
    syncStatus,
    retryCount,
    maxRetries,
    fileUID,
    s3Key,
    s3Url,
    error,
    createdAt,
    lastAttemptAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'image_sync_queue';
  @override
  VerificationContext validateIntegrity(
    Insertable<ImageSyncQueueRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_u_i_d')) {
      context.handle(
        _entityUIDMeta,
        entityUID.isAcceptableOrUnknown(data['entity_u_i_d']!, _entityUIDMeta),
      );
    } else if (isInserting) {
      context.missing(_entityUIDMeta);
    }
    if (data.containsKey('context_field')) {
      context.handle(
        _contextFieldMeta,
        contextField.isAcceptableOrUnknown(
          data['context_field']!,
          _contextFieldMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_contextFieldMeta);
    }
    if (data.containsKey('sequence')) {
      context.handle(
        _sequenceMeta,
        sequence.isAcceptableOrUnknown(data['sequence']!, _sequenceMeta),
      );
    } else if (isInserting) {
      context.missing(_sequenceMeta);
    }
    if (data.containsKey('local_file_path')) {
      context.handle(
        _localFilePathMeta,
        localFilePath.isAcceptableOrUnknown(
          data['local_file_path']!,
          _localFilePathMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_localFilePathMeta);
    }
    if (data.containsKey('file_name')) {
      context.handle(
        _fileNameMeta,
        fileName.isAcceptableOrUnknown(data['file_name']!, _fileNameMeta),
      );
    } else if (isInserting) {
      context.missing(_fileNameMeta);
    }
    if (data.containsKey('mime_type')) {
      context.handle(
        _mimeTypeMeta,
        mimeType.isAcceptableOrUnknown(data['mime_type']!, _mimeTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_mimeTypeMeta);
    }
    if (data.containsKey('file_size')) {
      context.handle(
        _fileSizeMeta,
        fileSize.isAcceptableOrUnknown(data['file_size']!, _fileSizeMeta),
      );
    } else if (isInserting) {
      context.missing(_fileSizeMeta);
    }
    if (data.containsKey('company_u_i_d')) {
      context.handle(
        _companyUIDMeta,
        companyUID.isAcceptableOrUnknown(
          data['company_u_i_d']!,
          _companyUIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_companyUIDMeta);
    }
    if (data.containsKey('uploaded_by_u_i_d')) {
      context.handle(
        _uploadedByUIDMeta,
        uploadedByUID.isAcceptableOrUnknown(
          data['uploaded_by_u_i_d']!,
          _uploadedByUIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_uploadedByUIDMeta);
    }
    if (data.containsKey('sync_status')) {
      context.handle(
        _syncStatusMeta,
        syncStatus.isAcceptableOrUnknown(data['sync_status']!, _syncStatusMeta),
      );
    } else if (isInserting) {
      context.missing(_syncStatusMeta);
    }
    if (data.containsKey('retry_count')) {
      context.handle(
        _retryCountMeta,
        retryCount.isAcceptableOrUnknown(data['retry_count']!, _retryCountMeta),
      );
    }
    if (data.containsKey('max_retries')) {
      context.handle(
        _maxRetriesMeta,
        maxRetries.isAcceptableOrUnknown(data['max_retries']!, _maxRetriesMeta),
      );
    }
    if (data.containsKey('file_u_i_d')) {
      context.handle(
        _fileUIDMeta,
        fileUID.isAcceptableOrUnknown(data['file_u_i_d']!, _fileUIDMeta),
      );
    }
    if (data.containsKey('s3_key')) {
      context.handle(
        _s3KeyMeta,
        s3Key.isAcceptableOrUnknown(data['s3_key']!, _s3KeyMeta),
      );
    }
    if (data.containsKey('s3_url')) {
      context.handle(
        _s3UrlMeta,
        s3Url.isAcceptableOrUnknown(data['s3_url']!, _s3UrlMeta),
      );
    }
    if (data.containsKey('error')) {
      context.handle(
        _errorMeta,
        error.isAcceptableOrUnknown(data['error']!, _errorMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('last_attempt_at')) {
      context.handle(
        _lastAttemptAtMeta,
        lastAttemptAt.isAcceptableOrUnknown(
          data['last_attempt_at']!,
          _lastAttemptAtMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ImageSyncQueueRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ImageSyncQueueRecord(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityUID: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_u_i_d'],
      )!,
      contextField: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}context_field'],
      )!,
      sequence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sequence'],
      )!,
      localFilePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}local_file_path'],
      )!,
      fileName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_name'],
      )!,
      mimeType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}mime_type'],
      )!,
      fileSize: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}file_size'],
      )!,
      companyUID: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}company_u_i_d'],
      )!,
      uploadedByUID: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uploaded_by_u_i_d'],
      )!,
      syncStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_status'],
      )!,
      retryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry_count'],
      )!,
      maxRetries: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_retries'],
      )!,
      fileUID: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_u_i_d'],
      ),
      s3Key: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}s3_key'],
      ),
      s3Url: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}s3_url'],
      ),
      error: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}error'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      lastAttemptAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_attempt_at'],
      ),
    );
  }

  @override
  $ImageSyncQueueTable createAlias(String alias) {
    return $ImageSyncQueueTable(attachedDatabase, alias);
  }
}

class ImageSyncQueueRecord extends DataClass
    implements Insertable<ImageSyncQueueRecord> {
  final int id;
  final String entityType;
  final String entityUID;
  final String contextField;
  final int sequence;
  final String localFilePath;
  final String fileName;
  final String mimeType;
  final int fileSize;
  final String companyUID;
  final String uploadedByUID;
  final String syncStatus;
  final int retryCount;
  final int maxRetries;
  final String? fileUID;
  final String? s3Key;
  final String? s3Url;
  final String? error;
  final DateTime createdAt;
  final DateTime? lastAttemptAt;
  const ImageSyncQueueRecord({
    required this.id,
    required this.entityType,
    required this.entityUID,
    required this.contextField,
    required this.sequence,
    required this.localFilePath,
    required this.fileName,
    required this.mimeType,
    required this.fileSize,
    required this.companyUID,
    required this.uploadedByUID,
    required this.syncStatus,
    required this.retryCount,
    required this.maxRetries,
    this.fileUID,
    this.s3Key,
    this.s3Url,
    this.error,
    required this.createdAt,
    this.lastAttemptAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_u_i_d'] = Variable<String>(entityUID);
    map['context_field'] = Variable<String>(contextField);
    map['sequence'] = Variable<int>(sequence);
    map['local_file_path'] = Variable<String>(localFilePath);
    map['file_name'] = Variable<String>(fileName);
    map['mime_type'] = Variable<String>(mimeType);
    map['file_size'] = Variable<int>(fileSize);
    map['company_u_i_d'] = Variable<String>(companyUID);
    map['uploaded_by_u_i_d'] = Variable<String>(uploadedByUID);
    map['sync_status'] = Variable<String>(syncStatus);
    map['retry_count'] = Variable<int>(retryCount);
    map['max_retries'] = Variable<int>(maxRetries);
    if (!nullToAbsent || fileUID != null) {
      map['file_u_i_d'] = Variable<String>(fileUID);
    }
    if (!nullToAbsent || s3Key != null) {
      map['s3_key'] = Variable<String>(s3Key);
    }
    if (!nullToAbsent || s3Url != null) {
      map['s3_url'] = Variable<String>(s3Url);
    }
    if (!nullToAbsent || error != null) {
      map['error'] = Variable<String>(error);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || lastAttemptAt != null) {
      map['last_attempt_at'] = Variable<DateTime>(lastAttemptAt);
    }
    return map;
  }

  ImageSyncQueueCompanion toCompanion(bool nullToAbsent) {
    return ImageSyncQueueCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityUID: Value(entityUID),
      contextField: Value(contextField),
      sequence: Value(sequence),
      localFilePath: Value(localFilePath),
      fileName: Value(fileName),
      mimeType: Value(mimeType),
      fileSize: Value(fileSize),
      companyUID: Value(companyUID),
      uploadedByUID: Value(uploadedByUID),
      syncStatus: Value(syncStatus),
      retryCount: Value(retryCount),
      maxRetries: Value(maxRetries),
      fileUID: fileUID == null && nullToAbsent
          ? const Value.absent()
          : Value(fileUID),
      s3Key: s3Key == null && nullToAbsent
          ? const Value.absent()
          : Value(s3Key),
      s3Url: s3Url == null && nullToAbsent
          ? const Value.absent()
          : Value(s3Url),
      error: error == null && nullToAbsent
          ? const Value.absent()
          : Value(error),
      createdAt: Value(createdAt),
      lastAttemptAt: lastAttemptAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastAttemptAt),
    );
  }

  factory ImageSyncQueueRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ImageSyncQueueRecord(
      id: serializer.fromJson<int>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityUID: serializer.fromJson<String>(json['entityUID']),
      contextField: serializer.fromJson<String>(json['contextField']),
      sequence: serializer.fromJson<int>(json['sequence']),
      localFilePath: serializer.fromJson<String>(json['localFilePath']),
      fileName: serializer.fromJson<String>(json['fileName']),
      mimeType: serializer.fromJson<String>(json['mimeType']),
      fileSize: serializer.fromJson<int>(json['fileSize']),
      companyUID: serializer.fromJson<String>(json['companyUID']),
      uploadedByUID: serializer.fromJson<String>(json['uploadedByUID']),
      syncStatus: serializer.fromJson<String>(json['syncStatus']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      maxRetries: serializer.fromJson<int>(json['maxRetries']),
      fileUID: serializer.fromJson<String?>(json['fileUID']),
      s3Key: serializer.fromJson<String?>(json['s3Key']),
      s3Url: serializer.fromJson<String?>(json['s3Url']),
      error: serializer.fromJson<String?>(json['error']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      lastAttemptAt: serializer.fromJson<DateTime?>(json['lastAttemptAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityUID': serializer.toJson<String>(entityUID),
      'contextField': serializer.toJson<String>(contextField),
      'sequence': serializer.toJson<int>(sequence),
      'localFilePath': serializer.toJson<String>(localFilePath),
      'fileName': serializer.toJson<String>(fileName),
      'mimeType': serializer.toJson<String>(mimeType),
      'fileSize': serializer.toJson<int>(fileSize),
      'companyUID': serializer.toJson<String>(companyUID),
      'uploadedByUID': serializer.toJson<String>(uploadedByUID),
      'syncStatus': serializer.toJson<String>(syncStatus),
      'retryCount': serializer.toJson<int>(retryCount),
      'maxRetries': serializer.toJson<int>(maxRetries),
      'fileUID': serializer.toJson<String?>(fileUID),
      's3Key': serializer.toJson<String?>(s3Key),
      's3Url': serializer.toJson<String?>(s3Url),
      'error': serializer.toJson<String?>(error),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'lastAttemptAt': serializer.toJson<DateTime?>(lastAttemptAt),
    };
  }

  ImageSyncQueueRecord copyWith({
    int? id,
    String? entityType,
    String? entityUID,
    String? contextField,
    int? sequence,
    String? localFilePath,
    String? fileName,
    String? mimeType,
    int? fileSize,
    String? companyUID,
    String? uploadedByUID,
    String? syncStatus,
    int? retryCount,
    int? maxRetries,
    Value<String?> fileUID = const Value.absent(),
    Value<String?> s3Key = const Value.absent(),
    Value<String?> s3Url = const Value.absent(),
    Value<String?> error = const Value.absent(),
    DateTime? createdAt,
    Value<DateTime?> lastAttemptAt = const Value.absent(),
  }) => ImageSyncQueueRecord(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityUID: entityUID ?? this.entityUID,
    contextField: contextField ?? this.contextField,
    sequence: sequence ?? this.sequence,
    localFilePath: localFilePath ?? this.localFilePath,
    fileName: fileName ?? this.fileName,
    mimeType: mimeType ?? this.mimeType,
    fileSize: fileSize ?? this.fileSize,
    companyUID: companyUID ?? this.companyUID,
    uploadedByUID: uploadedByUID ?? this.uploadedByUID,
    syncStatus: syncStatus ?? this.syncStatus,
    retryCount: retryCount ?? this.retryCount,
    maxRetries: maxRetries ?? this.maxRetries,
    fileUID: fileUID.present ? fileUID.value : this.fileUID,
    s3Key: s3Key.present ? s3Key.value : this.s3Key,
    s3Url: s3Url.present ? s3Url.value : this.s3Url,
    error: error.present ? error.value : this.error,
    createdAt: createdAt ?? this.createdAt,
    lastAttemptAt: lastAttemptAt.present
        ? lastAttemptAt.value
        : this.lastAttemptAt,
  );
  ImageSyncQueueRecord copyWithCompanion(ImageSyncQueueCompanion data) {
    return ImageSyncQueueRecord(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityUID: data.entityUID.present ? data.entityUID.value : this.entityUID,
      contextField: data.contextField.present
          ? data.contextField.value
          : this.contextField,
      sequence: data.sequence.present ? data.sequence.value : this.sequence,
      localFilePath: data.localFilePath.present
          ? data.localFilePath.value
          : this.localFilePath,
      fileName: data.fileName.present ? data.fileName.value : this.fileName,
      mimeType: data.mimeType.present ? data.mimeType.value : this.mimeType,
      fileSize: data.fileSize.present ? data.fileSize.value : this.fileSize,
      companyUID: data.companyUID.present
          ? data.companyUID.value
          : this.companyUID,
      uploadedByUID: data.uploadedByUID.present
          ? data.uploadedByUID.value
          : this.uploadedByUID,
      syncStatus: data.syncStatus.present
          ? data.syncStatus.value
          : this.syncStatus,
      retryCount: data.retryCount.present
          ? data.retryCount.value
          : this.retryCount,
      maxRetries: data.maxRetries.present
          ? data.maxRetries.value
          : this.maxRetries,
      fileUID: data.fileUID.present ? data.fileUID.value : this.fileUID,
      s3Key: data.s3Key.present ? data.s3Key.value : this.s3Key,
      s3Url: data.s3Url.present ? data.s3Url.value : this.s3Url,
      error: data.error.present ? data.error.value : this.error,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      lastAttemptAt: data.lastAttemptAt.present
          ? data.lastAttemptAt.value
          : this.lastAttemptAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ImageSyncQueueRecord(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityUID: $entityUID, ')
          ..write('contextField: $contextField, ')
          ..write('sequence: $sequence, ')
          ..write('localFilePath: $localFilePath, ')
          ..write('fileName: $fileName, ')
          ..write('mimeType: $mimeType, ')
          ..write('fileSize: $fileSize, ')
          ..write('companyUID: $companyUID, ')
          ..write('uploadedByUID: $uploadedByUID, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('retryCount: $retryCount, ')
          ..write('maxRetries: $maxRetries, ')
          ..write('fileUID: $fileUID, ')
          ..write('s3Key: $s3Key, ')
          ..write('s3Url: $s3Url, ')
          ..write('error: $error, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastAttemptAt: $lastAttemptAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityUID,
    contextField,
    sequence,
    localFilePath,
    fileName,
    mimeType,
    fileSize,
    companyUID,
    uploadedByUID,
    syncStatus,
    retryCount,
    maxRetries,
    fileUID,
    s3Key,
    s3Url,
    error,
    createdAt,
    lastAttemptAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ImageSyncQueueRecord &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityUID == this.entityUID &&
          other.contextField == this.contextField &&
          other.sequence == this.sequence &&
          other.localFilePath == this.localFilePath &&
          other.fileName == this.fileName &&
          other.mimeType == this.mimeType &&
          other.fileSize == this.fileSize &&
          other.companyUID == this.companyUID &&
          other.uploadedByUID == this.uploadedByUID &&
          other.syncStatus == this.syncStatus &&
          other.retryCount == this.retryCount &&
          other.maxRetries == this.maxRetries &&
          other.fileUID == this.fileUID &&
          other.s3Key == this.s3Key &&
          other.s3Url == this.s3Url &&
          other.error == this.error &&
          other.createdAt == this.createdAt &&
          other.lastAttemptAt == this.lastAttemptAt);
}

class ImageSyncQueueCompanion extends UpdateCompanion<ImageSyncQueueRecord> {
  final Value<int> id;
  final Value<String> entityType;
  final Value<String> entityUID;
  final Value<String> contextField;
  final Value<int> sequence;
  final Value<String> localFilePath;
  final Value<String> fileName;
  final Value<String> mimeType;
  final Value<int> fileSize;
  final Value<String> companyUID;
  final Value<String> uploadedByUID;
  final Value<String> syncStatus;
  final Value<int> retryCount;
  final Value<int> maxRetries;
  final Value<String?> fileUID;
  final Value<String?> s3Key;
  final Value<String?> s3Url;
  final Value<String?> error;
  final Value<DateTime> createdAt;
  final Value<DateTime?> lastAttemptAt;
  const ImageSyncQueueCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityUID = const Value.absent(),
    this.contextField = const Value.absent(),
    this.sequence = const Value.absent(),
    this.localFilePath = const Value.absent(),
    this.fileName = const Value.absent(),
    this.mimeType = const Value.absent(),
    this.fileSize = const Value.absent(),
    this.companyUID = const Value.absent(),
    this.uploadedByUID = const Value.absent(),
    this.syncStatus = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.maxRetries = const Value.absent(),
    this.fileUID = const Value.absent(),
    this.s3Key = const Value.absent(),
    this.s3Url = const Value.absent(),
    this.error = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastAttemptAt = const Value.absent(),
  });
  ImageSyncQueueCompanion.insert({
    this.id = const Value.absent(),
    required String entityType,
    required String entityUID,
    required String contextField,
    required int sequence,
    required String localFilePath,
    required String fileName,
    required String mimeType,
    required int fileSize,
    required String companyUID,
    required String uploadedByUID,
    required String syncStatus,
    this.retryCount = const Value.absent(),
    this.maxRetries = const Value.absent(),
    this.fileUID = const Value.absent(),
    this.s3Key = const Value.absent(),
    this.s3Url = const Value.absent(),
    this.error = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastAttemptAt = const Value.absent(),
  }) : entityType = Value(entityType),
       entityUID = Value(entityUID),
       contextField = Value(contextField),
       sequence = Value(sequence),
       localFilePath = Value(localFilePath),
       fileName = Value(fileName),
       mimeType = Value(mimeType),
       fileSize = Value(fileSize),
       companyUID = Value(companyUID),
       uploadedByUID = Value(uploadedByUID),
       syncStatus = Value(syncStatus);
  static Insertable<ImageSyncQueueRecord> custom({
    Expression<int>? id,
    Expression<String>? entityType,
    Expression<String>? entityUID,
    Expression<String>? contextField,
    Expression<int>? sequence,
    Expression<String>? localFilePath,
    Expression<String>? fileName,
    Expression<String>? mimeType,
    Expression<int>? fileSize,
    Expression<String>? companyUID,
    Expression<String>? uploadedByUID,
    Expression<String>? syncStatus,
    Expression<int>? retryCount,
    Expression<int>? maxRetries,
    Expression<String>? fileUID,
    Expression<String>? s3Key,
    Expression<String>? s3Url,
    Expression<String>? error,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? lastAttemptAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityUID != null) 'entity_u_i_d': entityUID,
      if (contextField != null) 'context_field': contextField,
      if (sequence != null) 'sequence': sequence,
      if (localFilePath != null) 'local_file_path': localFilePath,
      if (fileName != null) 'file_name': fileName,
      if (mimeType != null) 'mime_type': mimeType,
      if (fileSize != null) 'file_size': fileSize,
      if (companyUID != null) 'company_u_i_d': companyUID,
      if (uploadedByUID != null) 'uploaded_by_u_i_d': uploadedByUID,
      if (syncStatus != null) 'sync_status': syncStatus,
      if (retryCount != null) 'retry_count': retryCount,
      if (maxRetries != null) 'max_retries': maxRetries,
      if (fileUID != null) 'file_u_i_d': fileUID,
      if (s3Key != null) 's3_key': s3Key,
      if (s3Url != null) 's3_url': s3Url,
      if (error != null) 'error': error,
      if (createdAt != null) 'created_at': createdAt,
      if (lastAttemptAt != null) 'last_attempt_at': lastAttemptAt,
    });
  }

  ImageSyncQueueCompanion copyWith({
    Value<int>? id,
    Value<String>? entityType,
    Value<String>? entityUID,
    Value<String>? contextField,
    Value<int>? sequence,
    Value<String>? localFilePath,
    Value<String>? fileName,
    Value<String>? mimeType,
    Value<int>? fileSize,
    Value<String>? companyUID,
    Value<String>? uploadedByUID,
    Value<String>? syncStatus,
    Value<int>? retryCount,
    Value<int>? maxRetries,
    Value<String?>? fileUID,
    Value<String?>? s3Key,
    Value<String?>? s3Url,
    Value<String?>? error,
    Value<DateTime>? createdAt,
    Value<DateTime?>? lastAttemptAt,
  }) {
    return ImageSyncQueueCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityUID: entityUID ?? this.entityUID,
      contextField: contextField ?? this.contextField,
      sequence: sequence ?? this.sequence,
      localFilePath: localFilePath ?? this.localFilePath,
      fileName: fileName ?? this.fileName,
      mimeType: mimeType ?? this.mimeType,
      fileSize: fileSize ?? this.fileSize,
      companyUID: companyUID ?? this.companyUID,
      uploadedByUID: uploadedByUID ?? this.uploadedByUID,
      syncStatus: syncStatus ?? this.syncStatus,
      retryCount: retryCount ?? this.retryCount,
      maxRetries: maxRetries ?? this.maxRetries,
      fileUID: fileUID ?? this.fileUID,
      s3Key: s3Key ?? this.s3Key,
      s3Url: s3Url ?? this.s3Url,
      error: error ?? this.error,
      createdAt: createdAt ?? this.createdAt,
      lastAttemptAt: lastAttemptAt ?? this.lastAttemptAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityUID.present) {
      map['entity_u_i_d'] = Variable<String>(entityUID.value);
    }
    if (contextField.present) {
      map['context_field'] = Variable<String>(contextField.value);
    }
    if (sequence.present) {
      map['sequence'] = Variable<int>(sequence.value);
    }
    if (localFilePath.present) {
      map['local_file_path'] = Variable<String>(localFilePath.value);
    }
    if (fileName.present) {
      map['file_name'] = Variable<String>(fileName.value);
    }
    if (mimeType.present) {
      map['mime_type'] = Variable<String>(mimeType.value);
    }
    if (fileSize.present) {
      map['file_size'] = Variable<int>(fileSize.value);
    }
    if (companyUID.present) {
      map['company_u_i_d'] = Variable<String>(companyUID.value);
    }
    if (uploadedByUID.present) {
      map['uploaded_by_u_i_d'] = Variable<String>(uploadedByUID.value);
    }
    if (syncStatus.present) {
      map['sync_status'] = Variable<String>(syncStatus.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (maxRetries.present) {
      map['max_retries'] = Variable<int>(maxRetries.value);
    }
    if (fileUID.present) {
      map['file_u_i_d'] = Variable<String>(fileUID.value);
    }
    if (s3Key.present) {
      map['s3_key'] = Variable<String>(s3Key.value);
    }
    if (s3Url.present) {
      map['s3_url'] = Variable<String>(s3Url.value);
    }
    if (error.present) {
      map['error'] = Variable<String>(error.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (lastAttemptAt.present) {
      map['last_attempt_at'] = Variable<DateTime>(lastAttemptAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ImageSyncQueueCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityUID: $entityUID, ')
          ..write('contextField: $contextField, ')
          ..write('sequence: $sequence, ')
          ..write('localFilePath: $localFilePath, ')
          ..write('fileName: $fileName, ')
          ..write('mimeType: $mimeType, ')
          ..write('fileSize: $fileSize, ')
          ..write('companyUID: $companyUID, ')
          ..write('uploadedByUID: $uploadedByUID, ')
          ..write('syncStatus: $syncStatus, ')
          ..write('retryCount: $retryCount, ')
          ..write('maxRetries: $maxRetries, ')
          ..write('fileUID: $fileUID, ')
          ..write('s3Key: $s3Key, ')
          ..write('s3Url: $s3Url, ')
          ..write('error: $error, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastAttemptAt: $lastAttemptAt')
          ..write(')'))
        .toString();
  }
}

class $FilesTable extends Files with TableInfo<$FilesTable, FileRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FilesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fileNameMeta = const VerificationMeta(
    'fileName',
  );
  @override
  late final GeneratedColumn<String> fileName = GeneratedColumn<String>(
    'file_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _s3UrlMeta = const VerificationMeta('s3Url');
  @override
  late final GeneratedColumn<String> s3Url = GeneratedColumn<String>(
    's3_url',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _mimeTypeMeta = const VerificationMeta(
    'mimeType',
  );
  @override
  late final GeneratedColumn<String> mimeType = GeneratedColumn<String>(
    'mime_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sizeMeta = const VerificationMeta('size');
  @override
  late final GeneratedColumn<int> size = GeneratedColumn<int>(
    'size',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sequenceMeta = const VerificationMeta(
    'sequence',
  );
  @override
  late final GeneratedColumn<int> sequence = GeneratedColumn<int>(
    'sequence',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _companyIDMeta = const VerificationMeta(
    'companyID',
  );
  @override
  late final GeneratedColumn<int> companyID = GeneratedColumn<int>(
    'company_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contextTypeMeta = const VerificationMeta(
    'contextType',
  );
  @override
  late final GeneratedColumn<String> contextType = GeneratedColumn<String>(
    'context_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contextFieldMeta = const VerificationMeta(
    'contextField',
  );
  @override
  late final GeneratedColumn<String> contextField = GeneratedColumn<String>(
    'context_field',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _dailyReportIDMeta = const VerificationMeta(
    'dailyReportID',
  );
  @override
  late final GeneratedColumn<int> dailyReportID = GeneratedColumn<int>(
    'daily_report_i_d',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _uploadedByIDMeta = const VerificationMeta(
    'uploadedByID',
  );
  @override
  late final GeneratedColumn<int> uploadedByID = GeneratedColumn<int>(
    'uploaded_by_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    fileName,
    s3Url,
    mimeType,
    size,
    sequence,
    companyID,
    contextType,
    contextField,
    dailyReportID,
    uploadedByID,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'files';
  @override
  VerificationContext validateIntegrity(
    Insertable<FileRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('file_name')) {
      context.handle(
        _fileNameMeta,
        fileName.isAcceptableOrUnknown(data['file_name']!, _fileNameMeta),
      );
    } else if (isInserting) {
      context.missing(_fileNameMeta);
    }
    if (data.containsKey('s3_url')) {
      context.handle(
        _s3UrlMeta,
        s3Url.isAcceptableOrUnknown(data['s3_url']!, _s3UrlMeta),
      );
    } else if (isInserting) {
      context.missing(_s3UrlMeta);
    }
    if (data.containsKey('mime_type')) {
      context.handle(
        _mimeTypeMeta,
        mimeType.isAcceptableOrUnknown(data['mime_type']!, _mimeTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_mimeTypeMeta);
    }
    if (data.containsKey('size')) {
      context.handle(
        _sizeMeta,
        size.isAcceptableOrUnknown(data['size']!, _sizeMeta),
      );
    } else if (isInserting) {
      context.missing(_sizeMeta);
    }
    if (data.containsKey('sequence')) {
      context.handle(
        _sequenceMeta,
        sequence.isAcceptableOrUnknown(data['sequence']!, _sequenceMeta),
      );
    }
    if (data.containsKey('company_i_d')) {
      context.handle(
        _companyIDMeta,
        companyID.isAcceptableOrUnknown(data['company_i_d']!, _companyIDMeta),
      );
    } else if (isInserting) {
      context.missing(_companyIDMeta);
    }
    if (data.containsKey('context_type')) {
      context.handle(
        _contextTypeMeta,
        contextType.isAcceptableOrUnknown(
          data['context_type']!,
          _contextTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_contextTypeMeta);
    }
    if (data.containsKey('context_field')) {
      context.handle(
        _contextFieldMeta,
        contextField.isAcceptableOrUnknown(
          data['context_field']!,
          _contextFieldMeta,
        ),
      );
    }
    if (data.containsKey('daily_report_i_d')) {
      context.handle(
        _dailyReportIDMeta,
        dailyReportID.isAcceptableOrUnknown(
          data['daily_report_i_d']!,
          _dailyReportIDMeta,
        ),
      );
    }
    if (data.containsKey('uploaded_by_i_d')) {
      context.handle(
        _uploadedByIDMeta,
        uploadedByID.isAcceptableOrUnknown(
          data['uploaded_by_i_d']!,
          _uploadedByIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_uploadedByIDMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  FileRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FileRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      fileName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}file_name'],
      )!,
      s3Url: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}s3_url'],
      )!,
      mimeType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}mime_type'],
      )!,
      size: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}size'],
      )!,
      sequence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sequence'],
      ),
      companyID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}company_i_d'],
      )!,
      contextType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}context_type'],
      )!,
      contextField: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}context_field'],
      ),
      dailyReportID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}daily_report_i_d'],
      ),
      uploadedByID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}uploaded_by_i_d'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $FilesTable createAlias(String alias) {
    return $FilesTable(attachedDatabase, alias);
  }
}

class FileRecord extends DataClass implements Insertable<FileRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String fileName;
  final String s3Url;
  final String mimeType;
  final int size;
  final int? sequence;
  final int companyID;
  final String contextType;
  final String? contextField;
  final int? dailyReportID;
  final int uploadedByID;
  final DateTime createdAt;
  final DateTime updatedAt;
  const FileRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.fileName,
    required this.s3Url,
    required this.mimeType,
    required this.size,
    this.sequence,
    required this.companyID,
    required this.contextType,
    this.contextField,
    this.dailyReportID,
    required this.uploadedByID,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['file_name'] = Variable<String>(fileName);
    map['s3_url'] = Variable<String>(s3Url);
    map['mime_type'] = Variable<String>(mimeType);
    map['size'] = Variable<int>(size);
    if (!nullToAbsent || sequence != null) {
      map['sequence'] = Variable<int>(sequence);
    }
    map['company_i_d'] = Variable<int>(companyID);
    map['context_type'] = Variable<String>(contextType);
    if (!nullToAbsent || contextField != null) {
      map['context_field'] = Variable<String>(contextField);
    }
    if (!nullToAbsent || dailyReportID != null) {
      map['daily_report_i_d'] = Variable<int>(dailyReportID);
    }
    map['uploaded_by_i_d'] = Variable<int>(uploadedByID);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  FilesCompanion toCompanion(bool nullToAbsent) {
    return FilesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      fileName: Value(fileName),
      s3Url: Value(s3Url),
      mimeType: Value(mimeType),
      size: Value(size),
      sequence: sequence == null && nullToAbsent
          ? const Value.absent()
          : Value(sequence),
      companyID: Value(companyID),
      contextType: Value(contextType),
      contextField: contextField == null && nullToAbsent
          ? const Value.absent()
          : Value(contextField),
      dailyReportID: dailyReportID == null && nullToAbsent
          ? const Value.absent()
          : Value(dailyReportID),
      uploadedByID: Value(uploadedByID),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory FileRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FileRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      fileName: serializer.fromJson<String>(json['fileName']),
      s3Url: serializer.fromJson<String>(json['s3Url']),
      mimeType: serializer.fromJson<String>(json['mimeType']),
      size: serializer.fromJson<int>(json['size']),
      sequence: serializer.fromJson<int?>(json['sequence']),
      companyID: serializer.fromJson<int>(json['companyID']),
      contextType: serializer.fromJson<String>(json['contextType']),
      contextField: serializer.fromJson<String?>(json['contextField']),
      dailyReportID: serializer.fromJson<int?>(json['dailyReportID']),
      uploadedByID: serializer.fromJson<int>(json['uploadedByID']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'fileName': serializer.toJson<String>(fileName),
      's3Url': serializer.toJson<String>(s3Url),
      'mimeType': serializer.toJson<String>(mimeType),
      'size': serializer.toJson<int>(size),
      'sequence': serializer.toJson<int?>(sequence),
      'companyID': serializer.toJson<int>(companyID),
      'contextType': serializer.toJson<String>(contextType),
      'contextField': serializer.toJson<String?>(contextField),
      'dailyReportID': serializer.toJson<int?>(dailyReportID),
      'uploadedByID': serializer.toJson<int>(uploadedByID),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  FileRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? fileName,
    String? s3Url,
    String? mimeType,
    int? size,
    Value<int?> sequence = const Value.absent(),
    int? companyID,
    String? contextType,
    Value<String?> contextField = const Value.absent(),
    Value<int?> dailyReportID = const Value.absent(),
    int? uploadedByID,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => FileRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    fileName: fileName ?? this.fileName,
    s3Url: s3Url ?? this.s3Url,
    mimeType: mimeType ?? this.mimeType,
    size: size ?? this.size,
    sequence: sequence.present ? sequence.value : this.sequence,
    companyID: companyID ?? this.companyID,
    contextType: contextType ?? this.contextType,
    contextField: contextField.present ? contextField.value : this.contextField,
    dailyReportID: dailyReportID.present
        ? dailyReportID.value
        : this.dailyReportID,
    uploadedByID: uploadedByID ?? this.uploadedByID,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  FileRecord copyWithCompanion(FilesCompanion data) {
    return FileRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      fileName: data.fileName.present ? data.fileName.value : this.fileName,
      s3Url: data.s3Url.present ? data.s3Url.value : this.s3Url,
      mimeType: data.mimeType.present ? data.mimeType.value : this.mimeType,
      size: data.size.present ? data.size.value : this.size,
      sequence: data.sequence.present ? data.sequence.value : this.sequence,
      companyID: data.companyID.present ? data.companyID.value : this.companyID,
      contextType: data.contextType.present
          ? data.contextType.value
          : this.contextType,
      contextField: data.contextField.present
          ? data.contextField.value
          : this.contextField,
      dailyReportID: data.dailyReportID.present
          ? data.dailyReportID.value
          : this.dailyReportID,
      uploadedByID: data.uploadedByID.present
          ? data.uploadedByID.value
          : this.uploadedByID,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FileRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('fileName: $fileName, ')
          ..write('s3Url: $s3Url, ')
          ..write('mimeType: $mimeType, ')
          ..write('size: $size, ')
          ..write('sequence: $sequence, ')
          ..write('companyID: $companyID, ')
          ..write('contextType: $contextType, ')
          ..write('contextField: $contextField, ')
          ..write('dailyReportID: $dailyReportID, ')
          ..write('uploadedByID: $uploadedByID, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    fileName,
    s3Url,
    mimeType,
    size,
    sequence,
    companyID,
    contextType,
    contextField,
    dailyReportID,
    uploadedByID,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FileRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.fileName == this.fileName &&
          other.s3Url == this.s3Url &&
          other.mimeType == this.mimeType &&
          other.size == this.size &&
          other.sequence == this.sequence &&
          other.companyID == this.companyID &&
          other.contextType == this.contextType &&
          other.contextField == this.contextField &&
          other.dailyReportID == this.dailyReportID &&
          other.uploadedByID == this.uploadedByID &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class FilesCompanion extends UpdateCompanion<FileRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> fileName;
  final Value<String> s3Url;
  final Value<String> mimeType;
  final Value<int> size;
  final Value<int?> sequence;
  final Value<int> companyID;
  final Value<String> contextType;
  final Value<String?> contextField;
  final Value<int?> dailyReportID;
  final Value<int> uploadedByID;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const FilesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.fileName = const Value.absent(),
    this.s3Url = const Value.absent(),
    this.mimeType = const Value.absent(),
    this.size = const Value.absent(),
    this.sequence = const Value.absent(),
    this.companyID = const Value.absent(),
    this.contextType = const Value.absent(),
    this.contextField = const Value.absent(),
    this.dailyReportID = const Value.absent(),
    this.uploadedByID = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  FilesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String fileName,
    required String s3Url,
    required String mimeType,
    required int size,
    this.sequence = const Value.absent(),
    required int companyID,
    required String contextType,
    this.contextField = const Value.absent(),
    this.dailyReportID = const Value.absent(),
    required int uploadedByID,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       fileName = Value(fileName),
       s3Url = Value(s3Url),
       mimeType = Value(mimeType),
       size = Value(size),
       companyID = Value(companyID),
       contextType = Value(contextType),
       uploadedByID = Value(uploadedByID),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<FileRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? fileName,
    Expression<String>? s3Url,
    Expression<String>? mimeType,
    Expression<int>? size,
    Expression<int>? sequence,
    Expression<int>? companyID,
    Expression<String>? contextType,
    Expression<String>? contextField,
    Expression<int>? dailyReportID,
    Expression<int>? uploadedByID,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (fileName != null) 'file_name': fileName,
      if (s3Url != null) 's3_url': s3Url,
      if (mimeType != null) 'mime_type': mimeType,
      if (size != null) 'size': size,
      if (sequence != null) 'sequence': sequence,
      if (companyID != null) 'company_i_d': companyID,
      if (contextType != null) 'context_type': contextType,
      if (contextField != null) 'context_field': contextField,
      if (dailyReportID != null) 'daily_report_i_d': dailyReportID,
      if (uploadedByID != null) 'uploaded_by_i_d': uploadedByID,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  FilesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? fileName,
    Value<String>? s3Url,
    Value<String>? mimeType,
    Value<int>? size,
    Value<int?>? sequence,
    Value<int>? companyID,
    Value<String>? contextType,
    Value<String?>? contextField,
    Value<int?>? dailyReportID,
    Value<int>? uploadedByID,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return FilesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      fileName: fileName ?? this.fileName,
      s3Url: s3Url ?? this.s3Url,
      mimeType: mimeType ?? this.mimeType,
      size: size ?? this.size,
      sequence: sequence ?? this.sequence,
      companyID: companyID ?? this.companyID,
      contextType: contextType ?? this.contextType,
      contextField: contextField ?? this.contextField,
      dailyReportID: dailyReportID ?? this.dailyReportID,
      uploadedByID: uploadedByID ?? this.uploadedByID,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (fileName.present) {
      map['file_name'] = Variable<String>(fileName.value);
    }
    if (s3Url.present) {
      map['s3_url'] = Variable<String>(s3Url.value);
    }
    if (mimeType.present) {
      map['mime_type'] = Variable<String>(mimeType.value);
    }
    if (size.present) {
      map['size'] = Variable<int>(size.value);
    }
    if (sequence.present) {
      map['sequence'] = Variable<int>(sequence.value);
    }
    if (companyID.present) {
      map['company_i_d'] = Variable<int>(companyID.value);
    }
    if (contextType.present) {
      map['context_type'] = Variable<String>(contextType.value);
    }
    if (contextField.present) {
      map['context_field'] = Variable<String>(contextField.value);
    }
    if (dailyReportID.present) {
      map['daily_report_i_d'] = Variable<int>(dailyReportID.value);
    }
    if (uploadedByID.present) {
      map['uploaded_by_i_d'] = Variable<int>(uploadedByID.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FilesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('fileName: $fileName, ')
          ..write('s3Url: $s3Url, ')
          ..write('mimeType: $mimeType, ')
          ..write('size: $size, ')
          ..write('sequence: $sequence, ')
          ..write('companyID: $companyID, ')
          ..write('contextType: $contextType, ')
          ..write('contextField: $contextField, ')
          ..write('dailyReportID: $dailyReportID, ')
          ..write('uploadedByID: $uploadedByID, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $RolesTable extends Roles with TableInfo<$RolesTable, RoleRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RolesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _companyIDMeta = const VerificationMeta(
    'companyID',
  );
  @override
  late final GeneratedColumn<int> companyID = GeneratedColumn<int>(
    'company_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isSystemRoleMeta = const VerificationMeta(
    'isSystemRole',
  );
  @override
  late final GeneratedColumn<bool> isSystemRole = GeneratedColumn<bool>(
    'is_system_role',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_system_role" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    description,
    companyID,
    isSystemRole,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'roles';
  @override
  VerificationContext validateIntegrity(
    Insertable<RoleRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('company_i_d')) {
      context.handle(
        _companyIDMeta,
        companyID.isAcceptableOrUnknown(data['company_i_d']!, _companyIDMeta),
      );
    } else if (isInserting) {
      context.missing(_companyIDMeta);
    }
    if (data.containsKey('is_system_role')) {
      context.handle(
        _isSystemRoleMeta,
        isSystemRole.isAcceptableOrUnknown(
          data['is_system_role']!,
          _isSystemRoleMeta,
        ),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RoleRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RoleRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      companyID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}company_i_d'],
      )!,
      isSystemRole: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_system_role'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $RolesTable createAlias(String alias) {
    return $RolesTable(attachedDatabase, alias);
  }
}

class RoleRecord extends DataClass implements Insertable<RoleRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final String? description;
  final int companyID;
  final bool isSystemRole;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const RoleRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    this.description,
    required this.companyID,
    required this.isSystemRole,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['company_i_d'] = Variable<int>(companyID);
    map['is_system_role'] = Variable<bool>(isSystemRole);
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  RolesCompanion toCompanion(bool nullToAbsent) {
    return RolesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      companyID: Value(companyID),
      isSystemRole: Value(isSystemRole),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory RoleRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RoleRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      companyID: serializer.fromJson<int>(json['companyID']),
      isSystemRole: serializer.fromJson<bool>(json['isSystemRole']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'companyID': serializer.toJson<int>(companyID),
      'isSystemRole': serializer.toJson<bool>(isSystemRole),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  RoleRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    Value<String?> description = const Value.absent(),
    int? companyID,
    bool? isSystemRole,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => RoleRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    companyID: companyID ?? this.companyID,
    isSystemRole: isSystemRole ?? this.isSystemRole,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  RoleRecord copyWithCompanion(RolesCompanion data) {
    return RoleRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      companyID: data.companyID.present ? data.companyID.value : this.companyID,
      isSystemRole: data.isSystemRole.present
          ? data.isSystemRole.value
          : this.isSystemRole,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RoleRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('companyID: $companyID, ')
          ..write('isSystemRole: $isSystemRole, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    description,
    companyID,
    isSystemRole,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RoleRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.description == this.description &&
          other.companyID == this.companyID &&
          other.isSystemRole == this.isSystemRole &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class RolesCompanion extends UpdateCompanion<RoleRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String?> description;
  final Value<int> companyID;
  final Value<bool> isSystemRole;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const RolesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.companyID = const Value.absent(),
    this.isSystemRole = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  RolesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    this.description = const Value.absent(),
    required int companyID,
    this.isSystemRole = const Value.absent(),
    this.isActive = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       name = Value(name),
       companyID = Value(companyID),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<RoleRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? companyID,
    Expression<bool>? isSystemRole,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (companyID != null) 'company_i_d': companyID,
      if (isSystemRole != null) 'is_system_role': isSystemRole,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  RolesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String?>? description,
    Value<int>? companyID,
    Value<bool>? isSystemRole,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return RolesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      description: description ?? this.description,
      companyID: companyID ?? this.companyID,
      isSystemRole: isSystemRole ?? this.isSystemRole,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (companyID.present) {
      map['company_i_d'] = Variable<int>(companyID.value);
    }
    if (isSystemRole.present) {
      map['is_system_role'] = Variable<bool>(isSystemRole.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RolesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('companyID: $companyID, ')
          ..write('isSystemRole: $isSystemRole, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $PermissionsTable extends Permissions
    with TableInfo<$PermissionsTable, PermissionRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PermissionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _scopeMeta = const VerificationMeta('scope');
  @override
  late final GeneratedColumn<String> scope = GeneratedColumn<String>(
    'scope',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roleIDMeta = const VerificationMeta('roleID');
  @override
  late final GeneratedColumn<int> roleID = GeneratedColumn<int>(
    'role_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    code,
    name,
    description,
    category,
    scope,
    roleID,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'permissions';
  @override
  VerificationContext validateIntegrity(
    Insertable<PermissionRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('scope')) {
      context.handle(
        _scopeMeta,
        scope.isAcceptableOrUnknown(data['scope']!, _scopeMeta),
      );
    } else if (isInserting) {
      context.missing(_scopeMeta);
    }
    if (data.containsKey('role_i_d')) {
      context.handle(
        _roleIDMeta,
        roleID.isAcceptableOrUnknown(data['role_i_d']!, _roleIDMeta),
      );
    } else if (isInserting) {
      context.missing(_roleIDMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  PermissionRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PermissionRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      )!,
      scope: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}scope'],
      )!,
      roleID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}role_i_d'],
      )!,
    );
  }

  @override
  $PermissionsTable createAlias(String alias) {
    return $PermissionsTable(attachedDatabase, alias);
  }
}

class PermissionRecord extends DataClass
    implements Insertable<PermissionRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String code;
  final String name;
  final String? description;
  final String category;
  final String scope;
  final int roleID;
  const PermissionRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.code,
    required this.name,
    this.description,
    required this.category,
    required this.scope,
    required this.roleID,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['code'] = Variable<String>(code);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['category'] = Variable<String>(category);
    map['scope'] = Variable<String>(scope);
    map['role_i_d'] = Variable<int>(roleID);
    return map;
  }

  PermissionsCompanion toCompanion(bool nullToAbsent) {
    return PermissionsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      code: Value(code),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      category: Value(category),
      scope: Value(scope),
      roleID: Value(roleID),
    );
  }

  factory PermissionRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PermissionRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      code: serializer.fromJson<String>(json['code']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      category: serializer.fromJson<String>(json['category']),
      scope: serializer.fromJson<String>(json['scope']),
      roleID: serializer.fromJson<int>(json['roleID']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'code': serializer.toJson<String>(code),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'category': serializer.toJson<String>(category),
      'scope': serializer.toJson<String>(scope),
      'roleID': serializer.toJson<int>(roleID),
    };
  }

  PermissionRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? code,
    String? name,
    Value<String?> description = const Value.absent(),
    String? category,
    String? scope,
    int? roleID,
  }) => PermissionRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    code: code ?? this.code,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    category: category ?? this.category,
    scope: scope ?? this.scope,
    roleID: roleID ?? this.roleID,
  );
  PermissionRecord copyWithCompanion(PermissionsCompanion data) {
    return PermissionRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      code: data.code.present ? data.code.value : this.code,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      category: data.category.present ? data.category.value : this.category,
      scope: data.scope.present ? data.scope.value : this.scope,
      roleID: data.roleID.present ? data.roleID.value : this.roleID,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PermissionRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('category: $category, ')
          ..write('scope: $scope, ')
          ..write('roleID: $roleID')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    code,
    name,
    description,
    category,
    scope,
    roleID,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PermissionRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.code == this.code &&
          other.name == this.name &&
          other.description == this.description &&
          other.category == this.category &&
          other.scope == this.scope &&
          other.roleID == this.roleID);
}

class PermissionsCompanion extends UpdateCompanion<PermissionRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> code;
  final Value<String> name;
  final Value<String?> description;
  final Value<String> category;
  final Value<String> scope;
  final Value<int> roleID;
  const PermissionsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.code = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.category = const Value.absent(),
    this.scope = const Value.absent(),
    this.roleID = const Value.absent(),
  });
  PermissionsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String code,
    required String name,
    this.description = const Value.absent(),
    required String category,
    required String scope,
    required int roleID,
  }) : uid = Value(uid),
       code = Value(code),
       name = Value(name),
       category = Value(category),
       scope = Value(scope),
       roleID = Value(roleID);
  static Insertable<PermissionRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? code,
    Expression<String>? name,
    Expression<String>? description,
    Expression<String>? category,
    Expression<String>? scope,
    Expression<int>? roleID,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (code != null) 'code': code,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (category != null) 'category': category,
      if (scope != null) 'scope': scope,
      if (roleID != null) 'role_i_d': roleID,
    });
  }

  PermissionsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? code,
    Value<String>? name,
    Value<String?>? description,
    Value<String>? category,
    Value<String>? scope,
    Value<int>? roleID,
  }) {
    return PermissionsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      code: code ?? this.code,
      name: name ?? this.name,
      description: description ?? this.description,
      category: category ?? this.category,
      scope: scope ?? this.scope,
      roleID: roleID ?? this.roleID,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (scope.present) {
      map['scope'] = Variable<String>(scope.value);
    }
    if (roleID.present) {
      map['role_i_d'] = Variable<int>(roleID.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PermissionsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('code: $code, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('category: $category, ')
          ..write('scope: $scope, ')
          ..write('roleID: $roleID')
          ..write(')'))
        .toString();
  }
}

class $CompaniesTable extends Companies
    with TableInfo<$CompaniesTable, CompanyRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CompaniesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _regNoMeta = const VerificationMeta('regNo');
  @override
  late final GeneratedColumn<String> regNo = GeneratedColumn<String>(
    'reg_no',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cidbNoMeta = const VerificationMeta('cidbNo');
  @override
  late final GeneratedColumn<String> cidbNo = GeneratedColumn<String>(
    'cidb_no',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _postalCodeMeta = const VerificationMeta(
    'postalCode',
  );
  @override
  late final GeneratedColumn<String> postalCode = GeneratedColumn<String>(
    'postal_code',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cityMeta = const VerificationMeta('city');
  @override
  late final GeneratedColumn<String> city = GeneratedColumn<String>(
    'city',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _stateMeta = const VerificationMeta('state');
  @override
  late final GeneratedColumn<String> state = GeneratedColumn<String>(
    'state',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _countryMeta = const VerificationMeta(
    'country',
  );
  @override
  late final GeneratedColumn<String> country = GeneratedColumn<String>(
    'country',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _websiteMeta = const VerificationMeta(
    'website',
  );
  @override
  late final GeneratedColumn<String> website = GeneratedColumn<String>(
    'website',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _companyTypeMeta = const VerificationMeta(
    'companyType',
  );
  @override
  late final GeneratedColumn<String> companyType = GeneratedColumn<String>(
    'company_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ownerIDMeta = const VerificationMeta(
    'ownerID',
  );
  @override
  late final GeneratedColumn<int> ownerID = GeneratedColumn<int>(
    'owner_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _defaultBankAccMeta = const VerificationMeta(
    'defaultBankAcc',
  );
  @override
  late final GeneratedColumn<String> defaultBankAcc = GeneratedColumn<String>(
    'default_bank_acc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _defaultBankAccTypeMeta =
      const VerificationMeta('defaultBankAccType');
  @override
  late final GeneratedColumn<String> defaultBankAccType =
      GeneratedColumn<String>(
        'default_bank_acc_type',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _adminRoleUidMeta = const VerificationMeta(
    'adminRoleUid',
  );
  @override
  late final GeneratedColumn<String> adminRoleUid = GeneratedColumn<String>(
    'admin_role_uid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _adminRoleNameMeta = const VerificationMeta(
    'adminRoleName',
  );
  @override
  late final GeneratedColumn<String> adminRoleName = GeneratedColumn<String>(
    'admin_role_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bumiputeraMeta = const VerificationMeta(
    'bumiputera',
  );
  @override
  late final GeneratedColumn<bool> bumiputera = GeneratedColumn<bool>(
    'bumiputera',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("bumiputera" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _einvoiceTinNoMeta = const VerificationMeta(
    'einvoiceTinNo',
  );
  @override
  late final GeneratedColumn<String> einvoiceTinNo = GeneratedColumn<String>(
    'einvoice_tin_no',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _registrationDateMeta = const VerificationMeta(
    'registrationDate',
  );
  @override
  late final GeneratedColumn<DateTime> registrationDate =
      GeneratedColumn<DateTime>(
        'registration_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    uid,
    name,
    regNo,
    cidbNo,
    address,
    postalCode,
    city,
    state,
    country,
    phone,
    email,
    website,
    companyType,
    ownerID,
    defaultBankAcc,
    defaultBankAccType,
    createdAt,
    updatedAt,
    deletedAt,
    adminRoleUid,
    adminRoleName,
    bumiputera,
    einvoiceTinNo,
    registrationDate,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'companies';
  @override
  VerificationContext validateIntegrity(
    Insertable<CompanyRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('reg_no')) {
      context.handle(
        _regNoMeta,
        regNo.isAcceptableOrUnknown(data['reg_no']!, _regNoMeta),
      );
    }
    if (data.containsKey('cidb_no')) {
      context.handle(
        _cidbNoMeta,
        cidbNo.isAcceptableOrUnknown(data['cidb_no']!, _cidbNoMeta),
      );
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    }
    if (data.containsKey('postal_code')) {
      context.handle(
        _postalCodeMeta,
        postalCode.isAcceptableOrUnknown(data['postal_code']!, _postalCodeMeta),
      );
    }
    if (data.containsKey('city')) {
      context.handle(
        _cityMeta,
        city.isAcceptableOrUnknown(data['city']!, _cityMeta),
      );
    }
    if (data.containsKey('state')) {
      context.handle(
        _stateMeta,
        state.isAcceptableOrUnknown(data['state']!, _stateMeta),
      );
    }
    if (data.containsKey('country')) {
      context.handle(
        _countryMeta,
        country.isAcceptableOrUnknown(data['country']!, _countryMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('website')) {
      context.handle(
        _websiteMeta,
        website.isAcceptableOrUnknown(data['website']!, _websiteMeta),
      );
    }
    if (data.containsKey('company_type')) {
      context.handle(
        _companyTypeMeta,
        companyType.isAcceptableOrUnknown(
          data['company_type']!,
          _companyTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_companyTypeMeta);
    }
    if (data.containsKey('owner_i_d')) {
      context.handle(
        _ownerIDMeta,
        ownerID.isAcceptableOrUnknown(data['owner_i_d']!, _ownerIDMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIDMeta);
    }
    if (data.containsKey('default_bank_acc')) {
      context.handle(
        _defaultBankAccMeta,
        defaultBankAcc.isAcceptableOrUnknown(
          data['default_bank_acc']!,
          _defaultBankAccMeta,
        ),
      );
    }
    if (data.containsKey('default_bank_acc_type')) {
      context.handle(
        _defaultBankAccTypeMeta,
        defaultBankAccType.isAcceptableOrUnknown(
          data['default_bank_acc_type']!,
          _defaultBankAccTypeMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('admin_role_uid')) {
      context.handle(
        _adminRoleUidMeta,
        adminRoleUid.isAcceptableOrUnknown(
          data['admin_role_uid']!,
          _adminRoleUidMeta,
        ),
      );
    }
    if (data.containsKey('admin_role_name')) {
      context.handle(
        _adminRoleNameMeta,
        adminRoleName.isAcceptableOrUnknown(
          data['admin_role_name']!,
          _adminRoleNameMeta,
        ),
      );
    }
    if (data.containsKey('bumiputera')) {
      context.handle(
        _bumiputeraMeta,
        bumiputera.isAcceptableOrUnknown(data['bumiputera']!, _bumiputeraMeta),
      );
    }
    if (data.containsKey('einvoice_tin_no')) {
      context.handle(
        _einvoiceTinNoMeta,
        einvoiceTinNo.isAcceptableOrUnknown(
          data['einvoice_tin_no']!,
          _einvoiceTinNoMeta,
        ),
      );
    }
    if (data.containsKey('registration_date')) {
      context.handle(
        _registrationDateMeta,
        registrationDate.isAcceptableOrUnknown(
          data['registration_date']!,
          _registrationDateMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  CompanyRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CompanyRecord(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      regNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reg_no'],
      ),
      cidbNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cidb_no'],
      ),
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      ),
      postalCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}postal_code'],
      ),
      city: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}city'],
      ),
      state: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}state'],
      ),
      country: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}country'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      website: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}website'],
      ),
      companyType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}company_type'],
      )!,
      ownerID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}owner_i_d'],
      )!,
      defaultBankAcc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}default_bank_acc'],
      ),
      defaultBankAccType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}default_bank_acc_type'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      adminRoleUid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}admin_role_uid'],
      ),
      adminRoleName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}admin_role_name'],
      ),
      bumiputera: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}bumiputera'],
      )!,
      einvoiceTinNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}einvoice_tin_no'],
      ),
      registrationDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}registration_date'],
      ),
    );
  }

  @override
  $CompaniesTable createAlias(String alias) {
    return $CompaniesTable(attachedDatabase, alias);
  }
}

class CompanyRecord extends DataClass implements Insertable<CompanyRecord> {
  final int id;
  final String uid;
  final String name;
  final String? regNo;
  final String? cidbNo;
  final String? address;
  final String? postalCode;
  final String? city;
  final String? state;
  final String? country;
  final String? phone;
  final String? email;
  final String? website;
  final String companyType;
  final int ownerID;
  final String? defaultBankAcc;
  final String? defaultBankAccType;
  final DateTime createdAt;
  final DateTime updatedAt;
  final DateTime? deletedAt;
  final String? adminRoleUid;
  final String? adminRoleName;
  final bool bumiputera;
  final String? einvoiceTinNo;
  final DateTime? registrationDate;
  const CompanyRecord({
    required this.id,
    required this.uid,
    required this.name,
    this.regNo,
    this.cidbNo,
    this.address,
    this.postalCode,
    this.city,
    this.state,
    this.country,
    this.phone,
    this.email,
    this.website,
    required this.companyType,
    required this.ownerID,
    this.defaultBankAcc,
    this.defaultBankAccType,
    required this.createdAt,
    required this.updatedAt,
    this.deletedAt,
    this.adminRoleUid,
    this.adminRoleName,
    required this.bumiputera,
    this.einvoiceTinNo,
    this.registrationDate,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || regNo != null) {
      map['reg_no'] = Variable<String>(regNo);
    }
    if (!nullToAbsent || cidbNo != null) {
      map['cidb_no'] = Variable<String>(cidbNo);
    }
    if (!nullToAbsent || address != null) {
      map['address'] = Variable<String>(address);
    }
    if (!nullToAbsent || postalCode != null) {
      map['postal_code'] = Variable<String>(postalCode);
    }
    if (!nullToAbsent || city != null) {
      map['city'] = Variable<String>(city);
    }
    if (!nullToAbsent || state != null) {
      map['state'] = Variable<String>(state);
    }
    if (!nullToAbsent || country != null) {
      map['country'] = Variable<String>(country);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || website != null) {
      map['website'] = Variable<String>(website);
    }
    map['company_type'] = Variable<String>(companyType);
    map['owner_i_d'] = Variable<int>(ownerID);
    if (!nullToAbsent || defaultBankAcc != null) {
      map['default_bank_acc'] = Variable<String>(defaultBankAcc);
    }
    if (!nullToAbsent || defaultBankAccType != null) {
      map['default_bank_acc_type'] = Variable<String>(defaultBankAccType);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || adminRoleUid != null) {
      map['admin_role_uid'] = Variable<String>(adminRoleUid);
    }
    if (!nullToAbsent || adminRoleName != null) {
      map['admin_role_name'] = Variable<String>(adminRoleName);
    }
    map['bumiputera'] = Variable<bool>(bumiputera);
    if (!nullToAbsent || einvoiceTinNo != null) {
      map['einvoice_tin_no'] = Variable<String>(einvoiceTinNo);
    }
    if (!nullToAbsent || registrationDate != null) {
      map['registration_date'] = Variable<DateTime>(registrationDate);
    }
    return map;
  }

  CompaniesCompanion toCompanion(bool nullToAbsent) {
    return CompaniesCompanion(
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      regNo: regNo == null && nullToAbsent
          ? const Value.absent()
          : Value(regNo),
      cidbNo: cidbNo == null && nullToAbsent
          ? const Value.absent()
          : Value(cidbNo),
      address: address == null && nullToAbsent
          ? const Value.absent()
          : Value(address),
      postalCode: postalCode == null && nullToAbsent
          ? const Value.absent()
          : Value(postalCode),
      city: city == null && nullToAbsent ? const Value.absent() : Value(city),
      state: state == null && nullToAbsent
          ? const Value.absent()
          : Value(state),
      country: country == null && nullToAbsent
          ? const Value.absent()
          : Value(country),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      website: website == null && nullToAbsent
          ? const Value.absent()
          : Value(website),
      companyType: Value(companyType),
      ownerID: Value(ownerID),
      defaultBankAcc: defaultBankAcc == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultBankAcc),
      defaultBankAccType: defaultBankAccType == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultBankAccType),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      adminRoleUid: adminRoleUid == null && nullToAbsent
          ? const Value.absent()
          : Value(adminRoleUid),
      adminRoleName: adminRoleName == null && nullToAbsent
          ? const Value.absent()
          : Value(adminRoleName),
      bumiputera: Value(bumiputera),
      einvoiceTinNo: einvoiceTinNo == null && nullToAbsent
          ? const Value.absent()
          : Value(einvoiceTinNo),
      registrationDate: registrationDate == null && nullToAbsent
          ? const Value.absent()
          : Value(registrationDate),
    );
  }

  factory CompanyRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CompanyRecord(
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      regNo: serializer.fromJson<String?>(json['regNo']),
      cidbNo: serializer.fromJson<String?>(json['cidbNo']),
      address: serializer.fromJson<String?>(json['address']),
      postalCode: serializer.fromJson<String?>(json['postalCode']),
      city: serializer.fromJson<String?>(json['city']),
      state: serializer.fromJson<String?>(json['state']),
      country: serializer.fromJson<String?>(json['country']),
      phone: serializer.fromJson<String?>(json['phone']),
      email: serializer.fromJson<String?>(json['email']),
      website: serializer.fromJson<String?>(json['website']),
      companyType: serializer.fromJson<String>(json['companyType']),
      ownerID: serializer.fromJson<int>(json['ownerID']),
      defaultBankAcc: serializer.fromJson<String?>(json['defaultBankAcc']),
      defaultBankAccType: serializer.fromJson<String?>(
        json['defaultBankAccType'],
      ),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      adminRoleUid: serializer.fromJson<String?>(json['adminRoleUid']),
      adminRoleName: serializer.fromJson<String?>(json['adminRoleName']),
      bumiputera: serializer.fromJson<bool>(json['bumiputera']),
      einvoiceTinNo: serializer.fromJson<String?>(json['einvoiceTinNo']),
      registrationDate: serializer.fromJson<DateTime?>(
        json['registrationDate'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'regNo': serializer.toJson<String?>(regNo),
      'cidbNo': serializer.toJson<String?>(cidbNo),
      'address': serializer.toJson<String?>(address),
      'postalCode': serializer.toJson<String?>(postalCode),
      'city': serializer.toJson<String?>(city),
      'state': serializer.toJson<String?>(state),
      'country': serializer.toJson<String?>(country),
      'phone': serializer.toJson<String?>(phone),
      'email': serializer.toJson<String?>(email),
      'website': serializer.toJson<String?>(website),
      'companyType': serializer.toJson<String>(companyType),
      'ownerID': serializer.toJson<int>(ownerID),
      'defaultBankAcc': serializer.toJson<String?>(defaultBankAcc),
      'defaultBankAccType': serializer.toJson<String?>(defaultBankAccType),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'adminRoleUid': serializer.toJson<String?>(adminRoleUid),
      'adminRoleName': serializer.toJson<String?>(adminRoleName),
      'bumiputera': serializer.toJson<bool>(bumiputera),
      'einvoiceTinNo': serializer.toJson<String?>(einvoiceTinNo),
      'registrationDate': serializer.toJson<DateTime?>(registrationDate),
    };
  }

  CompanyRecord copyWith({
    int? id,
    String? uid,
    String? name,
    Value<String?> regNo = const Value.absent(),
    Value<String?> cidbNo = const Value.absent(),
    Value<String?> address = const Value.absent(),
    Value<String?> postalCode = const Value.absent(),
    Value<String?> city = const Value.absent(),
    Value<String?> state = const Value.absent(),
    Value<String?> country = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> email = const Value.absent(),
    Value<String?> website = const Value.absent(),
    String? companyType,
    int? ownerID,
    Value<String?> defaultBankAcc = const Value.absent(),
    Value<String?> defaultBankAccType = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> adminRoleUid = const Value.absent(),
    Value<String?> adminRoleName = const Value.absent(),
    bool? bumiputera,
    Value<String?> einvoiceTinNo = const Value.absent(),
    Value<DateTime?> registrationDate = const Value.absent(),
  }) => CompanyRecord(
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    regNo: regNo.present ? regNo.value : this.regNo,
    cidbNo: cidbNo.present ? cidbNo.value : this.cidbNo,
    address: address.present ? address.value : this.address,
    postalCode: postalCode.present ? postalCode.value : this.postalCode,
    city: city.present ? city.value : this.city,
    state: state.present ? state.value : this.state,
    country: country.present ? country.value : this.country,
    phone: phone.present ? phone.value : this.phone,
    email: email.present ? email.value : this.email,
    website: website.present ? website.value : this.website,
    companyType: companyType ?? this.companyType,
    ownerID: ownerID ?? this.ownerID,
    defaultBankAcc: defaultBankAcc.present
        ? defaultBankAcc.value
        : this.defaultBankAcc,
    defaultBankAccType: defaultBankAccType.present
        ? defaultBankAccType.value
        : this.defaultBankAccType,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    adminRoleUid: adminRoleUid.present ? adminRoleUid.value : this.adminRoleUid,
    adminRoleName: adminRoleName.present
        ? adminRoleName.value
        : this.adminRoleName,
    bumiputera: bumiputera ?? this.bumiputera,
    einvoiceTinNo: einvoiceTinNo.present
        ? einvoiceTinNo.value
        : this.einvoiceTinNo,
    registrationDate: registrationDate.present
        ? registrationDate.value
        : this.registrationDate,
  );
  CompanyRecord copyWithCompanion(CompaniesCompanion data) {
    return CompanyRecord(
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      regNo: data.regNo.present ? data.regNo.value : this.regNo,
      cidbNo: data.cidbNo.present ? data.cidbNo.value : this.cidbNo,
      address: data.address.present ? data.address.value : this.address,
      postalCode: data.postalCode.present
          ? data.postalCode.value
          : this.postalCode,
      city: data.city.present ? data.city.value : this.city,
      state: data.state.present ? data.state.value : this.state,
      country: data.country.present ? data.country.value : this.country,
      phone: data.phone.present ? data.phone.value : this.phone,
      email: data.email.present ? data.email.value : this.email,
      website: data.website.present ? data.website.value : this.website,
      companyType: data.companyType.present
          ? data.companyType.value
          : this.companyType,
      ownerID: data.ownerID.present ? data.ownerID.value : this.ownerID,
      defaultBankAcc: data.defaultBankAcc.present
          ? data.defaultBankAcc.value
          : this.defaultBankAcc,
      defaultBankAccType: data.defaultBankAccType.present
          ? data.defaultBankAccType.value
          : this.defaultBankAccType,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      adminRoleUid: data.adminRoleUid.present
          ? data.adminRoleUid.value
          : this.adminRoleUid,
      adminRoleName: data.adminRoleName.present
          ? data.adminRoleName.value
          : this.adminRoleName,
      bumiputera: data.bumiputera.present
          ? data.bumiputera.value
          : this.bumiputera,
      einvoiceTinNo: data.einvoiceTinNo.present
          ? data.einvoiceTinNo.value
          : this.einvoiceTinNo,
      registrationDate: data.registrationDate.present
          ? data.registrationDate.value
          : this.registrationDate,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CompanyRecord(')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('regNo: $regNo, ')
          ..write('cidbNo: $cidbNo, ')
          ..write('address: $address, ')
          ..write('postalCode: $postalCode, ')
          ..write('city: $city, ')
          ..write('state: $state, ')
          ..write('country: $country, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('website: $website, ')
          ..write('companyType: $companyType, ')
          ..write('ownerID: $ownerID, ')
          ..write('defaultBankAcc: $defaultBankAcc, ')
          ..write('defaultBankAccType: $defaultBankAccType, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('adminRoleUid: $adminRoleUid, ')
          ..write('adminRoleName: $adminRoleName, ')
          ..write('bumiputera: $bumiputera, ')
          ..write('einvoiceTinNo: $einvoiceTinNo, ')
          ..write('registrationDate: $registrationDate')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    uid,
    name,
    regNo,
    cidbNo,
    address,
    postalCode,
    city,
    state,
    country,
    phone,
    email,
    website,
    companyType,
    ownerID,
    defaultBankAcc,
    defaultBankAccType,
    createdAt,
    updatedAt,
    deletedAt,
    adminRoleUid,
    adminRoleName,
    bumiputera,
    einvoiceTinNo,
    registrationDate,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CompanyRecord &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.regNo == this.regNo &&
          other.cidbNo == this.cidbNo &&
          other.address == this.address &&
          other.postalCode == this.postalCode &&
          other.city == this.city &&
          other.state == this.state &&
          other.country == this.country &&
          other.phone == this.phone &&
          other.email == this.email &&
          other.website == this.website &&
          other.companyType == this.companyType &&
          other.ownerID == this.ownerID &&
          other.defaultBankAcc == this.defaultBankAcc &&
          other.defaultBankAccType == this.defaultBankAccType &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.deletedAt == this.deletedAt &&
          other.adminRoleUid == this.adminRoleUid &&
          other.adminRoleName == this.adminRoleName &&
          other.bumiputera == this.bumiputera &&
          other.einvoiceTinNo == this.einvoiceTinNo &&
          other.registrationDate == this.registrationDate);
}

class CompaniesCompanion extends UpdateCompanion<CompanyRecord> {
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String?> regNo;
  final Value<String?> cidbNo;
  final Value<String?> address;
  final Value<String?> postalCode;
  final Value<String?> city;
  final Value<String?> state;
  final Value<String?> country;
  final Value<String?> phone;
  final Value<String?> email;
  final Value<String?> website;
  final Value<String> companyType;
  final Value<int> ownerID;
  final Value<String?> defaultBankAcc;
  final Value<String?> defaultBankAccType;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<DateTime?> deletedAt;
  final Value<String?> adminRoleUid;
  final Value<String?> adminRoleName;
  final Value<bool> bumiputera;
  final Value<String?> einvoiceTinNo;
  final Value<DateTime?> registrationDate;
  const CompaniesCompanion({
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.regNo = const Value.absent(),
    this.cidbNo = const Value.absent(),
    this.address = const Value.absent(),
    this.postalCode = const Value.absent(),
    this.city = const Value.absent(),
    this.state = const Value.absent(),
    this.country = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.website = const Value.absent(),
    this.companyType = const Value.absent(),
    this.ownerID = const Value.absent(),
    this.defaultBankAcc = const Value.absent(),
    this.defaultBankAccType = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.adminRoleUid = const Value.absent(),
    this.adminRoleName = const Value.absent(),
    this.bumiputera = const Value.absent(),
    this.einvoiceTinNo = const Value.absent(),
    this.registrationDate = const Value.absent(),
  });
  CompaniesCompanion.insert({
    this.id = const Value.absent(),
    required String uid,
    required String name,
    this.regNo = const Value.absent(),
    this.cidbNo = const Value.absent(),
    this.address = const Value.absent(),
    this.postalCode = const Value.absent(),
    this.city = const Value.absent(),
    this.state = const Value.absent(),
    this.country = const Value.absent(),
    this.phone = const Value.absent(),
    this.email = const Value.absent(),
    this.website = const Value.absent(),
    required String companyType,
    required int ownerID,
    this.defaultBankAcc = const Value.absent(),
    this.defaultBankAccType = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    this.deletedAt = const Value.absent(),
    this.adminRoleUid = const Value.absent(),
    this.adminRoleName = const Value.absent(),
    this.bumiputera = const Value.absent(),
    this.einvoiceTinNo = const Value.absent(),
    this.registrationDate = const Value.absent(),
  }) : uid = Value(uid),
       name = Value(name),
       companyType = Value(companyType),
       ownerID = Value(ownerID),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<CompanyRecord> custom({
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? regNo,
    Expression<String>? cidbNo,
    Expression<String>? address,
    Expression<String>? postalCode,
    Expression<String>? city,
    Expression<String>? state,
    Expression<String>? country,
    Expression<String>? phone,
    Expression<String>? email,
    Expression<String>? website,
    Expression<String>? companyType,
    Expression<int>? ownerID,
    Expression<String>? defaultBankAcc,
    Expression<String>? defaultBankAccType,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<DateTime>? deletedAt,
    Expression<String>? adminRoleUid,
    Expression<String>? adminRoleName,
    Expression<bool>? bumiputera,
    Expression<String>? einvoiceTinNo,
    Expression<DateTime>? registrationDate,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (regNo != null) 'reg_no': regNo,
      if (cidbNo != null) 'cidb_no': cidbNo,
      if (address != null) 'address': address,
      if (postalCode != null) 'postal_code': postalCode,
      if (city != null) 'city': city,
      if (state != null) 'state': state,
      if (country != null) 'country': country,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (website != null) 'website': website,
      if (companyType != null) 'company_type': companyType,
      if (ownerID != null) 'owner_i_d': ownerID,
      if (defaultBankAcc != null) 'default_bank_acc': defaultBankAcc,
      if (defaultBankAccType != null)
        'default_bank_acc_type': defaultBankAccType,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (adminRoleUid != null) 'admin_role_uid': adminRoleUid,
      if (adminRoleName != null) 'admin_role_name': adminRoleName,
      if (bumiputera != null) 'bumiputera': bumiputera,
      if (einvoiceTinNo != null) 'einvoice_tin_no': einvoiceTinNo,
      if (registrationDate != null) 'registration_date': registrationDate,
    });
  }

  CompaniesCompanion copyWith({
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String?>? regNo,
    Value<String?>? cidbNo,
    Value<String?>? address,
    Value<String?>? postalCode,
    Value<String?>? city,
    Value<String?>? state,
    Value<String?>? country,
    Value<String?>? phone,
    Value<String?>? email,
    Value<String?>? website,
    Value<String>? companyType,
    Value<int>? ownerID,
    Value<String?>? defaultBankAcc,
    Value<String?>? defaultBankAccType,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<DateTime?>? deletedAt,
    Value<String?>? adminRoleUid,
    Value<String?>? adminRoleName,
    Value<bool>? bumiputera,
    Value<String?>? einvoiceTinNo,
    Value<DateTime?>? registrationDate,
  }) {
    return CompaniesCompanion(
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      regNo: regNo ?? this.regNo,
      cidbNo: cidbNo ?? this.cidbNo,
      address: address ?? this.address,
      postalCode: postalCode ?? this.postalCode,
      city: city ?? this.city,
      state: state ?? this.state,
      country: country ?? this.country,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      website: website ?? this.website,
      companyType: companyType ?? this.companyType,
      ownerID: ownerID ?? this.ownerID,
      defaultBankAcc: defaultBankAcc ?? this.defaultBankAcc,
      defaultBankAccType: defaultBankAccType ?? this.defaultBankAccType,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      deletedAt: deletedAt ?? this.deletedAt,
      adminRoleUid: adminRoleUid ?? this.adminRoleUid,
      adminRoleName: adminRoleName ?? this.adminRoleName,
      bumiputera: bumiputera ?? this.bumiputera,
      einvoiceTinNo: einvoiceTinNo ?? this.einvoiceTinNo,
      registrationDate: registrationDate ?? this.registrationDate,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (regNo.present) {
      map['reg_no'] = Variable<String>(regNo.value);
    }
    if (cidbNo.present) {
      map['cidb_no'] = Variable<String>(cidbNo.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (postalCode.present) {
      map['postal_code'] = Variable<String>(postalCode.value);
    }
    if (city.present) {
      map['city'] = Variable<String>(city.value);
    }
    if (state.present) {
      map['state'] = Variable<String>(state.value);
    }
    if (country.present) {
      map['country'] = Variable<String>(country.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (website.present) {
      map['website'] = Variable<String>(website.value);
    }
    if (companyType.present) {
      map['company_type'] = Variable<String>(companyType.value);
    }
    if (ownerID.present) {
      map['owner_i_d'] = Variable<int>(ownerID.value);
    }
    if (defaultBankAcc.present) {
      map['default_bank_acc'] = Variable<String>(defaultBankAcc.value);
    }
    if (defaultBankAccType.present) {
      map['default_bank_acc_type'] = Variable<String>(defaultBankAccType.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (adminRoleUid.present) {
      map['admin_role_uid'] = Variable<String>(adminRoleUid.value);
    }
    if (adminRoleName.present) {
      map['admin_role_name'] = Variable<String>(adminRoleName.value);
    }
    if (bumiputera.present) {
      map['bumiputera'] = Variable<bool>(bumiputera.value);
    }
    if (einvoiceTinNo.present) {
      map['einvoice_tin_no'] = Variable<String>(einvoiceTinNo.value);
    }
    if (registrationDate.present) {
      map['registration_date'] = Variable<DateTime>(registrationDate.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CompaniesCompanion(')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('regNo: $regNo, ')
          ..write('cidbNo: $cidbNo, ')
          ..write('address: $address, ')
          ..write('postalCode: $postalCode, ')
          ..write('city: $city, ')
          ..write('state: $state, ')
          ..write('country: $country, ')
          ..write('phone: $phone, ')
          ..write('email: $email, ')
          ..write('website: $website, ')
          ..write('companyType: $companyType, ')
          ..write('ownerID: $ownerID, ')
          ..write('defaultBankAcc: $defaultBankAcc, ')
          ..write('defaultBankAccType: $defaultBankAccType, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('adminRoleUid: $adminRoleUid, ')
          ..write('adminRoleName: $adminRoleName, ')
          ..write('bumiputera: $bumiputera, ')
          ..write('einvoiceTinNo: $einvoiceTinNo, ')
          ..write('registrationDate: $registrationDate')
          ..write(')'))
        .toString();
  }
}

class $WorkScopesTable extends WorkScopes
    with TableInfo<$WorkScopesTable, WorkScopeRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WorkScopesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _allowMultipleQuantitiesMeta =
      const VerificationMeta('allowMultipleQuantities');
  @override
  late final GeneratedColumn<bool> allowMultipleQuantities =
      GeneratedColumn<bool>(
        'allow_multiple_quantities',
        aliasedName,
        false,
        type: DriftSqlType.bool,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("allow_multiple_quantities" IN (0, 1))',
        ),
        defaultValue: const Constant(false),
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _companyIDMeta = const VerificationMeta(
    'companyID',
  );
  @override
  late final GeneratedColumn<int> companyID = GeneratedColumn<int>(
    'company_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    code,
    description,
    allowMultipleQuantities,
    createdAt,
    updatedAt,
    companyID,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'work_scopes';
  @override
  VerificationContext validateIntegrity(
    Insertable<WorkScopeRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    if (data.containsKey('allow_multiple_quantities')) {
      context.handle(
        _allowMultipleQuantitiesMeta,
        allowMultipleQuantities.isAcceptableOrUnknown(
          data['allow_multiple_quantities']!,
          _allowMultipleQuantitiesMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('company_i_d')) {
      context.handle(
        _companyIDMeta,
        companyID.isAcceptableOrUnknown(data['company_i_d']!, _companyIDMeta),
      );
    } else if (isInserting) {
      context.missing(_companyIDMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  WorkScopeRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WorkScopeRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      )!,
      allowMultipleQuantities: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}allow_multiple_quantities'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      companyID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}company_i_d'],
      )!,
    );
  }

  @override
  $WorkScopesTable createAlias(String alias) {
    return $WorkScopesTable(attachedDatabase, alias);
  }
}

class WorkScopeRecord extends DataClass implements Insertable<WorkScopeRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final String code;
  final String description;
  final bool allowMultipleQuantities;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int companyID;
  const WorkScopeRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    required this.code,
    required this.description,
    required this.allowMultipleQuantities,
    required this.createdAt,
    required this.updatedAt,
    required this.companyID,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    map['code'] = Variable<String>(code);
    map['description'] = Variable<String>(description);
    map['allow_multiple_quantities'] = Variable<bool>(allowMultipleQuantities);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['company_i_d'] = Variable<int>(companyID);
    return map;
  }

  WorkScopesCompanion toCompanion(bool nullToAbsent) {
    return WorkScopesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      code: Value(code),
      description: Value(description),
      allowMultipleQuantities: Value(allowMultipleQuantities),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      companyID: Value(companyID),
    );
  }

  factory WorkScopeRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WorkScopeRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String>(json['code']),
      description: serializer.fromJson<String>(json['description']),
      allowMultipleQuantities: serializer.fromJson<bool>(
        json['allowMultipleQuantities'],
      ),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      companyID: serializer.fromJson<int>(json['companyID']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String>(code),
      'description': serializer.toJson<String>(description),
      'allowMultipleQuantities': serializer.toJson<bool>(
        allowMultipleQuantities,
      ),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'companyID': serializer.toJson<int>(companyID),
    };
  }

  WorkScopeRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    String? code,
    String? description,
    bool? allowMultipleQuantities,
    DateTime? createdAt,
    DateTime? updatedAt,
    int? companyID,
  }) => WorkScopeRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    code: code ?? this.code,
    description: description ?? this.description,
    allowMultipleQuantities:
        allowMultipleQuantities ?? this.allowMultipleQuantities,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    companyID: companyID ?? this.companyID,
  );
  WorkScopeRecord copyWithCompanion(WorkScopesCompanion data) {
    return WorkScopeRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      description: data.description.present
          ? data.description.value
          : this.description,
      allowMultipleQuantities: data.allowMultipleQuantities.present
          ? data.allowMultipleQuantities.value
          : this.allowMultipleQuantities,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      companyID: data.companyID.present ? data.companyID.value : this.companyID,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WorkScopeRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('description: $description, ')
          ..write('allowMultipleQuantities: $allowMultipleQuantities, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('companyID: $companyID')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    code,
    description,
    allowMultipleQuantities,
    createdAt,
    updatedAt,
    companyID,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WorkScopeRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.code == this.code &&
          other.description == this.description &&
          other.allowMultipleQuantities == this.allowMultipleQuantities &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.companyID == this.companyID);
}

class WorkScopesCompanion extends UpdateCompanion<WorkScopeRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String> code;
  final Value<String> description;
  final Value<bool> allowMultipleQuantities;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> companyID;
  const WorkScopesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.description = const Value.absent(),
    this.allowMultipleQuantities = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.companyID = const Value.absent(),
  });
  WorkScopesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    required String code,
    required String description,
    this.allowMultipleQuantities = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
    required int companyID,
  }) : uid = Value(uid),
       name = Value(name),
       code = Value(code),
       description = Value(description),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt),
       companyID = Value(companyID);
  static Insertable<WorkScopeRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? description,
    Expression<bool>? allowMultipleQuantities,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? companyID,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (description != null) 'description': description,
      if (allowMultipleQuantities != null)
        'allow_multiple_quantities': allowMultipleQuantities,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (companyID != null) 'company_i_d': companyID,
    });
  }

  WorkScopesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String>? code,
    Value<String>? description,
    Value<bool>? allowMultipleQuantities,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? companyID,
  }) {
    return WorkScopesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      code: code ?? this.code,
      description: description ?? this.description,
      allowMultipleQuantities:
          allowMultipleQuantities ?? this.allowMultipleQuantities,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      companyID: companyID ?? this.companyID,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (allowMultipleQuantities.present) {
      map['allow_multiple_quantities'] = Variable<bool>(
        allowMultipleQuantities.value,
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (companyID.present) {
      map['company_i_d'] = Variable<int>(companyID.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WorkScopesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('description: $description, ')
          ..write('allowMultipleQuantities: $allowMultipleQuantities, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('companyID: $companyID')
          ..write(')'))
        .toString();
  }
}

class $WorkQuantityTypesTable extends WorkQuantityTypes
    with TableInfo<$WorkQuantityTypesTable, WorkQuantityTypeRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WorkQuantityTypesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _displayOrderMeta = const VerificationMeta(
    'displayOrder',
  );
  @override
  late final GeneratedColumn<int> displayOrder = GeneratedColumn<int>(
    'display_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _hasSegmentBreakdownMeta =
      const VerificationMeta('hasSegmentBreakdown');
  @override
  late final GeneratedColumn<bool> hasSegmentBreakdown = GeneratedColumn<bool>(
    'has_segment_breakdown',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("has_segment_breakdown" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _segmentSizeMeta = const VerificationMeta(
    'segmentSize',
  );
  @override
  late final GeneratedColumn<int> segmentSize = GeneratedColumn<int>(
    'segment_size',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _maxSegmentLengthMeta = const VerificationMeta(
    'maxSegmentLength',
  );
  @override
  late final GeneratedColumn<int> maxSegmentLength = GeneratedColumn<int>(
    'max_segment_length',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _workScopeIDMeta = const VerificationMeta(
    'workScopeID',
  );
  @override
  late final GeneratedColumn<int> workScopeID = GeneratedColumn<int>(
    'work_scope_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    code,
    displayOrder,
    hasSegmentBreakdown,
    segmentSize,
    maxSegmentLength,
    workScopeID,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'work_quantity_types';
  @override
  VerificationContext validateIntegrity(
    Insertable<WorkQuantityTypeRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('display_order')) {
      context.handle(
        _displayOrderMeta,
        displayOrder.isAcceptableOrUnknown(
          data['display_order']!,
          _displayOrderMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_displayOrderMeta);
    }
    if (data.containsKey('has_segment_breakdown')) {
      context.handle(
        _hasSegmentBreakdownMeta,
        hasSegmentBreakdown.isAcceptableOrUnknown(
          data['has_segment_breakdown']!,
          _hasSegmentBreakdownMeta,
        ),
      );
    }
    if (data.containsKey('segment_size')) {
      context.handle(
        _segmentSizeMeta,
        segmentSize.isAcceptableOrUnknown(
          data['segment_size']!,
          _segmentSizeMeta,
        ),
      );
    }
    if (data.containsKey('max_segment_length')) {
      context.handle(
        _maxSegmentLengthMeta,
        maxSegmentLength.isAcceptableOrUnknown(
          data['max_segment_length']!,
          _maxSegmentLengthMeta,
        ),
      );
    }
    if (data.containsKey('work_scope_i_d')) {
      context.handle(
        _workScopeIDMeta,
        workScopeID.isAcceptableOrUnknown(
          data['work_scope_i_d']!,
          _workScopeIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_workScopeIDMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  WorkQuantityTypeRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WorkQuantityTypeRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      displayOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}display_order'],
      )!,
      hasSegmentBreakdown: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}has_segment_breakdown'],
      )!,
      segmentSize: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}segment_size'],
      ),
      maxSegmentLength: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_segment_length'],
      ),
      workScopeID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}work_scope_i_d'],
      )!,
    );
  }

  @override
  $WorkQuantityTypesTable createAlias(String alias) {
    return $WorkQuantityTypesTable(attachedDatabase, alias);
  }
}

class WorkQuantityTypeRecord extends DataClass
    implements Insertable<WorkQuantityTypeRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final String code;
  final int displayOrder;
  final bool hasSegmentBreakdown;
  final int? segmentSize;
  final int? maxSegmentLength;
  final int workScopeID;
  const WorkQuantityTypeRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    required this.code,
    required this.displayOrder,
    required this.hasSegmentBreakdown,
    this.segmentSize,
    this.maxSegmentLength,
    required this.workScopeID,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    map['code'] = Variable<String>(code);
    map['display_order'] = Variable<int>(displayOrder);
    map['has_segment_breakdown'] = Variable<bool>(hasSegmentBreakdown);
    if (!nullToAbsent || segmentSize != null) {
      map['segment_size'] = Variable<int>(segmentSize);
    }
    if (!nullToAbsent || maxSegmentLength != null) {
      map['max_segment_length'] = Variable<int>(maxSegmentLength);
    }
    map['work_scope_i_d'] = Variable<int>(workScopeID);
    return map;
  }

  WorkQuantityTypesCompanion toCompanion(bool nullToAbsent) {
    return WorkQuantityTypesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      code: Value(code),
      displayOrder: Value(displayOrder),
      hasSegmentBreakdown: Value(hasSegmentBreakdown),
      segmentSize: segmentSize == null && nullToAbsent
          ? const Value.absent()
          : Value(segmentSize),
      maxSegmentLength: maxSegmentLength == null && nullToAbsent
          ? const Value.absent()
          : Value(maxSegmentLength),
      workScopeID: Value(workScopeID),
    );
  }

  factory WorkQuantityTypeRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WorkQuantityTypeRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String>(json['code']),
      displayOrder: serializer.fromJson<int>(json['displayOrder']),
      hasSegmentBreakdown: serializer.fromJson<bool>(
        json['hasSegmentBreakdown'],
      ),
      segmentSize: serializer.fromJson<int?>(json['segmentSize']),
      maxSegmentLength: serializer.fromJson<int?>(json['maxSegmentLength']),
      workScopeID: serializer.fromJson<int>(json['workScopeID']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String>(code),
      'displayOrder': serializer.toJson<int>(displayOrder),
      'hasSegmentBreakdown': serializer.toJson<bool>(hasSegmentBreakdown),
      'segmentSize': serializer.toJson<int?>(segmentSize),
      'maxSegmentLength': serializer.toJson<int?>(maxSegmentLength),
      'workScopeID': serializer.toJson<int>(workScopeID),
    };
  }

  WorkQuantityTypeRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    String? code,
    int? displayOrder,
    bool? hasSegmentBreakdown,
    Value<int?> segmentSize = const Value.absent(),
    Value<int?> maxSegmentLength = const Value.absent(),
    int? workScopeID,
  }) => WorkQuantityTypeRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    code: code ?? this.code,
    displayOrder: displayOrder ?? this.displayOrder,
    hasSegmentBreakdown: hasSegmentBreakdown ?? this.hasSegmentBreakdown,
    segmentSize: segmentSize.present ? segmentSize.value : this.segmentSize,
    maxSegmentLength: maxSegmentLength.present
        ? maxSegmentLength.value
        : this.maxSegmentLength,
    workScopeID: workScopeID ?? this.workScopeID,
  );
  WorkQuantityTypeRecord copyWithCompanion(WorkQuantityTypesCompanion data) {
    return WorkQuantityTypeRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      displayOrder: data.displayOrder.present
          ? data.displayOrder.value
          : this.displayOrder,
      hasSegmentBreakdown: data.hasSegmentBreakdown.present
          ? data.hasSegmentBreakdown.value
          : this.hasSegmentBreakdown,
      segmentSize: data.segmentSize.present
          ? data.segmentSize.value
          : this.segmentSize,
      maxSegmentLength: data.maxSegmentLength.present
          ? data.maxSegmentLength.value
          : this.maxSegmentLength,
      workScopeID: data.workScopeID.present
          ? data.workScopeID.value
          : this.workScopeID,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WorkQuantityTypeRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('hasSegmentBreakdown: $hasSegmentBreakdown, ')
          ..write('segmentSize: $segmentSize, ')
          ..write('maxSegmentLength: $maxSegmentLength, ')
          ..write('workScopeID: $workScopeID')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    code,
    displayOrder,
    hasSegmentBreakdown,
    segmentSize,
    maxSegmentLength,
    workScopeID,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WorkQuantityTypeRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.code == this.code &&
          other.displayOrder == this.displayOrder &&
          other.hasSegmentBreakdown == this.hasSegmentBreakdown &&
          other.segmentSize == this.segmentSize &&
          other.maxSegmentLength == this.maxSegmentLength &&
          other.workScopeID == this.workScopeID);
}

class WorkQuantityTypesCompanion
    extends UpdateCompanion<WorkQuantityTypeRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String> code;
  final Value<int> displayOrder;
  final Value<bool> hasSegmentBreakdown;
  final Value<int?> segmentSize;
  final Value<int?> maxSegmentLength;
  final Value<int> workScopeID;
  const WorkQuantityTypesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.hasSegmentBreakdown = const Value.absent(),
    this.segmentSize = const Value.absent(),
    this.maxSegmentLength = const Value.absent(),
    this.workScopeID = const Value.absent(),
  });
  WorkQuantityTypesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    required String code,
    required int displayOrder,
    this.hasSegmentBreakdown = const Value.absent(),
    this.segmentSize = const Value.absent(),
    this.maxSegmentLength = const Value.absent(),
    required int workScopeID,
  }) : uid = Value(uid),
       name = Value(name),
       code = Value(code),
       displayOrder = Value(displayOrder),
       workScopeID = Value(workScopeID);
  static Insertable<WorkQuantityTypeRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? code,
    Expression<int>? displayOrder,
    Expression<bool>? hasSegmentBreakdown,
    Expression<int>? segmentSize,
    Expression<int>? maxSegmentLength,
    Expression<int>? workScopeID,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (displayOrder != null) 'display_order': displayOrder,
      if (hasSegmentBreakdown != null)
        'has_segment_breakdown': hasSegmentBreakdown,
      if (segmentSize != null) 'segment_size': segmentSize,
      if (maxSegmentLength != null) 'max_segment_length': maxSegmentLength,
      if (workScopeID != null) 'work_scope_i_d': workScopeID,
    });
  }

  WorkQuantityTypesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String>? code,
    Value<int>? displayOrder,
    Value<bool>? hasSegmentBreakdown,
    Value<int?>? segmentSize,
    Value<int?>? maxSegmentLength,
    Value<int>? workScopeID,
  }) {
    return WorkQuantityTypesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      code: code ?? this.code,
      displayOrder: displayOrder ?? this.displayOrder,
      hasSegmentBreakdown: hasSegmentBreakdown ?? this.hasSegmentBreakdown,
      segmentSize: segmentSize ?? this.segmentSize,
      maxSegmentLength: maxSegmentLength ?? this.maxSegmentLength,
      workScopeID: workScopeID ?? this.workScopeID,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (displayOrder.present) {
      map['display_order'] = Variable<int>(displayOrder.value);
    }
    if (hasSegmentBreakdown.present) {
      map['has_segment_breakdown'] = Variable<bool>(hasSegmentBreakdown.value);
    }
    if (segmentSize.present) {
      map['segment_size'] = Variable<int>(segmentSize.value);
    }
    if (maxSegmentLength.present) {
      map['max_segment_length'] = Variable<int>(maxSegmentLength.value);
    }
    if (workScopeID.present) {
      map['work_scope_i_d'] = Variable<int>(workScopeID.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WorkQuantityTypesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('hasSegmentBreakdown: $hasSegmentBreakdown, ')
          ..write('segmentSize: $segmentSize, ')
          ..write('maxSegmentLength: $maxSegmentLength, ')
          ..write('workScopeID: $workScopeID')
          ..write(')'))
        .toString();
  }
}

class $WorkQuantityFieldsTable extends WorkQuantityFields
    with TableInfo<$WorkQuantityFieldsTable, WorkQuantityFieldRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WorkQuantityFieldsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fieldTypeMeta = const VerificationMeta(
    'fieldType',
  );
  @override
  late final GeneratedColumn<String> fieldType = GeneratedColumn<String>(
    'field_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _unitMeta = const VerificationMeta('unit');
  @override
  late final GeneratedColumn<String> unit = GeneratedColumn<String>(
    'unit',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _validationRulesMeta = const VerificationMeta(
    'validationRules',
  );
  @override
  late final GeneratedColumn<String> validationRules = GeneratedColumn<String>(
    'validation_rules',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _displayOrderMeta = const VerificationMeta(
    'displayOrder',
  );
  @override
  late final GeneratedColumn<int> displayOrder = GeneratedColumn<int>(
    'display_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isRequiredMeta = const VerificationMeta(
    'isRequired',
  );
  @override
  late final GeneratedColumn<bool> isRequired = GeneratedColumn<bool>(
    'is_required',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_required" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isForSegmentMeta = const VerificationMeta(
    'isForSegment',
  );
  @override
  late final GeneratedColumn<bool> isForSegment = GeneratedColumn<bool>(
    'is_for_segment',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_for_segment" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _defaultValueMeta = const VerificationMeta(
    'defaultValue',
  );
  @override
  late final GeneratedColumn<String> defaultValue = GeneratedColumn<String>(
    'default_value',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _placeholderMeta = const VerificationMeta(
    'placeholder',
  );
  @override
  late final GeneratedColumn<String> placeholder = GeneratedColumn<String>(
    'placeholder',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _helpTextMeta = const VerificationMeta(
    'helpText',
  );
  @override
  late final GeneratedColumn<String> helpText = GeneratedColumn<String>(
    'help_text',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _quantityTypeIDMeta = const VerificationMeta(
    'quantityTypeID',
  );
  @override
  late final GeneratedColumn<int> quantityTypeID = GeneratedColumn<int>(
    'quantity_type_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    code,
    fieldType,
    unit,
    validationRules,
    displayOrder,
    isRequired,
    isForSegment,
    defaultValue,
    placeholder,
    helpText,
    quantityTypeID,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'work_quantity_fields';
  @override
  VerificationContext validateIntegrity(
    Insertable<WorkQuantityFieldRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('field_type')) {
      context.handle(
        _fieldTypeMeta,
        fieldType.isAcceptableOrUnknown(data['field_type']!, _fieldTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_fieldTypeMeta);
    }
    if (data.containsKey('unit')) {
      context.handle(
        _unitMeta,
        unit.isAcceptableOrUnknown(data['unit']!, _unitMeta),
      );
    }
    if (data.containsKey('validation_rules')) {
      context.handle(
        _validationRulesMeta,
        validationRules.isAcceptableOrUnknown(
          data['validation_rules']!,
          _validationRulesMeta,
        ),
      );
    }
    if (data.containsKey('display_order')) {
      context.handle(
        _displayOrderMeta,
        displayOrder.isAcceptableOrUnknown(
          data['display_order']!,
          _displayOrderMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_displayOrderMeta);
    }
    if (data.containsKey('is_required')) {
      context.handle(
        _isRequiredMeta,
        isRequired.isAcceptableOrUnknown(data['is_required']!, _isRequiredMeta),
      );
    }
    if (data.containsKey('is_for_segment')) {
      context.handle(
        _isForSegmentMeta,
        isForSegment.isAcceptableOrUnknown(
          data['is_for_segment']!,
          _isForSegmentMeta,
        ),
      );
    }
    if (data.containsKey('default_value')) {
      context.handle(
        _defaultValueMeta,
        defaultValue.isAcceptableOrUnknown(
          data['default_value']!,
          _defaultValueMeta,
        ),
      );
    }
    if (data.containsKey('placeholder')) {
      context.handle(
        _placeholderMeta,
        placeholder.isAcceptableOrUnknown(
          data['placeholder']!,
          _placeholderMeta,
        ),
      );
    }
    if (data.containsKey('help_text')) {
      context.handle(
        _helpTextMeta,
        helpText.isAcceptableOrUnknown(data['help_text']!, _helpTextMeta),
      );
    }
    if (data.containsKey('quantity_type_i_d')) {
      context.handle(
        _quantityTypeIDMeta,
        quantityTypeID.isAcceptableOrUnknown(
          data['quantity_type_i_d']!,
          _quantityTypeIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_quantityTypeIDMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  WorkQuantityFieldRecord map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WorkQuantityFieldRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
      fieldType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}field_type'],
      )!,
      unit: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}unit'],
      ),
      validationRules: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}validation_rules'],
      ),
      displayOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}display_order'],
      )!,
      isRequired: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_required'],
      )!,
      isForSegment: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_for_segment'],
      )!,
      defaultValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}default_value'],
      ),
      placeholder: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}placeholder'],
      ),
      helpText: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}help_text'],
      ),
      quantityTypeID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity_type_i_d'],
      )!,
    );
  }

  @override
  $WorkQuantityFieldsTable createAlias(String alias) {
    return $WorkQuantityFieldsTable(attachedDatabase, alias);
  }
}

class WorkQuantityFieldRecord extends DataClass
    implements Insertable<WorkQuantityFieldRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final String code;
  final String fieldType;
  final String? unit;
  final String? validationRules;
  final int displayOrder;
  final bool isRequired;
  final bool isForSegment;
  final String? defaultValue;
  final String? placeholder;
  final String? helpText;
  final int quantityTypeID;
  const WorkQuantityFieldRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    required this.code,
    required this.fieldType,
    this.unit,
    this.validationRules,
    required this.displayOrder,
    required this.isRequired,
    required this.isForSegment,
    this.defaultValue,
    this.placeholder,
    this.helpText,
    required this.quantityTypeID,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    map['code'] = Variable<String>(code);
    map['field_type'] = Variable<String>(fieldType);
    if (!nullToAbsent || unit != null) {
      map['unit'] = Variable<String>(unit);
    }
    if (!nullToAbsent || validationRules != null) {
      map['validation_rules'] = Variable<String>(validationRules);
    }
    map['display_order'] = Variable<int>(displayOrder);
    map['is_required'] = Variable<bool>(isRequired);
    map['is_for_segment'] = Variable<bool>(isForSegment);
    if (!nullToAbsent || defaultValue != null) {
      map['default_value'] = Variable<String>(defaultValue);
    }
    if (!nullToAbsent || placeholder != null) {
      map['placeholder'] = Variable<String>(placeholder);
    }
    if (!nullToAbsent || helpText != null) {
      map['help_text'] = Variable<String>(helpText);
    }
    map['quantity_type_i_d'] = Variable<int>(quantityTypeID);
    return map;
  }

  WorkQuantityFieldsCompanion toCompanion(bool nullToAbsent) {
    return WorkQuantityFieldsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      code: Value(code),
      fieldType: Value(fieldType),
      unit: unit == null && nullToAbsent ? const Value.absent() : Value(unit),
      validationRules: validationRules == null && nullToAbsent
          ? const Value.absent()
          : Value(validationRules),
      displayOrder: Value(displayOrder),
      isRequired: Value(isRequired),
      isForSegment: Value(isForSegment),
      defaultValue: defaultValue == null && nullToAbsent
          ? const Value.absent()
          : Value(defaultValue),
      placeholder: placeholder == null && nullToAbsent
          ? const Value.absent()
          : Value(placeholder),
      helpText: helpText == null && nullToAbsent
          ? const Value.absent()
          : Value(helpText),
      quantityTypeID: Value(quantityTypeID),
    );
  }

  factory WorkQuantityFieldRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WorkQuantityFieldRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String>(json['code']),
      fieldType: serializer.fromJson<String>(json['fieldType']),
      unit: serializer.fromJson<String?>(json['unit']),
      validationRules: serializer.fromJson<String?>(json['validationRules']),
      displayOrder: serializer.fromJson<int>(json['displayOrder']),
      isRequired: serializer.fromJson<bool>(json['isRequired']),
      isForSegment: serializer.fromJson<bool>(json['isForSegment']),
      defaultValue: serializer.fromJson<String?>(json['defaultValue']),
      placeholder: serializer.fromJson<String?>(json['placeholder']),
      helpText: serializer.fromJson<String?>(json['helpText']),
      quantityTypeID: serializer.fromJson<int>(json['quantityTypeID']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String>(code),
      'fieldType': serializer.toJson<String>(fieldType),
      'unit': serializer.toJson<String?>(unit),
      'validationRules': serializer.toJson<String?>(validationRules),
      'displayOrder': serializer.toJson<int>(displayOrder),
      'isRequired': serializer.toJson<bool>(isRequired),
      'isForSegment': serializer.toJson<bool>(isForSegment),
      'defaultValue': serializer.toJson<String?>(defaultValue),
      'placeholder': serializer.toJson<String?>(placeholder),
      'helpText': serializer.toJson<String?>(helpText),
      'quantityTypeID': serializer.toJson<int>(quantityTypeID),
    };
  }

  WorkQuantityFieldRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    String? code,
    String? fieldType,
    Value<String?> unit = const Value.absent(),
    Value<String?> validationRules = const Value.absent(),
    int? displayOrder,
    bool? isRequired,
    bool? isForSegment,
    Value<String?> defaultValue = const Value.absent(),
    Value<String?> placeholder = const Value.absent(),
    Value<String?> helpText = const Value.absent(),
    int? quantityTypeID,
  }) => WorkQuantityFieldRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    code: code ?? this.code,
    fieldType: fieldType ?? this.fieldType,
    unit: unit.present ? unit.value : this.unit,
    validationRules: validationRules.present
        ? validationRules.value
        : this.validationRules,
    displayOrder: displayOrder ?? this.displayOrder,
    isRequired: isRequired ?? this.isRequired,
    isForSegment: isForSegment ?? this.isForSegment,
    defaultValue: defaultValue.present ? defaultValue.value : this.defaultValue,
    placeholder: placeholder.present ? placeholder.value : this.placeholder,
    helpText: helpText.present ? helpText.value : this.helpText,
    quantityTypeID: quantityTypeID ?? this.quantityTypeID,
  );
  WorkQuantityFieldRecord copyWithCompanion(WorkQuantityFieldsCompanion data) {
    return WorkQuantityFieldRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
      fieldType: data.fieldType.present ? data.fieldType.value : this.fieldType,
      unit: data.unit.present ? data.unit.value : this.unit,
      validationRules: data.validationRules.present
          ? data.validationRules.value
          : this.validationRules,
      displayOrder: data.displayOrder.present
          ? data.displayOrder.value
          : this.displayOrder,
      isRequired: data.isRequired.present
          ? data.isRequired.value
          : this.isRequired,
      isForSegment: data.isForSegment.present
          ? data.isForSegment.value
          : this.isForSegment,
      defaultValue: data.defaultValue.present
          ? data.defaultValue.value
          : this.defaultValue,
      placeholder: data.placeholder.present
          ? data.placeholder.value
          : this.placeholder,
      helpText: data.helpText.present ? data.helpText.value : this.helpText,
      quantityTypeID: data.quantityTypeID.present
          ? data.quantityTypeID.value
          : this.quantityTypeID,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WorkQuantityFieldRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('fieldType: $fieldType, ')
          ..write('unit: $unit, ')
          ..write('validationRules: $validationRules, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('isRequired: $isRequired, ')
          ..write('isForSegment: $isForSegment, ')
          ..write('defaultValue: $defaultValue, ')
          ..write('placeholder: $placeholder, ')
          ..write('helpText: $helpText, ')
          ..write('quantityTypeID: $quantityTypeID')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    code,
    fieldType,
    unit,
    validationRules,
    displayOrder,
    isRequired,
    isForSegment,
    defaultValue,
    placeholder,
    helpText,
    quantityTypeID,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WorkQuantityFieldRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.code == this.code &&
          other.fieldType == this.fieldType &&
          other.unit == this.unit &&
          other.validationRules == this.validationRules &&
          other.displayOrder == this.displayOrder &&
          other.isRequired == this.isRequired &&
          other.isForSegment == this.isForSegment &&
          other.defaultValue == this.defaultValue &&
          other.placeholder == this.placeholder &&
          other.helpText == this.helpText &&
          other.quantityTypeID == this.quantityTypeID);
}

class WorkQuantityFieldsCompanion
    extends UpdateCompanion<WorkQuantityFieldRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String> code;
  final Value<String> fieldType;
  final Value<String?> unit;
  final Value<String?> validationRules;
  final Value<int> displayOrder;
  final Value<bool> isRequired;
  final Value<bool> isForSegment;
  final Value<String?> defaultValue;
  final Value<String?> placeholder;
  final Value<String?> helpText;
  final Value<int> quantityTypeID;
  const WorkQuantityFieldsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
    this.fieldType = const Value.absent(),
    this.unit = const Value.absent(),
    this.validationRules = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.isRequired = const Value.absent(),
    this.isForSegment = const Value.absent(),
    this.defaultValue = const Value.absent(),
    this.placeholder = const Value.absent(),
    this.helpText = const Value.absent(),
    this.quantityTypeID = const Value.absent(),
  });
  WorkQuantityFieldsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    required String code,
    required String fieldType,
    this.unit = const Value.absent(),
    this.validationRules = const Value.absent(),
    required int displayOrder,
    this.isRequired = const Value.absent(),
    this.isForSegment = const Value.absent(),
    this.defaultValue = const Value.absent(),
    this.placeholder = const Value.absent(),
    this.helpText = const Value.absent(),
    required int quantityTypeID,
  }) : uid = Value(uid),
       name = Value(name),
       code = Value(code),
       fieldType = Value(fieldType),
       displayOrder = Value(displayOrder),
       quantityTypeID = Value(quantityTypeID);
  static Insertable<WorkQuantityFieldRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? code,
    Expression<String>? fieldType,
    Expression<String>? unit,
    Expression<String>? validationRules,
    Expression<int>? displayOrder,
    Expression<bool>? isRequired,
    Expression<bool>? isForSegment,
    Expression<String>? defaultValue,
    Expression<String>? placeholder,
    Expression<String>? helpText,
    Expression<int>? quantityTypeID,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
      if (fieldType != null) 'field_type': fieldType,
      if (unit != null) 'unit': unit,
      if (validationRules != null) 'validation_rules': validationRules,
      if (displayOrder != null) 'display_order': displayOrder,
      if (isRequired != null) 'is_required': isRequired,
      if (isForSegment != null) 'is_for_segment': isForSegment,
      if (defaultValue != null) 'default_value': defaultValue,
      if (placeholder != null) 'placeholder': placeholder,
      if (helpText != null) 'help_text': helpText,
      if (quantityTypeID != null) 'quantity_type_i_d': quantityTypeID,
    });
  }

  WorkQuantityFieldsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String>? code,
    Value<String>? fieldType,
    Value<String?>? unit,
    Value<String?>? validationRules,
    Value<int>? displayOrder,
    Value<bool>? isRequired,
    Value<bool>? isForSegment,
    Value<String?>? defaultValue,
    Value<String?>? placeholder,
    Value<String?>? helpText,
    Value<int>? quantityTypeID,
  }) {
    return WorkQuantityFieldsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      code: code ?? this.code,
      fieldType: fieldType ?? this.fieldType,
      unit: unit ?? this.unit,
      validationRules: validationRules ?? this.validationRules,
      displayOrder: displayOrder ?? this.displayOrder,
      isRequired: isRequired ?? this.isRequired,
      isForSegment: isForSegment ?? this.isForSegment,
      defaultValue: defaultValue ?? this.defaultValue,
      placeholder: placeholder ?? this.placeholder,
      helpText: helpText ?? this.helpText,
      quantityTypeID: quantityTypeID ?? this.quantityTypeID,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (fieldType.present) {
      map['field_type'] = Variable<String>(fieldType.value);
    }
    if (unit.present) {
      map['unit'] = Variable<String>(unit.value);
    }
    if (validationRules.present) {
      map['validation_rules'] = Variable<String>(validationRules.value);
    }
    if (displayOrder.present) {
      map['display_order'] = Variable<int>(displayOrder.value);
    }
    if (isRequired.present) {
      map['is_required'] = Variable<bool>(isRequired.value);
    }
    if (isForSegment.present) {
      map['is_for_segment'] = Variable<bool>(isForSegment.value);
    }
    if (defaultValue.present) {
      map['default_value'] = Variable<String>(defaultValue.value);
    }
    if (placeholder.present) {
      map['placeholder'] = Variable<String>(placeholder.value);
    }
    if (helpText.present) {
      map['help_text'] = Variable<String>(helpText.value);
    }
    if (quantityTypeID.present) {
      map['quantity_type_i_d'] = Variable<int>(quantityTypeID.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WorkQuantityFieldsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('code: $code, ')
          ..write('fieldType: $fieldType, ')
          ..write('unit: $unit, ')
          ..write('validationRules: $validationRules, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('isRequired: $isRequired, ')
          ..write('isForSegment: $isForSegment, ')
          ..write('defaultValue: $defaultValue, ')
          ..write('placeholder: $placeholder, ')
          ..write('helpText: $helpText, ')
          ..write('quantityTypeID: $quantityTypeID')
          ..write(')'))
        .toString();
  }
}

class $WorkQuantityFieldOptionsTable extends WorkQuantityFieldOptions
    with
        TableInfo<
          $WorkQuantityFieldOptionsTable,
          WorkQuantityFieldOptionRecord
        > {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WorkQuantityFieldOptionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
    'value',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _displayOrderMeta = const VerificationMeta(
    'displayOrder',
  );
  @override
  late final GeneratedColumn<int> displayOrder = GeneratedColumn<int>(
    'display_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fieldIDMeta = const VerificationMeta(
    'fieldID',
  );
  @override
  late final GeneratedColumn<int> fieldID = GeneratedColumn<int>(
    'field_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    value,
    displayOrder,
    fieldID,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'work_quantity_field_options';
  @override
  VerificationContext validateIntegrity(
    Insertable<WorkQuantityFieldOptionRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
        _valueMeta,
        value.isAcceptableOrUnknown(data['value']!, _valueMeta),
      );
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('display_order')) {
      context.handle(
        _displayOrderMeta,
        displayOrder.isAcceptableOrUnknown(
          data['display_order']!,
          _displayOrderMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_displayOrderMeta);
    }
    if (data.containsKey('field_i_d')) {
      context.handle(
        _fieldIDMeta,
        fieldID.isAcceptableOrUnknown(data['field_i_d']!, _fieldIDMeta),
      );
    } else if (isInserting) {
      context.missing(_fieldIDMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  WorkQuantityFieldOptionRecord map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WorkQuantityFieldOptionRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      value: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}value'],
      )!,
      displayOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}display_order'],
      )!,
      fieldID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}field_i_d'],
      )!,
    );
  }

  @override
  $WorkQuantityFieldOptionsTable createAlias(String alias) {
    return $WorkQuantityFieldOptionsTable(attachedDatabase, alias);
  }
}

class WorkQuantityFieldOptionRecord extends DataClass
    implements Insertable<WorkQuantityFieldOptionRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String value;
  final int displayOrder;
  final int fieldID;
  const WorkQuantityFieldOptionRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.value,
    required this.displayOrder,
    required this.fieldID,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['value'] = Variable<String>(value);
    map['display_order'] = Variable<int>(displayOrder);
    map['field_i_d'] = Variable<int>(fieldID);
    return map;
  }

  WorkQuantityFieldOptionsCompanion toCompanion(bool nullToAbsent) {
    return WorkQuantityFieldOptionsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      value: Value(value),
      displayOrder: Value(displayOrder),
      fieldID: Value(fieldID),
    );
  }

  factory WorkQuantityFieldOptionRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WorkQuantityFieldOptionRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      value: serializer.fromJson<String>(json['value']),
      displayOrder: serializer.fromJson<int>(json['displayOrder']),
      fieldID: serializer.fromJson<int>(json['fieldID']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'value': serializer.toJson<String>(value),
      'displayOrder': serializer.toJson<int>(displayOrder),
      'fieldID': serializer.toJson<int>(fieldID),
    };
  }

  WorkQuantityFieldOptionRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? value,
    int? displayOrder,
    int? fieldID,
  }) => WorkQuantityFieldOptionRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    value: value ?? this.value,
    displayOrder: displayOrder ?? this.displayOrder,
    fieldID: fieldID ?? this.fieldID,
  );
  WorkQuantityFieldOptionRecord copyWithCompanion(
    WorkQuantityFieldOptionsCompanion data,
  ) {
    return WorkQuantityFieldOptionRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      value: data.value.present ? data.value.value : this.value,
      displayOrder: data.displayOrder.present
          ? data.displayOrder.value
          : this.displayOrder,
      fieldID: data.fieldID.present ? data.fieldID.value : this.fieldID,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WorkQuantityFieldOptionRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('value: $value, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('fieldID: $fieldID')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    value,
    displayOrder,
    fieldID,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WorkQuantityFieldOptionRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.value == this.value &&
          other.displayOrder == this.displayOrder &&
          other.fieldID == this.fieldID);
}

class WorkQuantityFieldOptionsCompanion
    extends UpdateCompanion<WorkQuantityFieldOptionRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> value;
  final Value<int> displayOrder;
  final Value<int> fieldID;
  const WorkQuantityFieldOptionsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.value = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.fieldID = const Value.absent(),
  });
  WorkQuantityFieldOptionsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String value,
    required int displayOrder,
    required int fieldID,
  }) : uid = Value(uid),
       value = Value(value),
       displayOrder = Value(displayOrder),
       fieldID = Value(fieldID);
  static Insertable<WorkQuantityFieldOptionRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? value,
    Expression<int>? displayOrder,
    Expression<int>? fieldID,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (value != null) 'value': value,
      if (displayOrder != null) 'display_order': displayOrder,
      if (fieldID != null) 'field_i_d': fieldID,
    });
  }

  WorkQuantityFieldOptionsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? value,
    Value<int>? displayOrder,
    Value<int>? fieldID,
  }) {
    return WorkQuantityFieldOptionsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      value: value ?? this.value,
      displayOrder: displayOrder ?? this.displayOrder,
      fieldID: fieldID ?? this.fieldID,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (displayOrder.present) {
      map['display_order'] = Variable<int>(displayOrder.value);
    }
    if (fieldID.present) {
      map['field_i_d'] = Variable<int>(fieldID.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WorkQuantityFieldOptionsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('value: $value, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('fieldID: $fieldID')
          ..write(')'))
        .toString();
  }
}

class $WorkScopeEquipmentsTable extends WorkScopeEquipments
    with TableInfo<$WorkScopeEquipmentsTable, WorkScopeEquipmentsRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WorkScopeEquipmentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
    'code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    code,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'work_scope_equipments';
  @override
  VerificationContext validateIntegrity(
    Insertable<WorkScopeEquipmentsRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('code')) {
      context.handle(
        _codeMeta,
        code.isAcceptableOrUnknown(data['code']!, _codeMeta),
      );
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  WorkScopeEquipmentsRecord map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WorkScopeEquipmentsRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      code: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}code'],
      )!,
    );
  }

  @override
  $WorkScopeEquipmentsTable createAlias(String alias) {
    return $WorkScopeEquipmentsTable(attachedDatabase, alias);
  }
}

class WorkScopeEquipmentsRecord extends DataClass
    implements Insertable<WorkScopeEquipmentsRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final String code;
  const WorkScopeEquipmentsRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    required this.code,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    map['code'] = Variable<String>(code);
    return map;
  }

  WorkScopeEquipmentsCompanion toCompanion(bool nullToAbsent) {
    return WorkScopeEquipmentsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      code: Value(code),
    );
  }

  factory WorkScopeEquipmentsRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WorkScopeEquipmentsRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      code: serializer.fromJson<String>(json['code']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'code': serializer.toJson<String>(code),
    };
  }

  WorkScopeEquipmentsRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    String? code,
  }) => WorkScopeEquipmentsRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    code: code ?? this.code,
  );
  WorkScopeEquipmentsRecord copyWithCompanion(
    WorkScopeEquipmentsCompanion data,
  ) {
    return WorkScopeEquipmentsRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      code: data.code.present ? data.code.value : this.code,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WorkScopeEquipmentsRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('code: $code')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    code,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WorkScopeEquipmentsRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.code == this.code);
}

class WorkScopeEquipmentsCompanion
    extends UpdateCompanion<WorkScopeEquipmentsRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String> code;
  const WorkScopeEquipmentsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.code = const Value.absent(),
  });
  WorkScopeEquipmentsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    required String code,
  }) : uid = Value(uid),
       name = Value(name),
       code = Value(code);
  static Insertable<WorkScopeEquipmentsRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? code,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (code != null) 'code': code,
    });
  }

  WorkScopeEquipmentsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String>? code,
  }) {
    return WorkScopeEquipmentsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      code: code ?? this.code,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WorkScopeEquipmentsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('code: $code')
          ..write(')'))
        .toString();
  }
}

class $WorkScopeEquipmentTable extends WorkScopeEquipment
    with TableInfo<$WorkScopeEquipmentTable, WorkScopeEquipmentRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WorkScopeEquipmentTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _workScopeIDMeta = const VerificationMeta(
    'workScopeID',
  );
  @override
  late final GeneratedColumn<int> workScopeID = GeneratedColumn<int>(
    'work_scope_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _workEquipmentIDMeta = const VerificationMeta(
    'workEquipmentID',
  );
  @override
  late final GeneratedColumn<int> workEquipmentID = GeneratedColumn<int>(
    'work_equipment_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    workScopeID,
    workEquipmentID,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'work_scope_equipment';
  @override
  VerificationContext validateIntegrity(
    Insertable<WorkScopeEquipmentRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('work_scope_i_d')) {
      context.handle(
        _workScopeIDMeta,
        workScopeID.isAcceptableOrUnknown(
          data['work_scope_i_d']!,
          _workScopeIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_workScopeIDMeta);
    }
    if (data.containsKey('work_equipment_i_d')) {
      context.handle(
        _workEquipmentIDMeta,
        workEquipmentID.isAcceptableOrUnknown(
          data['work_equipment_i_d']!,
          _workEquipmentIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_workEquipmentIDMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {workScopeID, workEquipmentID},
  ];
  @override
  WorkScopeEquipmentRecord map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WorkScopeEquipmentRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      workScopeID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}work_scope_i_d'],
      )!,
      workEquipmentID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}work_equipment_i_d'],
      )!,
    );
  }

  @override
  $WorkScopeEquipmentTable createAlias(String alias) {
    return $WorkScopeEquipmentTable(attachedDatabase, alias);
  }
}

class WorkScopeEquipmentRecord extends DataClass
    implements Insertable<WorkScopeEquipmentRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final int workScopeID;
  final int workEquipmentID;
  const WorkScopeEquipmentRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.workScopeID,
    required this.workEquipmentID,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['work_scope_i_d'] = Variable<int>(workScopeID);
    map['work_equipment_i_d'] = Variable<int>(workEquipmentID);
    return map;
  }

  WorkScopeEquipmentCompanion toCompanion(bool nullToAbsent) {
    return WorkScopeEquipmentCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      workScopeID: Value(workScopeID),
      workEquipmentID: Value(workEquipmentID),
    );
  }

  factory WorkScopeEquipmentRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WorkScopeEquipmentRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      workScopeID: serializer.fromJson<int>(json['workScopeID']),
      workEquipmentID: serializer.fromJson<int>(json['workEquipmentID']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'workScopeID': serializer.toJson<int>(workScopeID),
      'workEquipmentID': serializer.toJson<int>(workEquipmentID),
    };
  }

  WorkScopeEquipmentRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    int? workScopeID,
    int? workEquipmentID,
  }) => WorkScopeEquipmentRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    workScopeID: workScopeID ?? this.workScopeID,
    workEquipmentID: workEquipmentID ?? this.workEquipmentID,
  );
  WorkScopeEquipmentRecord copyWithCompanion(WorkScopeEquipmentCompanion data) {
    return WorkScopeEquipmentRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      workScopeID: data.workScopeID.present
          ? data.workScopeID.value
          : this.workScopeID,
      workEquipmentID: data.workEquipmentID.present
          ? data.workEquipmentID.value
          : this.workEquipmentID,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WorkScopeEquipmentRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('workScopeID: $workScopeID, ')
          ..write('workEquipmentID: $workEquipmentID')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    workScopeID,
    workEquipmentID,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WorkScopeEquipmentRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.workScopeID == this.workScopeID &&
          other.workEquipmentID == this.workEquipmentID);
}

class WorkScopeEquipmentCompanion
    extends UpdateCompanion<WorkScopeEquipmentRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<int> workScopeID;
  final Value<int> workEquipmentID;
  const WorkScopeEquipmentCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.workScopeID = const Value.absent(),
    this.workEquipmentID = const Value.absent(),
  });
  WorkScopeEquipmentCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required int workScopeID,
    required int workEquipmentID,
  }) : workScopeID = Value(workScopeID),
       workEquipmentID = Value(workEquipmentID);
  static Insertable<WorkScopeEquipmentRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<int>? workScopeID,
    Expression<int>? workEquipmentID,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (workScopeID != null) 'work_scope_i_d': workScopeID,
      if (workEquipmentID != null) 'work_equipment_i_d': workEquipmentID,
    });
  }

  WorkScopeEquipmentCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<int>? workScopeID,
    Value<int>? workEquipmentID,
  }) {
    return WorkScopeEquipmentCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      workScopeID: workScopeID ?? this.workScopeID,
      workEquipmentID: workEquipmentID ?? this.workEquipmentID,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (workScopeID.present) {
      map['work_scope_i_d'] = Variable<int>(workScopeID.value);
    }
    if (workEquipmentID.present) {
      map['work_equipment_i_d'] = Variable<int>(workEquipmentID.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WorkScopeEquipmentCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('workScopeID: $workScopeID, ')
          ..write('workEquipmentID: $workEquipmentID')
          ..write(')'))
        .toString();
  }
}

class $CountriesTable extends Countries
    with TableInfo<$CountriesTable, CountryRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CountriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'countries';
  @override
  VerificationContext validateIntegrity(
    Insertable<CountryRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  CountryRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CountryRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $CountriesTable createAlias(String alias) {
    return $CountriesTable(attachedDatabase, alias);
  }
}

class CountryRecord extends DataClass implements Insertable<CountryRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final DateTime createdAt;
  final DateTime updatedAt;
  const CountryRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  CountriesCompanion toCompanion(bool nullToAbsent) {
    return CountriesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory CountryRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CountryRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  CountryRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => CountryRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  CountryRecord copyWithCompanion(CountriesCompanion data) {
    return CountryRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CountryRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CountryRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class CountriesCompanion extends UpdateCompanion<CountryRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const CountriesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  CountriesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       name = Value(name),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<CountryRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  CountriesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return CountriesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CountriesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ProvincesTable extends Provinces
    with TableInfo<$ProvincesTable, ProvinceRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ProvincesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _countryIDMeta = const VerificationMeta(
    'countryID',
  );
  @override
  late final GeneratedColumn<int> countryID = GeneratedColumn<int>(
    'country_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    countryID,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'provinces';
  @override
  VerificationContext validateIntegrity(
    Insertable<ProvinceRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('country_i_d')) {
      context.handle(
        _countryIDMeta,
        countryID.isAcceptableOrUnknown(data['country_i_d']!, _countryIDMeta),
      );
    } else if (isInserting) {
      context.missing(_countryIDMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  ProvinceRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ProvinceRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      countryID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}country_i_d'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ProvincesTable createAlias(String alias) {
    return $ProvincesTable(attachedDatabase, alias);
  }
}

class ProvinceRecord extends DataClass implements Insertable<ProvinceRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final int countryID;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ProvinceRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    required this.countryID,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    map['country_i_d'] = Variable<int>(countryID);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ProvincesCompanion toCompanion(bool nullToAbsent) {
    return ProvincesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      countryID: Value(countryID),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ProvinceRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ProvinceRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      countryID: serializer.fromJson<int>(json['countryID']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'countryID': serializer.toJson<int>(countryID),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ProvinceRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    int? countryID,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ProvinceRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    countryID: countryID ?? this.countryID,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ProvinceRecord copyWithCompanion(ProvincesCompanion data) {
    return ProvinceRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      countryID: data.countryID.present ? data.countryID.value : this.countryID,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ProvinceRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('countryID: $countryID, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    countryID,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ProvinceRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.countryID == this.countryID &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ProvincesCompanion extends UpdateCompanion<ProvinceRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<int> countryID;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ProvincesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.countryID = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ProvincesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    required int countryID,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       name = Value(name),
       countryID = Value(countryID),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ProvinceRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<int>? countryID,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (countryID != null) 'country_i_d': countryID,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ProvincesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<int>? countryID,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return ProvincesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      countryID: countryID ?? this.countryID,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (countryID.present) {
      map['country_i_d'] = Variable<int>(countryID.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ProvincesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('countryID: $countryID, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $DistrictsTable extends Districts
    with TableInfo<$DistrictsTable, DistrictRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DistrictsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _stateIdMeta = const VerificationMeta(
    'stateId',
  );
  @override
  late final GeneratedColumn<int> stateId = GeneratedColumn<int>(
    'state_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    stateId,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'districts';
  @override
  VerificationContext validateIntegrity(
    Insertable<DistrictRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('state_id')) {
      context.handle(
        _stateIdMeta,
        stateId.isAcceptableOrUnknown(data['state_id']!, _stateIdMeta),
      );
    } else if (isInserting) {
      context.missing(_stateIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  DistrictRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DistrictRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      stateId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}state_id'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $DistrictsTable createAlias(String alias) {
    return $DistrictsTable(attachedDatabase, alias);
  }
}

class DistrictRecord extends DataClass implements Insertable<DistrictRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final int stateId;
  final DateTime createdAt;
  final DateTime updatedAt;
  const DistrictRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    required this.stateId,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    map['state_id'] = Variable<int>(stateId);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  DistrictsCompanion toCompanion(bool nullToAbsent) {
    return DistrictsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      stateId: Value(stateId),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory DistrictRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DistrictRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      stateId: serializer.fromJson<int>(json['stateId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'stateId': serializer.toJson<int>(stateId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  DistrictRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    int? stateId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => DistrictRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    stateId: stateId ?? this.stateId,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  DistrictRecord copyWithCompanion(DistrictsCompanion data) {
    return DistrictRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      stateId: data.stateId.present ? data.stateId.value : this.stateId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DistrictRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('stateId: $stateId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    stateId,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DistrictRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.stateId == this.stateId &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class DistrictsCompanion extends UpdateCompanion<DistrictRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<int> stateId;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const DistrictsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.stateId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  DistrictsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    required int stateId,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       name = Value(name),
       stateId = Value(stateId),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<DistrictRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<int>? stateId,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (stateId != null) 'state_id': stateId,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  DistrictsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<int>? stateId,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return DistrictsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      stateId: stateId ?? this.stateId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (stateId.present) {
      map['state_id'] = Variable<int>(stateId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DistrictsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('stateId: $stateId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $RoadCategoriesTable extends RoadCategories
    with TableInfo<$RoadCategoriesTable, RoadCategoryRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RoadCategoriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'road_categories';
  @override
  VerificationContext validateIntegrity(
    Insertable<RoadCategoryRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  RoadCategoryRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RoadCategoryRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $RoadCategoriesTable createAlias(String alias) {
    return $RoadCategoriesTable(attachedDatabase, alias);
  }
}

class RoadCategoryRecord extends DataClass
    implements Insertable<RoadCategoryRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final DateTime createdAt;
  final DateTime updatedAt;
  const RoadCategoryRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  RoadCategoriesCompanion toCompanion(bool nullToAbsent) {
    return RoadCategoriesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory RoadCategoryRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RoadCategoryRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  RoadCategoryRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => RoadCategoryRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  RoadCategoryRecord copyWithCompanion(RoadCategoriesCompanion data) {
    return RoadCategoryRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RoadCategoryRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RoadCategoryRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class RoadCategoriesCompanion extends UpdateCompanion<RoadCategoryRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const RoadCategoriesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  RoadCategoriesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       name = Value(name),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<RoadCategoryRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  RoadCategoriesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return RoadCategoriesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RoadCategoriesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $RoadsTable extends Roads with TableInfo<$RoadsTable, RoadRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RoadsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roadNoMeta = const VerificationMeta('roadNo');
  @override
  late final GeneratedColumn<String> roadNo = GeneratedColumn<String>(
    'road_no',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sectionStartMeta = const VerificationMeta(
    'sectionStart',
  );
  @override
  late final GeneratedColumn<double> sectionStart = GeneratedColumn<double>(
    'section_start',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sectionFinishMeta = const VerificationMeta(
    'sectionFinish',
  );
  @override
  late final GeneratedColumn<double> sectionFinish = GeneratedColumn<double>(
    'section_finish',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _mainCategoryIdMeta = const VerificationMeta(
    'mainCategoryId',
  );
  @override
  late final GeneratedColumn<int> mainCategoryId = GeneratedColumn<int>(
    'main_category_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _secondaryCategoryIdMeta =
      const VerificationMeta('secondaryCategoryId');
  @override
  late final GeneratedColumn<int> secondaryCategoryId = GeneratedColumn<int>(
    'secondary_category_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _districtIdMeta = const VerificationMeta(
    'districtId',
  );
  @override
  late final GeneratedColumn<int> districtId = GeneratedColumn<int>(
    'district_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    roadNo,
    sectionStart,
    sectionFinish,
    mainCategoryId,
    secondaryCategoryId,
    districtId,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'roads';
  @override
  VerificationContext validateIntegrity(
    Insertable<RoadRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('road_no')) {
      context.handle(
        _roadNoMeta,
        roadNo.isAcceptableOrUnknown(data['road_no']!, _roadNoMeta),
      );
    }
    if (data.containsKey('section_start')) {
      context.handle(
        _sectionStartMeta,
        sectionStart.isAcceptableOrUnknown(
          data['section_start']!,
          _sectionStartMeta,
        ),
      );
    }
    if (data.containsKey('section_finish')) {
      context.handle(
        _sectionFinishMeta,
        sectionFinish.isAcceptableOrUnknown(
          data['section_finish']!,
          _sectionFinishMeta,
        ),
      );
    }
    if (data.containsKey('main_category_id')) {
      context.handle(
        _mainCategoryIdMeta,
        mainCategoryId.isAcceptableOrUnknown(
          data['main_category_id']!,
          _mainCategoryIdMeta,
        ),
      );
    }
    if (data.containsKey('secondary_category_id')) {
      context.handle(
        _secondaryCategoryIdMeta,
        secondaryCategoryId.isAcceptableOrUnknown(
          data['secondary_category_id']!,
          _secondaryCategoryIdMeta,
        ),
      );
    }
    if (data.containsKey('district_id')) {
      context.handle(
        _districtIdMeta,
        districtId.isAcceptableOrUnknown(data['district_id']!, _districtIdMeta),
      );
    } else if (isInserting) {
      context.missing(_districtIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  RoadRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RoadRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      roadNo: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}road_no'],
      ),
      sectionStart: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}section_start'],
      ),
      sectionFinish: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}section_finish'],
      ),
      mainCategoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}main_category_id'],
      ),
      secondaryCategoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}secondary_category_id'],
      ),
      districtId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}district_id'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $RoadsTable createAlias(String alias) {
    return $RoadsTable(attachedDatabase, alias);
  }
}

class RoadRecord extends DataClass implements Insertable<RoadRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final String? roadNo;
  final double? sectionStart;
  final double? sectionFinish;
  final int? mainCategoryId;
  final int? secondaryCategoryId;
  final int districtId;
  final DateTime createdAt;
  final DateTime updatedAt;
  const RoadRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    this.roadNo,
    this.sectionStart,
    this.sectionFinish,
    this.mainCategoryId,
    this.secondaryCategoryId,
    required this.districtId,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || roadNo != null) {
      map['road_no'] = Variable<String>(roadNo);
    }
    if (!nullToAbsent || sectionStart != null) {
      map['section_start'] = Variable<double>(sectionStart);
    }
    if (!nullToAbsent || sectionFinish != null) {
      map['section_finish'] = Variable<double>(sectionFinish);
    }
    if (!nullToAbsent || mainCategoryId != null) {
      map['main_category_id'] = Variable<int>(mainCategoryId);
    }
    if (!nullToAbsent || secondaryCategoryId != null) {
      map['secondary_category_id'] = Variable<int>(secondaryCategoryId);
    }
    map['district_id'] = Variable<int>(districtId);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  RoadsCompanion toCompanion(bool nullToAbsent) {
    return RoadsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      roadNo: roadNo == null && nullToAbsent
          ? const Value.absent()
          : Value(roadNo),
      sectionStart: sectionStart == null && nullToAbsent
          ? const Value.absent()
          : Value(sectionStart),
      sectionFinish: sectionFinish == null && nullToAbsent
          ? const Value.absent()
          : Value(sectionFinish),
      mainCategoryId: mainCategoryId == null && nullToAbsent
          ? const Value.absent()
          : Value(mainCategoryId),
      secondaryCategoryId: secondaryCategoryId == null && nullToAbsent
          ? const Value.absent()
          : Value(secondaryCategoryId),
      districtId: Value(districtId),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory RoadRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RoadRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      roadNo: serializer.fromJson<String?>(json['roadNo']),
      sectionStart: serializer.fromJson<double?>(json['sectionStart']),
      sectionFinish: serializer.fromJson<double?>(json['sectionFinish']),
      mainCategoryId: serializer.fromJson<int?>(json['mainCategoryId']),
      secondaryCategoryId: serializer.fromJson<int?>(
        json['secondaryCategoryId'],
      ),
      districtId: serializer.fromJson<int>(json['districtId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'roadNo': serializer.toJson<String?>(roadNo),
      'sectionStart': serializer.toJson<double?>(sectionStart),
      'sectionFinish': serializer.toJson<double?>(sectionFinish),
      'mainCategoryId': serializer.toJson<int?>(mainCategoryId),
      'secondaryCategoryId': serializer.toJson<int?>(secondaryCategoryId),
      'districtId': serializer.toJson<int>(districtId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  RoadRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    Value<String?> roadNo = const Value.absent(),
    Value<double?> sectionStart = const Value.absent(),
    Value<double?> sectionFinish = const Value.absent(),
    Value<int?> mainCategoryId = const Value.absent(),
    Value<int?> secondaryCategoryId = const Value.absent(),
    int? districtId,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => RoadRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    roadNo: roadNo.present ? roadNo.value : this.roadNo,
    sectionStart: sectionStart.present ? sectionStart.value : this.sectionStart,
    sectionFinish: sectionFinish.present
        ? sectionFinish.value
        : this.sectionFinish,
    mainCategoryId: mainCategoryId.present
        ? mainCategoryId.value
        : this.mainCategoryId,
    secondaryCategoryId: secondaryCategoryId.present
        ? secondaryCategoryId.value
        : this.secondaryCategoryId,
    districtId: districtId ?? this.districtId,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  RoadRecord copyWithCompanion(RoadsCompanion data) {
    return RoadRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      roadNo: data.roadNo.present ? data.roadNo.value : this.roadNo,
      sectionStart: data.sectionStart.present
          ? data.sectionStart.value
          : this.sectionStart,
      sectionFinish: data.sectionFinish.present
          ? data.sectionFinish.value
          : this.sectionFinish,
      mainCategoryId: data.mainCategoryId.present
          ? data.mainCategoryId.value
          : this.mainCategoryId,
      secondaryCategoryId: data.secondaryCategoryId.present
          ? data.secondaryCategoryId.value
          : this.secondaryCategoryId,
      districtId: data.districtId.present
          ? data.districtId.value
          : this.districtId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RoadRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('roadNo: $roadNo, ')
          ..write('sectionStart: $sectionStart, ')
          ..write('sectionFinish: $sectionFinish, ')
          ..write('mainCategoryId: $mainCategoryId, ')
          ..write('secondaryCategoryId: $secondaryCategoryId, ')
          ..write('districtId: $districtId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    roadNo,
    sectionStart,
    sectionFinish,
    mainCategoryId,
    secondaryCategoryId,
    districtId,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RoadRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.roadNo == this.roadNo &&
          other.sectionStart == this.sectionStart &&
          other.sectionFinish == this.sectionFinish &&
          other.mainCategoryId == this.mainCategoryId &&
          other.secondaryCategoryId == this.secondaryCategoryId &&
          other.districtId == this.districtId &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class RoadsCompanion extends UpdateCompanion<RoadRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String?> roadNo;
  final Value<double?> sectionStart;
  final Value<double?> sectionFinish;
  final Value<int?> mainCategoryId;
  final Value<int?> secondaryCategoryId;
  final Value<int> districtId;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const RoadsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.roadNo = const Value.absent(),
    this.sectionStart = const Value.absent(),
    this.sectionFinish = const Value.absent(),
    this.mainCategoryId = const Value.absent(),
    this.secondaryCategoryId = const Value.absent(),
    this.districtId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  RoadsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    this.roadNo = const Value.absent(),
    this.sectionStart = const Value.absent(),
    this.sectionFinish = const Value.absent(),
    this.mainCategoryId = const Value.absent(),
    this.secondaryCategoryId = const Value.absent(),
    required int districtId,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       name = Value(name),
       districtId = Value(districtId),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<RoadRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? roadNo,
    Expression<double>? sectionStart,
    Expression<double>? sectionFinish,
    Expression<int>? mainCategoryId,
    Expression<int>? secondaryCategoryId,
    Expression<int>? districtId,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (roadNo != null) 'road_no': roadNo,
      if (sectionStart != null) 'section_start': sectionStart,
      if (sectionFinish != null) 'section_finish': sectionFinish,
      if (mainCategoryId != null) 'main_category_id': mainCategoryId,
      if (secondaryCategoryId != null)
        'secondary_category_id': secondaryCategoryId,
      if (districtId != null) 'district_id': districtId,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  RoadsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String?>? roadNo,
    Value<double?>? sectionStart,
    Value<double?>? sectionFinish,
    Value<int?>? mainCategoryId,
    Value<int?>? secondaryCategoryId,
    Value<int>? districtId,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return RoadsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      roadNo: roadNo ?? this.roadNo,
      sectionStart: sectionStart ?? this.sectionStart,
      sectionFinish: sectionFinish ?? this.sectionFinish,
      mainCategoryId: mainCategoryId ?? this.mainCategoryId,
      secondaryCategoryId: secondaryCategoryId ?? this.secondaryCategoryId,
      districtId: districtId ?? this.districtId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (roadNo.present) {
      map['road_no'] = Variable<String>(roadNo.value);
    }
    if (sectionStart.present) {
      map['section_start'] = Variable<double>(sectionStart.value);
    }
    if (sectionFinish.present) {
      map['section_finish'] = Variable<double>(sectionFinish.value);
    }
    if (mainCategoryId.present) {
      map['main_category_id'] = Variable<int>(mainCategoryId.value);
    }
    if (secondaryCategoryId.present) {
      map['secondary_category_id'] = Variable<int>(secondaryCategoryId.value);
    }
    if (districtId.present) {
      map['district_id'] = Variable<int>(districtId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RoadsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('roadNo: $roadNo, ')
          ..write('sectionStart: $sectionStart, ')
          ..write('sectionFinish: $sectionFinish, ')
          ..write('mainCategoryId: $mainCategoryId, ')
          ..write('secondaryCategoryId: $secondaryCategoryId, ')
          ..write('districtId: $districtId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $PackagesTable extends Packages
    with TableInfo<$PackagesTable, PackageRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PackagesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    description,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'packages';
  @override
  VerificationContext validateIntegrity(
    Insertable<PackageRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  PackageRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PackageRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $PackagesTable createAlias(String alias) {
    return $PackagesTable(attachedDatabase, alias);
  }
}

class PackageRecord extends DataClass implements Insertable<PackageRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final String? description;
  final DateTime createdAt;
  final DateTime updatedAt;
  const PackageRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    this.description,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  PackagesCompanion toCompanion(bool nullToAbsent) {
    return PackagesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory PackageRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PackageRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  PackageRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    Value<String?> description = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => PackageRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    description: description.present ? description.value : this.description,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  PackageRecord copyWithCompanion(PackagesCompanion data) {
    return PackageRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      description: data.description.present
          ? data.description.value
          : this.description,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PackageRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    description,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PackageRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.description == this.description &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class PackagesCompanion extends UpdateCompanion<PackageRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String?> description;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const PackagesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  PackagesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    this.description = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       name = Value(name),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<PackageRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? description,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  PackagesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String?>? description,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return PackagesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      description: description ?? this.description,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PackagesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $PackageRoadsTable extends PackageRoads
    with TableInfo<$PackageRoadsTable, PackageRoadRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PackageRoadsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roadUIDMeta = const VerificationMeta(
    'roadUID',
  );
  @override
  late final GeneratedColumn<String> roadUID = GeneratedColumn<String>(
    'road_u_i_d',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sectionStartMeta = const VerificationMeta(
    'sectionStart',
  );
  @override
  late final GeneratedColumn<double> sectionStart = GeneratedColumn<double>(
    'section_start',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sectionFinishMeta = const VerificationMeta(
    'sectionFinish',
  );
  @override
  late final GeneratedColumn<double> sectionFinish = GeneratedColumn<double>(
    'section_finish',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    roadUID,
    sectionStart,
    sectionFinish,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'package_roads';
  @override
  VerificationContext validateIntegrity(
    Insertable<PackageRoadRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('road_u_i_d')) {
      context.handle(
        _roadUIDMeta,
        roadUID.isAcceptableOrUnknown(data['road_u_i_d']!, _roadUIDMeta),
      );
    } else if (isInserting) {
      context.missing(_roadUIDMeta);
    }
    if (data.containsKey('section_start')) {
      context.handle(
        _sectionStartMeta,
        sectionStart.isAcceptableOrUnknown(
          data['section_start']!,
          _sectionStartMeta,
        ),
      );
    }
    if (data.containsKey('section_finish')) {
      context.handle(
        _sectionFinishMeta,
        sectionFinish.isAcceptableOrUnknown(
          data['section_finish']!,
          _sectionFinishMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  PackageRoadRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PackageRoadRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      roadUID: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}road_u_i_d'],
      )!,
      sectionStart: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}section_start'],
      ),
      sectionFinish: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}section_finish'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $PackageRoadsTable createAlias(String alias) {
    return $PackageRoadsTable(attachedDatabase, alias);
  }
}

class PackageRoadRecord extends DataClass
    implements Insertable<PackageRoadRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String roadUID;
  final double? sectionStart;
  final double? sectionFinish;
  final DateTime createdAt;
  final DateTime updatedAt;
  const PackageRoadRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.roadUID,
    this.sectionStart,
    this.sectionFinish,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['road_u_i_d'] = Variable<String>(roadUID);
    if (!nullToAbsent || sectionStart != null) {
      map['section_start'] = Variable<double>(sectionStart);
    }
    if (!nullToAbsent || sectionFinish != null) {
      map['section_finish'] = Variable<double>(sectionFinish);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  PackageRoadsCompanion toCompanion(bool nullToAbsent) {
    return PackageRoadsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      roadUID: Value(roadUID),
      sectionStart: sectionStart == null && nullToAbsent
          ? const Value.absent()
          : Value(sectionStart),
      sectionFinish: sectionFinish == null && nullToAbsent
          ? const Value.absent()
          : Value(sectionFinish),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory PackageRoadRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PackageRoadRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      roadUID: serializer.fromJson<String>(json['roadUID']),
      sectionStart: serializer.fromJson<double?>(json['sectionStart']),
      sectionFinish: serializer.fromJson<double?>(json['sectionFinish']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'roadUID': serializer.toJson<String>(roadUID),
      'sectionStart': serializer.toJson<double?>(sectionStart),
      'sectionFinish': serializer.toJson<double?>(sectionFinish),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  PackageRoadRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? roadUID,
    Value<double?> sectionStart = const Value.absent(),
    Value<double?> sectionFinish = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => PackageRoadRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    roadUID: roadUID ?? this.roadUID,
    sectionStart: sectionStart.present ? sectionStart.value : this.sectionStart,
    sectionFinish: sectionFinish.present
        ? sectionFinish.value
        : this.sectionFinish,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  PackageRoadRecord copyWithCompanion(PackageRoadsCompanion data) {
    return PackageRoadRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      roadUID: data.roadUID.present ? data.roadUID.value : this.roadUID,
      sectionStart: data.sectionStart.present
          ? data.sectionStart.value
          : this.sectionStart,
      sectionFinish: data.sectionFinish.present
          ? data.sectionFinish.value
          : this.sectionFinish,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PackageRoadRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('roadUID: $roadUID, ')
          ..write('sectionStart: $sectionStart, ')
          ..write('sectionFinish: $sectionFinish, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    roadUID,
    sectionStart,
    sectionFinish,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PackageRoadRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.roadUID == this.roadUID &&
          other.sectionStart == this.sectionStart &&
          other.sectionFinish == this.sectionFinish &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class PackageRoadsCompanion extends UpdateCompanion<PackageRoadRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> roadUID;
  final Value<double?> sectionStart;
  final Value<double?> sectionFinish;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const PackageRoadsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.roadUID = const Value.absent(),
    this.sectionStart = const Value.absent(),
    this.sectionFinish = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  PackageRoadsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String roadUID,
    this.sectionStart = const Value.absent(),
    this.sectionFinish = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : uid = Value(uid),
       roadUID = Value(roadUID),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<PackageRoadRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? roadUID,
    Expression<double>? sectionStart,
    Expression<double>? sectionFinish,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (roadUID != null) 'road_u_i_d': roadUID,
      if (sectionStart != null) 'section_start': sectionStart,
      if (sectionFinish != null) 'section_finish': sectionFinish,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  PackageRoadsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? roadUID,
    Value<double?>? sectionStart,
    Value<double?>? sectionFinish,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return PackageRoadsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      roadUID: roadUID ?? this.roadUID,
      sectionStart: sectionStart ?? this.sectionStart,
      sectionFinish: sectionFinish ?? this.sectionFinish,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (roadUID.present) {
      map['road_u_i_d'] = Variable<String>(roadUID.value);
    }
    if (sectionStart.present) {
      map['section_start'] = Variable<double>(sectionStart.value);
    }
    if (sectionFinish.present) {
      map['section_finish'] = Variable<double>(sectionFinish.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PackageRoadsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('roadUID: $roadUID, ')
          ..write('sectionStart: $sectionStart, ')
          ..write('sectionFinish: $sectionFinish, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $DailyReportsTable extends DailyReports
    with TableInfo<$DailyReportsTable, DailyReportRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $DailyReportsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _uidMeta = const VerificationMeta('uid');
  @override
  late final GeneratedColumn<String> uid = GeneratedColumn<String>(
    'uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _weatherConditionMeta = const VerificationMeta(
    'weatherCondition',
  );
  @override
  late final GeneratedColumn<String> weatherCondition = GeneratedColumn<String>(
    'weather_condition',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _workPerformedMeta = const VerificationMeta(
    'workPerformed',
  );
  @override
  late final GeneratedColumn<bool> workPerformed = GeneratedColumn<bool>(
    'work_performed',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("work_performed" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _companyIDMeta = const VerificationMeta(
    'companyID',
  );
  @override
  late final GeneratedColumn<int> companyID = GeneratedColumn<int>(
    'company_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contractRelationIDMeta =
      const VerificationMeta('contractRelationID');
  @override
  late final GeneratedColumn<int> contractRelationID = GeneratedColumn<int>(
    'contract_relation_i_d',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('SUBMITTED'),
  );
  static const VerificationMeta _approvedByIDMeta = const VerificationMeta(
    'approvedByID',
  );
  @override
  late final GeneratedColumn<int> approvedByID = GeneratedColumn<int>(
    'approved_by_i_d',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _approvedAtMeta = const VerificationMeta(
    'approvedAt',
  );
  @override
  late final GeneratedColumn<DateTime> approvedAt = GeneratedColumn<DateTime>(
    'approved_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _rejectionReasonMeta = const VerificationMeta(
    'rejectionReason',
  );
  @override
  late final GeneratedColumn<String> rejectionReason = GeneratedColumn<String>(
    'rejection_reason',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _workScopeIDMeta = const VerificationMeta(
    'workScopeID',
  );
  @override
  late final GeneratedColumn<int> workScopeID = GeneratedColumn<int>(
    'work_scope_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _roadIDMeta = const VerificationMeta('roadID');
  @override
  late final GeneratedColumn<int> roadID = GeneratedColumn<int>(
    'road_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _totalWorkersMeta = const VerificationMeta(
    'totalWorkers',
  );
  @override
  late final GeneratedColumn<int> totalWorkers = GeneratedColumn<int>(
    'total_workers',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _fromSectionMeta = const VerificationMeta(
    'fromSection',
  );
  @override
  late final GeneratedColumn<double> fromSection = GeneratedColumn<double>(
    'from_section',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _toSectionMeta = const VerificationMeta(
    'toSection',
  );
  @override
  late final GeneratedColumn<double> toSection = GeneratedColumn<double>(
    'to_section',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdByIDMeta = const VerificationMeta(
    'createdByID',
  );
  @override
  late final GeneratedColumn<int> createdByID = GeneratedColumn<int>(
    'created_by_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _workScopeDataMeta = const VerificationMeta(
    'workScopeData',
  );
  @override
  late final GeneratedColumn<String> workScopeData = GeneratedColumn<String>(
    'work_scope_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roadDataMeta = const VerificationMeta(
    'roadData',
  );
  @override
  late final GeneratedColumn<String> roadData = GeneratedColumn<String>(
    'road_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _equipmentsDataMeta = const VerificationMeta(
    'equipmentsData',
  );
  @override
  late final GeneratedColumn<String> equipmentsData = GeneratedColumn<String>(
    'equipments_data',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _reportQuantitiesDataMeta =
      const VerificationMeta('reportQuantitiesData');
  @override
  late final GeneratedColumn<String> reportQuantitiesData =
      GeneratedColumn<String>(
        'report_quantities_data',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    notes,
    weatherCondition,
    workPerformed,
    longitude,
    latitude,
    companyID,
    contractRelationID,
    status,
    approvedByID,
    approvedAt,
    rejectionReason,
    workScopeID,
    roadID,
    totalWorkers,
    fromSection,
    toSection,
    createdByID,
    createdAt,
    updatedAt,
    workScopeData,
    roadData,
    equipmentsData,
    reportQuantitiesData,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'daily_reports';
  @override
  VerificationContext validateIntegrity(
    Insertable<DailyReportRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uid')) {
      context.handle(
        _uidMeta,
        uid.isAcceptableOrUnknown(data['uid']!, _uidMeta),
      );
    } else if (isInserting) {
      context.missing(_uidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('weather_condition')) {
      context.handle(
        _weatherConditionMeta,
        weatherCondition.isAcceptableOrUnknown(
          data['weather_condition']!,
          _weatherConditionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_weatherConditionMeta);
    }
    if (data.containsKey('work_performed')) {
      context.handle(
        _workPerformedMeta,
        workPerformed.isAcceptableOrUnknown(
          data['work_performed']!,
          _workPerformedMeta,
        ),
      );
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    }
    if (data.containsKey('company_i_d')) {
      context.handle(
        _companyIDMeta,
        companyID.isAcceptableOrUnknown(data['company_i_d']!, _companyIDMeta),
      );
    } else if (isInserting) {
      context.missing(_companyIDMeta);
    }
    if (data.containsKey('contract_relation_i_d')) {
      context.handle(
        _contractRelationIDMeta,
        contractRelationID.isAcceptableOrUnknown(
          data['contract_relation_i_d']!,
          _contractRelationIDMeta,
        ),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('approved_by_i_d')) {
      context.handle(
        _approvedByIDMeta,
        approvedByID.isAcceptableOrUnknown(
          data['approved_by_i_d']!,
          _approvedByIDMeta,
        ),
      );
    }
    if (data.containsKey('approved_at')) {
      context.handle(
        _approvedAtMeta,
        approvedAt.isAcceptableOrUnknown(data['approved_at']!, _approvedAtMeta),
      );
    }
    if (data.containsKey('rejection_reason')) {
      context.handle(
        _rejectionReasonMeta,
        rejectionReason.isAcceptableOrUnknown(
          data['rejection_reason']!,
          _rejectionReasonMeta,
        ),
      );
    }
    if (data.containsKey('work_scope_i_d')) {
      context.handle(
        _workScopeIDMeta,
        workScopeID.isAcceptableOrUnknown(
          data['work_scope_i_d']!,
          _workScopeIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_workScopeIDMeta);
    }
    if (data.containsKey('road_i_d')) {
      context.handle(
        _roadIDMeta,
        roadID.isAcceptableOrUnknown(data['road_i_d']!, _roadIDMeta),
      );
    } else if (isInserting) {
      context.missing(_roadIDMeta);
    }
    if (data.containsKey('total_workers')) {
      context.handle(
        _totalWorkersMeta,
        totalWorkers.isAcceptableOrUnknown(
          data['total_workers']!,
          _totalWorkersMeta,
        ),
      );
    }
    if (data.containsKey('from_section')) {
      context.handle(
        _fromSectionMeta,
        fromSection.isAcceptableOrUnknown(
          data['from_section']!,
          _fromSectionMeta,
        ),
      );
    }
    if (data.containsKey('to_section')) {
      context.handle(
        _toSectionMeta,
        toSection.isAcceptableOrUnknown(data['to_section']!, _toSectionMeta),
      );
    }
    if (data.containsKey('created_by_i_d')) {
      context.handle(
        _createdByIDMeta,
        createdByID.isAcceptableOrUnknown(
          data['created_by_i_d']!,
          _createdByIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_createdByIDMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('work_scope_data')) {
      context.handle(
        _workScopeDataMeta,
        workScopeData.isAcceptableOrUnknown(
          data['work_scope_data']!,
          _workScopeDataMeta,
        ),
      );
    }
    if (data.containsKey('road_data')) {
      context.handle(
        _roadDataMeta,
        roadData.isAcceptableOrUnknown(data['road_data']!, _roadDataMeta),
      );
    }
    if (data.containsKey('equipments_data')) {
      context.handle(
        _equipmentsDataMeta,
        equipmentsData.isAcceptableOrUnknown(
          data['equipments_data']!,
          _equipmentsDataMeta,
        ),
      );
    }
    if (data.containsKey('report_quantities_data')) {
      context.handle(
        _reportQuantitiesDataMeta,
        reportQuantitiesData.isAcceptableOrUnknown(
          data['report_quantities_data']!,
          _reportQuantitiesDataMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {uid},
  ];
  @override
  DailyReportRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return DailyReportRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      uid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      weatherCondition: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}weather_condition'],
      )!,
      workPerformed: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}work_performed'],
      )!,
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      ),
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      ),
      companyID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}company_i_d'],
      )!,
      contractRelationID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}contract_relation_i_d'],
      ),
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      approvedByID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}approved_by_i_d'],
      ),
      approvedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}approved_at'],
      ),
      rejectionReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}rejection_reason'],
      ),
      workScopeID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}work_scope_i_d'],
      )!,
      roadID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}road_i_d'],
      )!,
      totalWorkers: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_workers'],
      ),
      fromSection: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}from_section'],
      ),
      toSection: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}to_section'],
      ),
      createdByID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_by_i_d'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      workScopeData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}work_scope_data'],
      ),
      roadData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}road_data'],
      ),
      equipmentsData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}equipments_data'],
      ),
      reportQuantitiesData: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}report_quantities_data'],
      ),
    );
  }

  @override
  $DailyReportsTable createAlias(String alias) {
    return $DailyReportsTable(attachedDatabase, alias);
  }
}

class DailyReportRecord extends DataClass
    implements Insertable<DailyReportRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String uid;
  final String name;
  final String? notes;
  final String weatherCondition;
  final bool workPerformed;
  final double? longitude;
  final double? latitude;
  final int companyID;
  final int? contractRelationID;
  final String status;
  final int? approvedByID;
  final DateTime? approvedAt;
  final String? rejectionReason;
  final int workScopeID;
  final int roadID;
  final int? totalWorkers;
  final double? fromSection;
  final double? toSection;
  final int createdByID;
  final DateTime createdAt;
  final DateTime updatedAt;
  final String? workScopeData;
  final String? roadData;
  final String? equipmentsData;
  final String? reportQuantitiesData;
  const DailyReportRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.uid,
    required this.name,
    this.notes,
    required this.weatherCondition,
    required this.workPerformed,
    this.longitude,
    this.latitude,
    required this.companyID,
    this.contractRelationID,
    required this.status,
    this.approvedByID,
    this.approvedAt,
    this.rejectionReason,
    required this.workScopeID,
    required this.roadID,
    this.totalWorkers,
    this.fromSection,
    this.toSection,
    required this.createdByID,
    required this.createdAt,
    required this.updatedAt,
    this.workScopeData,
    this.roadData,
    this.equipmentsData,
    this.reportQuantitiesData,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['uid'] = Variable<String>(uid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['weather_condition'] = Variable<String>(weatherCondition);
    map['work_performed'] = Variable<bool>(workPerformed);
    if (!nullToAbsent || longitude != null) {
      map['longitude'] = Variable<double>(longitude);
    }
    if (!nullToAbsent || latitude != null) {
      map['latitude'] = Variable<double>(latitude);
    }
    map['company_i_d'] = Variable<int>(companyID);
    if (!nullToAbsent || contractRelationID != null) {
      map['contract_relation_i_d'] = Variable<int>(contractRelationID);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || approvedByID != null) {
      map['approved_by_i_d'] = Variable<int>(approvedByID);
    }
    if (!nullToAbsent || approvedAt != null) {
      map['approved_at'] = Variable<DateTime>(approvedAt);
    }
    if (!nullToAbsent || rejectionReason != null) {
      map['rejection_reason'] = Variable<String>(rejectionReason);
    }
    map['work_scope_i_d'] = Variable<int>(workScopeID);
    map['road_i_d'] = Variable<int>(roadID);
    if (!nullToAbsent || totalWorkers != null) {
      map['total_workers'] = Variable<int>(totalWorkers);
    }
    if (!nullToAbsent || fromSection != null) {
      map['from_section'] = Variable<double>(fromSection);
    }
    if (!nullToAbsent || toSection != null) {
      map['to_section'] = Variable<double>(toSection);
    }
    map['created_by_i_d'] = Variable<int>(createdByID);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    if (!nullToAbsent || workScopeData != null) {
      map['work_scope_data'] = Variable<String>(workScopeData);
    }
    if (!nullToAbsent || roadData != null) {
      map['road_data'] = Variable<String>(roadData);
    }
    if (!nullToAbsent || equipmentsData != null) {
      map['equipments_data'] = Variable<String>(equipmentsData);
    }
    if (!nullToAbsent || reportQuantitiesData != null) {
      map['report_quantities_data'] = Variable<String>(reportQuantitiesData);
    }
    return map;
  }

  DailyReportsCompanion toCompanion(bool nullToAbsent) {
    return DailyReportsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      uid: Value(uid),
      name: Value(name),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      weatherCondition: Value(weatherCondition),
      workPerformed: Value(workPerformed),
      longitude: longitude == null && nullToAbsent
          ? const Value.absent()
          : Value(longitude),
      latitude: latitude == null && nullToAbsent
          ? const Value.absent()
          : Value(latitude),
      companyID: Value(companyID),
      contractRelationID: contractRelationID == null && nullToAbsent
          ? const Value.absent()
          : Value(contractRelationID),
      status: Value(status),
      approvedByID: approvedByID == null && nullToAbsent
          ? const Value.absent()
          : Value(approvedByID),
      approvedAt: approvedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(approvedAt),
      rejectionReason: rejectionReason == null && nullToAbsent
          ? const Value.absent()
          : Value(rejectionReason),
      workScopeID: Value(workScopeID),
      roadID: Value(roadID),
      totalWorkers: totalWorkers == null && nullToAbsent
          ? const Value.absent()
          : Value(totalWorkers),
      fromSection: fromSection == null && nullToAbsent
          ? const Value.absent()
          : Value(fromSection),
      toSection: toSection == null && nullToAbsent
          ? const Value.absent()
          : Value(toSection),
      createdByID: Value(createdByID),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      workScopeData: workScopeData == null && nullToAbsent
          ? const Value.absent()
          : Value(workScopeData),
      roadData: roadData == null && nullToAbsent
          ? const Value.absent()
          : Value(roadData),
      equipmentsData: equipmentsData == null && nullToAbsent
          ? const Value.absent()
          : Value(equipmentsData),
      reportQuantitiesData: reportQuantitiesData == null && nullToAbsent
          ? const Value.absent()
          : Value(reportQuantitiesData),
    );
  }

  factory DailyReportRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return DailyReportRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      uid: serializer.fromJson<String>(json['uid']),
      name: serializer.fromJson<String>(json['name']),
      notes: serializer.fromJson<String?>(json['notes']),
      weatherCondition: serializer.fromJson<String>(json['weatherCondition']),
      workPerformed: serializer.fromJson<bool>(json['workPerformed']),
      longitude: serializer.fromJson<double?>(json['longitude']),
      latitude: serializer.fromJson<double?>(json['latitude']),
      companyID: serializer.fromJson<int>(json['companyID']),
      contractRelationID: serializer.fromJson<int?>(json['contractRelationID']),
      status: serializer.fromJson<String>(json['status']),
      approvedByID: serializer.fromJson<int?>(json['approvedByID']),
      approvedAt: serializer.fromJson<DateTime?>(json['approvedAt']),
      rejectionReason: serializer.fromJson<String?>(json['rejectionReason']),
      workScopeID: serializer.fromJson<int>(json['workScopeID']),
      roadID: serializer.fromJson<int>(json['roadID']),
      totalWorkers: serializer.fromJson<int?>(json['totalWorkers']),
      fromSection: serializer.fromJson<double?>(json['fromSection']),
      toSection: serializer.fromJson<double?>(json['toSection']),
      createdByID: serializer.fromJson<int>(json['createdByID']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      workScopeData: serializer.fromJson<String?>(json['workScopeData']),
      roadData: serializer.fromJson<String?>(json['roadData']),
      equipmentsData: serializer.fromJson<String?>(json['equipmentsData']),
      reportQuantitiesData: serializer.fromJson<String?>(
        json['reportQuantitiesData'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'uid': serializer.toJson<String>(uid),
      'name': serializer.toJson<String>(name),
      'notes': serializer.toJson<String?>(notes),
      'weatherCondition': serializer.toJson<String>(weatherCondition),
      'workPerformed': serializer.toJson<bool>(workPerformed),
      'longitude': serializer.toJson<double?>(longitude),
      'latitude': serializer.toJson<double?>(latitude),
      'companyID': serializer.toJson<int>(companyID),
      'contractRelationID': serializer.toJson<int?>(contractRelationID),
      'status': serializer.toJson<String>(status),
      'approvedByID': serializer.toJson<int?>(approvedByID),
      'approvedAt': serializer.toJson<DateTime?>(approvedAt),
      'rejectionReason': serializer.toJson<String?>(rejectionReason),
      'workScopeID': serializer.toJson<int>(workScopeID),
      'roadID': serializer.toJson<int>(roadID),
      'totalWorkers': serializer.toJson<int?>(totalWorkers),
      'fromSection': serializer.toJson<double?>(fromSection),
      'toSection': serializer.toJson<double?>(toSection),
      'createdByID': serializer.toJson<int>(createdByID),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'workScopeData': serializer.toJson<String?>(workScopeData),
      'roadData': serializer.toJson<String?>(roadData),
      'equipmentsData': serializer.toJson<String?>(equipmentsData),
      'reportQuantitiesData': serializer.toJson<String?>(reportQuantitiesData),
    };
  }

  DailyReportRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? uid,
    String? name,
    Value<String?> notes = const Value.absent(),
    String? weatherCondition,
    bool? workPerformed,
    Value<double?> longitude = const Value.absent(),
    Value<double?> latitude = const Value.absent(),
    int? companyID,
    Value<int?> contractRelationID = const Value.absent(),
    String? status,
    Value<int?> approvedByID = const Value.absent(),
    Value<DateTime?> approvedAt = const Value.absent(),
    Value<String?> rejectionReason = const Value.absent(),
    int? workScopeID,
    int? roadID,
    Value<int?> totalWorkers = const Value.absent(),
    Value<double?> fromSection = const Value.absent(),
    Value<double?> toSection = const Value.absent(),
    int? createdByID,
    DateTime? createdAt,
    DateTime? updatedAt,
    Value<String?> workScopeData = const Value.absent(),
    Value<String?> roadData = const Value.absent(),
    Value<String?> equipmentsData = const Value.absent(),
    Value<String?> reportQuantitiesData = const Value.absent(),
  }) => DailyReportRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    uid: uid ?? this.uid,
    name: name ?? this.name,
    notes: notes.present ? notes.value : this.notes,
    weatherCondition: weatherCondition ?? this.weatherCondition,
    workPerformed: workPerformed ?? this.workPerformed,
    longitude: longitude.present ? longitude.value : this.longitude,
    latitude: latitude.present ? latitude.value : this.latitude,
    companyID: companyID ?? this.companyID,
    contractRelationID: contractRelationID.present
        ? contractRelationID.value
        : this.contractRelationID,
    status: status ?? this.status,
    approvedByID: approvedByID.present ? approvedByID.value : this.approvedByID,
    approvedAt: approvedAt.present ? approvedAt.value : this.approvedAt,
    rejectionReason: rejectionReason.present
        ? rejectionReason.value
        : this.rejectionReason,
    workScopeID: workScopeID ?? this.workScopeID,
    roadID: roadID ?? this.roadID,
    totalWorkers: totalWorkers.present ? totalWorkers.value : this.totalWorkers,
    fromSection: fromSection.present ? fromSection.value : this.fromSection,
    toSection: toSection.present ? toSection.value : this.toSection,
    createdByID: createdByID ?? this.createdByID,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    workScopeData: workScopeData.present
        ? workScopeData.value
        : this.workScopeData,
    roadData: roadData.present ? roadData.value : this.roadData,
    equipmentsData: equipmentsData.present
        ? equipmentsData.value
        : this.equipmentsData,
    reportQuantitiesData: reportQuantitiesData.present
        ? reportQuantitiesData.value
        : this.reportQuantitiesData,
  );
  DailyReportRecord copyWithCompanion(DailyReportsCompanion data) {
    return DailyReportRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      uid: data.uid.present ? data.uid.value : this.uid,
      name: data.name.present ? data.name.value : this.name,
      notes: data.notes.present ? data.notes.value : this.notes,
      weatherCondition: data.weatherCondition.present
          ? data.weatherCondition.value
          : this.weatherCondition,
      workPerformed: data.workPerformed.present
          ? data.workPerformed.value
          : this.workPerformed,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      companyID: data.companyID.present ? data.companyID.value : this.companyID,
      contractRelationID: data.contractRelationID.present
          ? data.contractRelationID.value
          : this.contractRelationID,
      status: data.status.present ? data.status.value : this.status,
      approvedByID: data.approvedByID.present
          ? data.approvedByID.value
          : this.approvedByID,
      approvedAt: data.approvedAt.present
          ? data.approvedAt.value
          : this.approvedAt,
      rejectionReason: data.rejectionReason.present
          ? data.rejectionReason.value
          : this.rejectionReason,
      workScopeID: data.workScopeID.present
          ? data.workScopeID.value
          : this.workScopeID,
      roadID: data.roadID.present ? data.roadID.value : this.roadID,
      totalWorkers: data.totalWorkers.present
          ? data.totalWorkers.value
          : this.totalWorkers,
      fromSection: data.fromSection.present
          ? data.fromSection.value
          : this.fromSection,
      toSection: data.toSection.present ? data.toSection.value : this.toSection,
      createdByID: data.createdByID.present
          ? data.createdByID.value
          : this.createdByID,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      workScopeData: data.workScopeData.present
          ? data.workScopeData.value
          : this.workScopeData,
      roadData: data.roadData.present ? data.roadData.value : this.roadData,
      equipmentsData: data.equipmentsData.present
          ? data.equipmentsData.value
          : this.equipmentsData,
      reportQuantitiesData: data.reportQuantitiesData.present
          ? data.reportQuantitiesData.value
          : this.reportQuantitiesData,
    );
  }

  @override
  String toString() {
    return (StringBuffer('DailyReportRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('notes: $notes, ')
          ..write('weatherCondition: $weatherCondition, ')
          ..write('workPerformed: $workPerformed, ')
          ..write('longitude: $longitude, ')
          ..write('latitude: $latitude, ')
          ..write('companyID: $companyID, ')
          ..write('contractRelationID: $contractRelationID, ')
          ..write('status: $status, ')
          ..write('approvedByID: $approvedByID, ')
          ..write('approvedAt: $approvedAt, ')
          ..write('rejectionReason: $rejectionReason, ')
          ..write('workScopeID: $workScopeID, ')
          ..write('roadID: $roadID, ')
          ..write('totalWorkers: $totalWorkers, ')
          ..write('fromSection: $fromSection, ')
          ..write('toSection: $toSection, ')
          ..write('createdByID: $createdByID, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('workScopeData: $workScopeData, ')
          ..write('roadData: $roadData, ')
          ..write('equipmentsData: $equipmentsData, ')
          ..write('reportQuantitiesData: $reportQuantitiesData')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    uid,
    name,
    notes,
    weatherCondition,
    workPerformed,
    longitude,
    latitude,
    companyID,
    contractRelationID,
    status,
    approvedByID,
    approvedAt,
    rejectionReason,
    workScopeID,
    roadID,
    totalWorkers,
    fromSection,
    toSection,
    createdByID,
    createdAt,
    updatedAt,
    workScopeData,
    roadData,
    equipmentsData,
    reportQuantitiesData,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is DailyReportRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.uid == this.uid &&
          other.name == this.name &&
          other.notes == this.notes &&
          other.weatherCondition == this.weatherCondition &&
          other.workPerformed == this.workPerformed &&
          other.longitude == this.longitude &&
          other.latitude == this.latitude &&
          other.companyID == this.companyID &&
          other.contractRelationID == this.contractRelationID &&
          other.status == this.status &&
          other.approvedByID == this.approvedByID &&
          other.approvedAt == this.approvedAt &&
          other.rejectionReason == this.rejectionReason &&
          other.workScopeID == this.workScopeID &&
          other.roadID == this.roadID &&
          other.totalWorkers == this.totalWorkers &&
          other.fromSection == this.fromSection &&
          other.toSection == this.toSection &&
          other.createdByID == this.createdByID &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.workScopeData == this.workScopeData &&
          other.roadData == this.roadData &&
          other.equipmentsData == this.equipmentsData &&
          other.reportQuantitiesData == this.reportQuantitiesData);
}

class DailyReportsCompanion extends UpdateCompanion<DailyReportRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> uid;
  final Value<String> name;
  final Value<String?> notes;
  final Value<String> weatherCondition;
  final Value<bool> workPerformed;
  final Value<double?> longitude;
  final Value<double?> latitude;
  final Value<int> companyID;
  final Value<int?> contractRelationID;
  final Value<String> status;
  final Value<int?> approvedByID;
  final Value<DateTime?> approvedAt;
  final Value<String?> rejectionReason;
  final Value<int> workScopeID;
  final Value<int> roadID;
  final Value<int?> totalWorkers;
  final Value<double?> fromSection;
  final Value<double?> toSection;
  final Value<int> createdByID;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<String?> workScopeData;
  final Value<String?> roadData;
  final Value<String?> equipmentsData;
  final Value<String?> reportQuantitiesData;
  const DailyReportsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.uid = const Value.absent(),
    this.name = const Value.absent(),
    this.notes = const Value.absent(),
    this.weatherCondition = const Value.absent(),
    this.workPerformed = const Value.absent(),
    this.longitude = const Value.absent(),
    this.latitude = const Value.absent(),
    this.companyID = const Value.absent(),
    this.contractRelationID = const Value.absent(),
    this.status = const Value.absent(),
    this.approvedByID = const Value.absent(),
    this.approvedAt = const Value.absent(),
    this.rejectionReason = const Value.absent(),
    this.workScopeID = const Value.absent(),
    this.roadID = const Value.absent(),
    this.totalWorkers = const Value.absent(),
    this.fromSection = const Value.absent(),
    this.toSection = const Value.absent(),
    this.createdByID = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.workScopeData = const Value.absent(),
    this.roadData = const Value.absent(),
    this.equipmentsData = const Value.absent(),
    this.reportQuantitiesData = const Value.absent(),
  });
  DailyReportsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String uid,
    required String name,
    this.notes = const Value.absent(),
    required String weatherCondition,
    this.workPerformed = const Value.absent(),
    this.longitude = const Value.absent(),
    this.latitude = const Value.absent(),
    required int companyID,
    this.contractRelationID = const Value.absent(),
    this.status = const Value.absent(),
    this.approvedByID = const Value.absent(),
    this.approvedAt = const Value.absent(),
    this.rejectionReason = const Value.absent(),
    required int workScopeID,
    required int roadID,
    this.totalWorkers = const Value.absent(),
    this.fromSection = const Value.absent(),
    this.toSection = const Value.absent(),
    required int createdByID,
    required DateTime createdAt,
    required DateTime updatedAt,
    this.workScopeData = const Value.absent(),
    this.roadData = const Value.absent(),
    this.equipmentsData = const Value.absent(),
    this.reportQuantitiesData = const Value.absent(),
  }) : uid = Value(uid),
       name = Value(name),
       weatherCondition = Value(weatherCondition),
       companyID = Value(companyID),
       workScopeID = Value(workScopeID),
       roadID = Value(roadID),
       createdByID = Value(createdByID),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<DailyReportRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? uid,
    Expression<String>? name,
    Expression<String>? notes,
    Expression<String>? weatherCondition,
    Expression<bool>? workPerformed,
    Expression<double>? longitude,
    Expression<double>? latitude,
    Expression<int>? companyID,
    Expression<int>? contractRelationID,
    Expression<String>? status,
    Expression<int>? approvedByID,
    Expression<DateTime>? approvedAt,
    Expression<String>? rejectionReason,
    Expression<int>? workScopeID,
    Expression<int>? roadID,
    Expression<int>? totalWorkers,
    Expression<double>? fromSection,
    Expression<double>? toSection,
    Expression<int>? createdByID,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<String>? workScopeData,
    Expression<String>? roadData,
    Expression<String>? equipmentsData,
    Expression<String>? reportQuantitiesData,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (uid != null) 'uid': uid,
      if (name != null) 'name': name,
      if (notes != null) 'notes': notes,
      if (weatherCondition != null) 'weather_condition': weatherCondition,
      if (workPerformed != null) 'work_performed': workPerformed,
      if (longitude != null) 'longitude': longitude,
      if (latitude != null) 'latitude': latitude,
      if (companyID != null) 'company_i_d': companyID,
      if (contractRelationID != null)
        'contract_relation_i_d': contractRelationID,
      if (status != null) 'status': status,
      if (approvedByID != null) 'approved_by_i_d': approvedByID,
      if (approvedAt != null) 'approved_at': approvedAt,
      if (rejectionReason != null) 'rejection_reason': rejectionReason,
      if (workScopeID != null) 'work_scope_i_d': workScopeID,
      if (roadID != null) 'road_i_d': roadID,
      if (totalWorkers != null) 'total_workers': totalWorkers,
      if (fromSection != null) 'from_section': fromSection,
      if (toSection != null) 'to_section': toSection,
      if (createdByID != null) 'created_by_i_d': createdByID,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (workScopeData != null) 'work_scope_data': workScopeData,
      if (roadData != null) 'road_data': roadData,
      if (equipmentsData != null) 'equipments_data': equipmentsData,
      if (reportQuantitiesData != null)
        'report_quantities_data': reportQuantitiesData,
    });
  }

  DailyReportsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? uid,
    Value<String>? name,
    Value<String?>? notes,
    Value<String>? weatherCondition,
    Value<bool>? workPerformed,
    Value<double?>? longitude,
    Value<double?>? latitude,
    Value<int>? companyID,
    Value<int?>? contractRelationID,
    Value<String>? status,
    Value<int?>? approvedByID,
    Value<DateTime?>? approvedAt,
    Value<String?>? rejectionReason,
    Value<int>? workScopeID,
    Value<int>? roadID,
    Value<int?>? totalWorkers,
    Value<double?>? fromSection,
    Value<double?>? toSection,
    Value<int>? createdByID,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<String?>? workScopeData,
    Value<String?>? roadData,
    Value<String?>? equipmentsData,
    Value<String?>? reportQuantitiesData,
  }) {
    return DailyReportsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      uid: uid ?? this.uid,
      name: name ?? this.name,
      notes: notes ?? this.notes,
      weatherCondition: weatherCondition ?? this.weatherCondition,
      workPerformed: workPerformed ?? this.workPerformed,
      longitude: longitude ?? this.longitude,
      latitude: latitude ?? this.latitude,
      companyID: companyID ?? this.companyID,
      contractRelationID: contractRelationID ?? this.contractRelationID,
      status: status ?? this.status,
      approvedByID: approvedByID ?? this.approvedByID,
      approvedAt: approvedAt ?? this.approvedAt,
      rejectionReason: rejectionReason ?? this.rejectionReason,
      workScopeID: workScopeID ?? this.workScopeID,
      roadID: roadID ?? this.roadID,
      totalWorkers: totalWorkers ?? this.totalWorkers,
      fromSection: fromSection ?? this.fromSection,
      toSection: toSection ?? this.toSection,
      createdByID: createdByID ?? this.createdByID,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      workScopeData: workScopeData ?? this.workScopeData,
      roadData: roadData ?? this.roadData,
      equipmentsData: equipmentsData ?? this.equipmentsData,
      reportQuantitiesData: reportQuantitiesData ?? this.reportQuantitiesData,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uid.present) {
      map['uid'] = Variable<String>(uid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (weatherCondition.present) {
      map['weather_condition'] = Variable<String>(weatherCondition.value);
    }
    if (workPerformed.present) {
      map['work_performed'] = Variable<bool>(workPerformed.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (companyID.present) {
      map['company_i_d'] = Variable<int>(companyID.value);
    }
    if (contractRelationID.present) {
      map['contract_relation_i_d'] = Variable<int>(contractRelationID.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (approvedByID.present) {
      map['approved_by_i_d'] = Variable<int>(approvedByID.value);
    }
    if (approvedAt.present) {
      map['approved_at'] = Variable<DateTime>(approvedAt.value);
    }
    if (rejectionReason.present) {
      map['rejection_reason'] = Variable<String>(rejectionReason.value);
    }
    if (workScopeID.present) {
      map['work_scope_i_d'] = Variable<int>(workScopeID.value);
    }
    if (roadID.present) {
      map['road_i_d'] = Variable<int>(roadID.value);
    }
    if (totalWorkers.present) {
      map['total_workers'] = Variable<int>(totalWorkers.value);
    }
    if (fromSection.present) {
      map['from_section'] = Variable<double>(fromSection.value);
    }
    if (toSection.present) {
      map['to_section'] = Variable<double>(toSection.value);
    }
    if (createdByID.present) {
      map['created_by_i_d'] = Variable<int>(createdByID.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (workScopeData.present) {
      map['work_scope_data'] = Variable<String>(workScopeData.value);
    }
    if (roadData.present) {
      map['road_data'] = Variable<String>(roadData.value);
    }
    if (equipmentsData.present) {
      map['equipments_data'] = Variable<String>(equipmentsData.value);
    }
    if (reportQuantitiesData.present) {
      map['report_quantities_data'] = Variable<String>(
        reportQuantitiesData.value,
      );
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('DailyReportsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('uid: $uid, ')
          ..write('name: $name, ')
          ..write('notes: $notes, ')
          ..write('weatherCondition: $weatherCondition, ')
          ..write('workPerformed: $workPerformed, ')
          ..write('longitude: $longitude, ')
          ..write('latitude: $latitude, ')
          ..write('companyID: $companyID, ')
          ..write('contractRelationID: $contractRelationID, ')
          ..write('status: $status, ')
          ..write('approvedByID: $approvedByID, ')
          ..write('approvedAt: $approvedAt, ')
          ..write('rejectionReason: $rejectionReason, ')
          ..write('workScopeID: $workScopeID, ')
          ..write('roadID: $roadID, ')
          ..write('totalWorkers: $totalWorkers, ')
          ..write('fromSection: $fromSection, ')
          ..write('toSection: $toSection, ')
          ..write('createdByID: $createdByID, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('workScopeData: $workScopeData, ')
          ..write('roadData: $roadData, ')
          ..write('equipmentsData: $equipmentsData, ')
          ..write('reportQuantitiesData: $reportQuantitiesData')
          ..write(')'))
        .toString();
  }
}

class $ReportEquipmentsTable extends ReportEquipments
    with TableInfo<$ReportEquipmentsTable, ReportEquipmentRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReportEquipmentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _reportTypeMeta = const VerificationMeta(
    'reportType',
  );
  @override
  late final GeneratedColumn<String> reportType = GeneratedColumn<String>(
    'report_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dailyReportIDMeta = const VerificationMeta(
    'dailyReportID',
  );
  @override
  late final GeneratedColumn<int> dailyReportID = GeneratedColumn<int>(
    'daily_report_i_d',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _workEquipmentIDMeta = const VerificationMeta(
    'workEquipmentID',
  );
  @override
  late final GeneratedColumn<int> workEquipmentID = GeneratedColumn<int>(
    'work_equipment_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _addedByIDMeta = const VerificationMeta(
    'addedByID',
  );
  @override
  late final GeneratedColumn<int> addedByID = GeneratedColumn<int>(
    'added_by_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    reportType,
    dailyReportID,
    workEquipmentID,
    addedByID,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'report_equipments';
  @override
  VerificationContext validateIntegrity(
    Insertable<ReportEquipmentRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('report_type')) {
      context.handle(
        _reportTypeMeta,
        reportType.isAcceptableOrUnknown(data['report_type']!, _reportTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_reportTypeMeta);
    }
    if (data.containsKey('daily_report_i_d')) {
      context.handle(
        _dailyReportIDMeta,
        dailyReportID.isAcceptableOrUnknown(
          data['daily_report_i_d']!,
          _dailyReportIDMeta,
        ),
      );
    }
    if (data.containsKey('work_equipment_i_d')) {
      context.handle(
        _workEquipmentIDMeta,
        workEquipmentID.isAcceptableOrUnknown(
          data['work_equipment_i_d']!,
          _workEquipmentIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_workEquipmentIDMeta);
    }
    if (data.containsKey('added_by_i_d')) {
      context.handle(
        _addedByIDMeta,
        addedByID.isAcceptableOrUnknown(data['added_by_i_d']!, _addedByIDMeta),
      );
    } else if (isInserting) {
      context.missing(_addedByIDMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {dailyReportID, workEquipmentID},
  ];
  @override
  ReportEquipmentRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReportEquipmentRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      reportType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}report_type'],
      )!,
      dailyReportID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}daily_report_i_d'],
      ),
      workEquipmentID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}work_equipment_i_d'],
      )!,
      addedByID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}added_by_i_d'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ReportEquipmentsTable createAlias(String alias) {
    return $ReportEquipmentsTable(attachedDatabase, alias);
  }
}

class ReportEquipmentRecord extends DataClass
    implements Insertable<ReportEquipmentRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String reportType;
  final int? dailyReportID;
  final int workEquipmentID;
  final int addedByID;
  final DateTime createdAt;
  const ReportEquipmentRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.reportType,
    this.dailyReportID,
    required this.workEquipmentID,
    required this.addedByID,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['report_type'] = Variable<String>(reportType);
    if (!nullToAbsent || dailyReportID != null) {
      map['daily_report_i_d'] = Variable<int>(dailyReportID);
    }
    map['work_equipment_i_d'] = Variable<int>(workEquipmentID);
    map['added_by_i_d'] = Variable<int>(addedByID);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ReportEquipmentsCompanion toCompanion(bool nullToAbsent) {
    return ReportEquipmentsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      reportType: Value(reportType),
      dailyReportID: dailyReportID == null && nullToAbsent
          ? const Value.absent()
          : Value(dailyReportID),
      workEquipmentID: Value(workEquipmentID),
      addedByID: Value(addedByID),
      createdAt: Value(createdAt),
    );
  }

  factory ReportEquipmentRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReportEquipmentRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      reportType: serializer.fromJson<String>(json['reportType']),
      dailyReportID: serializer.fromJson<int?>(json['dailyReportID']),
      workEquipmentID: serializer.fromJson<int>(json['workEquipmentID']),
      addedByID: serializer.fromJson<int>(json['addedByID']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'reportType': serializer.toJson<String>(reportType),
      'dailyReportID': serializer.toJson<int?>(dailyReportID),
      'workEquipmentID': serializer.toJson<int>(workEquipmentID),
      'addedByID': serializer.toJson<int>(addedByID),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ReportEquipmentRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? reportType,
    Value<int?> dailyReportID = const Value.absent(),
    int? workEquipmentID,
    int? addedByID,
    DateTime? createdAt,
  }) => ReportEquipmentRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    reportType: reportType ?? this.reportType,
    dailyReportID: dailyReportID.present
        ? dailyReportID.value
        : this.dailyReportID,
    workEquipmentID: workEquipmentID ?? this.workEquipmentID,
    addedByID: addedByID ?? this.addedByID,
    createdAt: createdAt ?? this.createdAt,
  );
  ReportEquipmentRecord copyWithCompanion(ReportEquipmentsCompanion data) {
    return ReportEquipmentRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      reportType: data.reportType.present
          ? data.reportType.value
          : this.reportType,
      dailyReportID: data.dailyReportID.present
          ? data.dailyReportID.value
          : this.dailyReportID,
      workEquipmentID: data.workEquipmentID.present
          ? data.workEquipmentID.value
          : this.workEquipmentID,
      addedByID: data.addedByID.present ? data.addedByID.value : this.addedByID,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReportEquipmentRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('reportType: $reportType, ')
          ..write('dailyReportID: $dailyReportID, ')
          ..write('workEquipmentID: $workEquipmentID, ')
          ..write('addedByID: $addedByID, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    reportType,
    dailyReportID,
    workEquipmentID,
    addedByID,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReportEquipmentRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.reportType == this.reportType &&
          other.dailyReportID == this.dailyReportID &&
          other.workEquipmentID == this.workEquipmentID &&
          other.addedByID == this.addedByID &&
          other.createdAt == this.createdAt);
}

class ReportEquipmentsCompanion extends UpdateCompanion<ReportEquipmentRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> reportType;
  final Value<int?> dailyReportID;
  final Value<int> workEquipmentID;
  final Value<int> addedByID;
  final Value<DateTime> createdAt;
  const ReportEquipmentsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.reportType = const Value.absent(),
    this.dailyReportID = const Value.absent(),
    this.workEquipmentID = const Value.absent(),
    this.addedByID = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  ReportEquipmentsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String reportType,
    this.dailyReportID = const Value.absent(),
    required int workEquipmentID,
    required int addedByID,
    required DateTime createdAt,
  }) : reportType = Value(reportType),
       workEquipmentID = Value(workEquipmentID),
       addedByID = Value(addedByID),
       createdAt = Value(createdAt);
  static Insertable<ReportEquipmentRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? reportType,
    Expression<int>? dailyReportID,
    Expression<int>? workEquipmentID,
    Expression<int>? addedByID,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (reportType != null) 'report_type': reportType,
      if (dailyReportID != null) 'daily_report_i_d': dailyReportID,
      if (workEquipmentID != null) 'work_equipment_i_d': workEquipmentID,
      if (addedByID != null) 'added_by_i_d': addedByID,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  ReportEquipmentsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? reportType,
    Value<int?>? dailyReportID,
    Value<int>? workEquipmentID,
    Value<int>? addedByID,
    Value<DateTime>? createdAt,
  }) {
    return ReportEquipmentsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      reportType: reportType ?? this.reportType,
      dailyReportID: dailyReportID ?? this.dailyReportID,
      workEquipmentID: workEquipmentID ?? this.workEquipmentID,
      addedByID: addedByID ?? this.addedByID,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (reportType.present) {
      map['report_type'] = Variable<String>(reportType.value);
    }
    if (dailyReportID.present) {
      map['daily_report_i_d'] = Variable<int>(dailyReportID.value);
    }
    if (workEquipmentID.present) {
      map['work_equipment_i_d'] = Variable<int>(workEquipmentID.value);
    }
    if (addedByID.present) {
      map['added_by_i_d'] = Variable<int>(addedByID.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReportEquipmentsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('reportType: $reportType, ')
          ..write('dailyReportID: $dailyReportID, ')
          ..write('workEquipmentID: $workEquipmentID, ')
          ..write('addedByID: $addedByID, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $ReportQuantitiesTable extends ReportQuantities
    with TableInfo<$ReportQuantitiesTable, ReportQuantityRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReportQuantitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _reportTypeMeta = const VerificationMeta(
    'reportType',
  );
  @override
  late final GeneratedColumn<String> reportType = GeneratedColumn<String>(
    'report_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dailyReportIDMeta = const VerificationMeta(
    'dailyReportID',
  );
  @override
  late final GeneratedColumn<int> dailyReportID = GeneratedColumn<int>(
    'daily_report_i_d',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _quantityTypeIDMeta = const VerificationMeta(
    'quantityTypeID',
  );
  @override
  late final GeneratedColumn<int> quantityTypeID = GeneratedColumn<int>(
    'quantity_type_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sequenceNoMeta = const VerificationMeta(
    'sequenceNo',
  );
  @override
  late final GeneratedColumn<int> sequenceNo = GeneratedColumn<int>(
    'sequence_no',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _totalLengthMeta = const VerificationMeta(
    'totalLength',
  );
  @override
  late final GeneratedColumn<double> totalLength = GeneratedColumn<double>(
    'total_length',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    reportType,
    dailyReportID,
    quantityTypeID,
    sequenceNo,
    totalLength,
    notes,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'report_quantities';
  @override
  VerificationContext validateIntegrity(
    Insertable<ReportQuantityRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('report_type')) {
      context.handle(
        _reportTypeMeta,
        reportType.isAcceptableOrUnknown(data['report_type']!, _reportTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_reportTypeMeta);
    }
    if (data.containsKey('daily_report_i_d')) {
      context.handle(
        _dailyReportIDMeta,
        dailyReportID.isAcceptableOrUnknown(
          data['daily_report_i_d']!,
          _dailyReportIDMeta,
        ),
      );
    }
    if (data.containsKey('quantity_type_i_d')) {
      context.handle(
        _quantityTypeIDMeta,
        quantityTypeID.isAcceptableOrUnknown(
          data['quantity_type_i_d']!,
          _quantityTypeIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_quantityTypeIDMeta);
    }
    if (data.containsKey('sequence_no')) {
      context.handle(
        _sequenceNoMeta,
        sequenceNo.isAcceptableOrUnknown(data['sequence_no']!, _sequenceNoMeta),
      );
    }
    if (data.containsKey('total_length')) {
      context.handle(
        _totalLengthMeta,
        totalLength.isAcceptableOrUnknown(
          data['total_length']!,
          _totalLengthMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {dailyReportID, quantityTypeID, sequenceNo},
  ];
  @override
  ReportQuantityRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReportQuantityRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      reportType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}report_type'],
      )!,
      dailyReportID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}daily_report_i_d'],
      ),
      quantityTypeID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity_type_i_d'],
      )!,
      sequenceNo: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sequence_no'],
      )!,
      totalLength: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}total_length'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ReportQuantitiesTable createAlias(String alias) {
    return $ReportQuantitiesTable(attachedDatabase, alias);
  }
}

class ReportQuantityRecord extends DataClass
    implements Insertable<ReportQuantityRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final String reportType;
  final int? dailyReportID;
  final int quantityTypeID;
  final int sequenceNo;
  final double? totalLength;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ReportQuantityRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.reportType,
    this.dailyReportID,
    required this.quantityTypeID,
    required this.sequenceNo,
    this.totalLength,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['report_type'] = Variable<String>(reportType);
    if (!nullToAbsent || dailyReportID != null) {
      map['daily_report_i_d'] = Variable<int>(dailyReportID);
    }
    map['quantity_type_i_d'] = Variable<int>(quantityTypeID);
    map['sequence_no'] = Variable<int>(sequenceNo);
    if (!nullToAbsent || totalLength != null) {
      map['total_length'] = Variable<double>(totalLength);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ReportQuantitiesCompanion toCompanion(bool nullToAbsent) {
    return ReportQuantitiesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      reportType: Value(reportType),
      dailyReportID: dailyReportID == null && nullToAbsent
          ? const Value.absent()
          : Value(dailyReportID),
      quantityTypeID: Value(quantityTypeID),
      sequenceNo: Value(sequenceNo),
      totalLength: totalLength == null && nullToAbsent
          ? const Value.absent()
          : Value(totalLength),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ReportQuantityRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReportQuantityRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      reportType: serializer.fromJson<String>(json['reportType']),
      dailyReportID: serializer.fromJson<int?>(json['dailyReportID']),
      quantityTypeID: serializer.fromJson<int>(json['quantityTypeID']),
      sequenceNo: serializer.fromJson<int>(json['sequenceNo']),
      totalLength: serializer.fromJson<double?>(json['totalLength']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'reportType': serializer.toJson<String>(reportType),
      'dailyReportID': serializer.toJson<int?>(dailyReportID),
      'quantityTypeID': serializer.toJson<int>(quantityTypeID),
      'sequenceNo': serializer.toJson<int>(sequenceNo),
      'totalLength': serializer.toJson<double?>(totalLength),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ReportQuantityRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    String? reportType,
    Value<int?> dailyReportID = const Value.absent(),
    int? quantityTypeID,
    int? sequenceNo,
    Value<double?> totalLength = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ReportQuantityRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    reportType: reportType ?? this.reportType,
    dailyReportID: dailyReportID.present
        ? dailyReportID.value
        : this.dailyReportID,
    quantityTypeID: quantityTypeID ?? this.quantityTypeID,
    sequenceNo: sequenceNo ?? this.sequenceNo,
    totalLength: totalLength.present ? totalLength.value : this.totalLength,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ReportQuantityRecord copyWithCompanion(ReportQuantitiesCompanion data) {
    return ReportQuantityRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      reportType: data.reportType.present
          ? data.reportType.value
          : this.reportType,
      dailyReportID: data.dailyReportID.present
          ? data.dailyReportID.value
          : this.dailyReportID,
      quantityTypeID: data.quantityTypeID.present
          ? data.quantityTypeID.value
          : this.quantityTypeID,
      sequenceNo: data.sequenceNo.present
          ? data.sequenceNo.value
          : this.sequenceNo,
      totalLength: data.totalLength.present
          ? data.totalLength.value
          : this.totalLength,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReportQuantityRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('reportType: $reportType, ')
          ..write('dailyReportID: $dailyReportID, ')
          ..write('quantityTypeID: $quantityTypeID, ')
          ..write('sequenceNo: $sequenceNo, ')
          ..write('totalLength: $totalLength, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    reportType,
    dailyReportID,
    quantityTypeID,
    sequenceNo,
    totalLength,
    notes,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReportQuantityRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.reportType == this.reportType &&
          other.dailyReportID == this.dailyReportID &&
          other.quantityTypeID == this.quantityTypeID &&
          other.sequenceNo == this.sequenceNo &&
          other.totalLength == this.totalLength &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ReportQuantitiesCompanion extends UpdateCompanion<ReportQuantityRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<String> reportType;
  final Value<int?> dailyReportID;
  final Value<int> quantityTypeID;
  final Value<int> sequenceNo;
  final Value<double?> totalLength;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ReportQuantitiesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.reportType = const Value.absent(),
    this.dailyReportID = const Value.absent(),
    this.quantityTypeID = const Value.absent(),
    this.sequenceNo = const Value.absent(),
    this.totalLength = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ReportQuantitiesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required String reportType,
    this.dailyReportID = const Value.absent(),
    required int quantityTypeID,
    this.sequenceNo = const Value.absent(),
    this.totalLength = const Value.absent(),
    this.notes = const Value.absent(),
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : reportType = Value(reportType),
       quantityTypeID = Value(quantityTypeID),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ReportQuantityRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<String>? reportType,
    Expression<int>? dailyReportID,
    Expression<int>? quantityTypeID,
    Expression<int>? sequenceNo,
    Expression<double>? totalLength,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (reportType != null) 'report_type': reportType,
      if (dailyReportID != null) 'daily_report_i_d': dailyReportID,
      if (quantityTypeID != null) 'quantity_type_i_d': quantityTypeID,
      if (sequenceNo != null) 'sequence_no': sequenceNo,
      if (totalLength != null) 'total_length': totalLength,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ReportQuantitiesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<String>? reportType,
    Value<int?>? dailyReportID,
    Value<int>? quantityTypeID,
    Value<int>? sequenceNo,
    Value<double?>? totalLength,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return ReportQuantitiesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      reportType: reportType ?? this.reportType,
      dailyReportID: dailyReportID ?? this.dailyReportID,
      quantityTypeID: quantityTypeID ?? this.quantityTypeID,
      sequenceNo: sequenceNo ?? this.sequenceNo,
      totalLength: totalLength ?? this.totalLength,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (reportType.present) {
      map['report_type'] = Variable<String>(reportType.value);
    }
    if (dailyReportID.present) {
      map['daily_report_i_d'] = Variable<int>(dailyReportID.value);
    }
    if (quantityTypeID.present) {
      map['quantity_type_i_d'] = Variable<int>(quantityTypeID.value);
    }
    if (sequenceNo.present) {
      map['sequence_no'] = Variable<int>(sequenceNo.value);
    }
    if (totalLength.present) {
      map['total_length'] = Variable<double>(totalLength.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReportQuantitiesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('reportType: $reportType, ')
          ..write('dailyReportID: $dailyReportID, ')
          ..write('quantityTypeID: $quantityTypeID, ')
          ..write('sequenceNo: $sequenceNo, ')
          ..write('totalLength: $totalLength, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ReportQuantityValuesTable extends ReportQuantityValues
    with TableInfo<$ReportQuantityValuesTable, ReportQuantityValueRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReportQuantityValuesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _reportQuantityIDMeta = const VerificationMeta(
    'reportQuantityID',
  );
  @override
  late final GeneratedColumn<int> reportQuantityID = GeneratedColumn<int>(
    'report_quantity_i_d',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _segmentIDMeta = const VerificationMeta(
    'segmentID',
  );
  @override
  late final GeneratedColumn<int> segmentID = GeneratedColumn<int>(
    'segment_i_d',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _quantityFieldIDMeta = const VerificationMeta(
    'quantityFieldID',
  );
  @override
  late final GeneratedColumn<int> quantityFieldID = GeneratedColumn<int>(
    'quantity_field_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<String> value = GeneratedColumn<String>(
    'value',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    reportQuantityID,
    segmentID,
    quantityFieldID,
    value,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'report_quantity_values';
  @override
  VerificationContext validateIntegrity(
    Insertable<ReportQuantityValueRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('report_quantity_i_d')) {
      context.handle(
        _reportQuantityIDMeta,
        reportQuantityID.isAcceptableOrUnknown(
          data['report_quantity_i_d']!,
          _reportQuantityIDMeta,
        ),
      );
    }
    if (data.containsKey('segment_i_d')) {
      context.handle(
        _segmentIDMeta,
        segmentID.isAcceptableOrUnknown(data['segment_i_d']!, _segmentIDMeta),
      );
    }
    if (data.containsKey('quantity_field_i_d')) {
      context.handle(
        _quantityFieldIDMeta,
        quantityFieldID.isAcceptableOrUnknown(
          data['quantity_field_i_d']!,
          _quantityFieldIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_quantityFieldIDMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
        _valueMeta,
        value.isAcceptableOrUnknown(data['value']!, _valueMeta),
      );
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {reportQuantityID, quantityFieldID},
    {segmentID, quantityFieldID},
  ];
  @override
  ReportQuantityValueRecord map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReportQuantityValueRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      reportQuantityID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}report_quantity_i_d'],
      ),
      segmentID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}segment_i_d'],
      ),
      quantityFieldID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity_field_i_d'],
      )!,
      value: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}value'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ReportQuantityValuesTable createAlias(String alias) {
    return $ReportQuantityValuesTable(attachedDatabase, alias);
  }
}

class ReportQuantityValueRecord extends DataClass
    implements Insertable<ReportQuantityValueRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final int? reportQuantityID;
  final int? segmentID;
  final int quantityFieldID;
  final String value;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ReportQuantityValueRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    this.reportQuantityID,
    this.segmentID,
    required this.quantityFieldID,
    required this.value,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    if (!nullToAbsent || reportQuantityID != null) {
      map['report_quantity_i_d'] = Variable<int>(reportQuantityID);
    }
    if (!nullToAbsent || segmentID != null) {
      map['segment_i_d'] = Variable<int>(segmentID);
    }
    map['quantity_field_i_d'] = Variable<int>(quantityFieldID);
    map['value'] = Variable<String>(value);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ReportQuantityValuesCompanion toCompanion(bool nullToAbsent) {
    return ReportQuantityValuesCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      reportQuantityID: reportQuantityID == null && nullToAbsent
          ? const Value.absent()
          : Value(reportQuantityID),
      segmentID: segmentID == null && nullToAbsent
          ? const Value.absent()
          : Value(segmentID),
      quantityFieldID: Value(quantityFieldID),
      value: Value(value),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ReportQuantityValueRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReportQuantityValueRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      reportQuantityID: serializer.fromJson<int?>(json['reportQuantityID']),
      segmentID: serializer.fromJson<int?>(json['segmentID']),
      quantityFieldID: serializer.fromJson<int>(json['quantityFieldID']),
      value: serializer.fromJson<String>(json['value']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'reportQuantityID': serializer.toJson<int?>(reportQuantityID),
      'segmentID': serializer.toJson<int?>(segmentID),
      'quantityFieldID': serializer.toJson<int>(quantityFieldID),
      'value': serializer.toJson<String>(value),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ReportQuantityValueRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    Value<int?> reportQuantityID = const Value.absent(),
    Value<int?> segmentID = const Value.absent(),
    int? quantityFieldID,
    String? value,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ReportQuantityValueRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    reportQuantityID: reportQuantityID.present
        ? reportQuantityID.value
        : this.reportQuantityID,
    segmentID: segmentID.present ? segmentID.value : this.segmentID,
    quantityFieldID: quantityFieldID ?? this.quantityFieldID,
    value: value ?? this.value,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ReportQuantityValueRecord copyWithCompanion(
    ReportQuantityValuesCompanion data,
  ) {
    return ReportQuantityValueRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      reportQuantityID: data.reportQuantityID.present
          ? data.reportQuantityID.value
          : this.reportQuantityID,
      segmentID: data.segmentID.present ? data.segmentID.value : this.segmentID,
      quantityFieldID: data.quantityFieldID.present
          ? data.quantityFieldID.value
          : this.quantityFieldID,
      value: data.value.present ? data.value.value : this.value,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReportQuantityValueRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('reportQuantityID: $reportQuantityID, ')
          ..write('segmentID: $segmentID, ')
          ..write('quantityFieldID: $quantityFieldID, ')
          ..write('value: $value, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    reportQuantityID,
    segmentID,
    quantityFieldID,
    value,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReportQuantityValueRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.reportQuantityID == this.reportQuantityID &&
          other.segmentID == this.segmentID &&
          other.quantityFieldID == this.quantityFieldID &&
          other.value == this.value &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ReportQuantityValuesCompanion
    extends UpdateCompanion<ReportQuantityValueRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<int?> reportQuantityID;
  final Value<int?> segmentID;
  final Value<int> quantityFieldID;
  final Value<String> value;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ReportQuantityValuesCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.reportQuantityID = const Value.absent(),
    this.segmentID = const Value.absent(),
    this.quantityFieldID = const Value.absent(),
    this.value = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ReportQuantityValuesCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.reportQuantityID = const Value.absent(),
    this.segmentID = const Value.absent(),
    required int quantityFieldID,
    required String value,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : quantityFieldID = Value(quantityFieldID),
       value = Value(value),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ReportQuantityValueRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<int>? reportQuantityID,
    Expression<int>? segmentID,
    Expression<int>? quantityFieldID,
    Expression<String>? value,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (reportQuantityID != null) 'report_quantity_i_d': reportQuantityID,
      if (segmentID != null) 'segment_i_d': segmentID,
      if (quantityFieldID != null) 'quantity_field_i_d': quantityFieldID,
      if (value != null) 'value': value,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ReportQuantityValuesCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<int?>? reportQuantityID,
    Value<int?>? segmentID,
    Value<int>? quantityFieldID,
    Value<String>? value,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return ReportQuantityValuesCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      reportQuantityID: reportQuantityID ?? this.reportQuantityID,
      segmentID: segmentID ?? this.segmentID,
      quantityFieldID: quantityFieldID ?? this.quantityFieldID,
      value: value ?? this.value,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (reportQuantityID.present) {
      map['report_quantity_i_d'] = Variable<int>(reportQuantityID.value);
    }
    if (segmentID.present) {
      map['segment_i_d'] = Variable<int>(segmentID.value);
    }
    if (quantityFieldID.present) {
      map['quantity_field_i_d'] = Variable<int>(quantityFieldID.value);
    }
    if (value.present) {
      map['value'] = Variable<String>(value.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReportQuantityValuesCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('reportQuantityID: $reportQuantityID, ')
          ..write('segmentID: $segmentID, ')
          ..write('quantityFieldID: $quantityFieldID, ')
          ..write('value: $value, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ReportSegmentsTable extends ReportSegments
    with TableInfo<$ReportSegmentsTable, ReportSegmentRecord> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReportSegmentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _deletedAtMeta = const VerificationMeta(
    'deletedAt',
  );
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
    'deleted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncActionMeta = const VerificationMeta(
    'syncAction',
  );
  @override
  late final GeneratedColumn<String> syncAction = GeneratedColumn<String>(
    'sync_action',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncRetryCountMeta = const VerificationMeta(
    'syncRetryCount',
  );
  @override
  late final GeneratedColumn<int> syncRetryCount = GeneratedColumn<int>(
    'sync_retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncErrorMeta = const VerificationMeta(
    'syncError',
  );
  @override
  late final GeneratedColumn<String> syncError = GeneratedColumn<String>(
    'sync_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastSyncAttemptMeta = const VerificationMeta(
    'lastSyncAttempt',
  );
  @override
  late final GeneratedColumn<DateTime> lastSyncAttempt =
      GeneratedColumn<DateTime>(
        'last_sync_attempt',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _reportQuantityIDMeta = const VerificationMeta(
    'reportQuantityID',
  );
  @override
  late final GeneratedColumn<int> reportQuantityID = GeneratedColumn<int>(
    'report_quantity_i_d',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _segmentNumberMeta = const VerificationMeta(
    'segmentNumber',
  );
  @override
  late final GeneratedColumn<int> segmentNumber = GeneratedColumn<int>(
    'segment_number',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _startDistanceMeta = const VerificationMeta(
    'startDistance',
  );
  @override
  late final GeneratedColumn<double> startDistance = GeneratedColumn<double>(
    'start_distance',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endDistanceMeta = const VerificationMeta(
    'endDistance',
  );
  @override
  late final GeneratedColumn<double> endDistance = GeneratedColumn<double>(
    'end_distance',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    reportQuantityID,
    segmentNumber,
    startDistance,
    endDistance,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'report_segments';
  @override
  VerificationContext validateIntegrity(
    Insertable<ReportSegmentRecord> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    if (data.containsKey('deleted_at')) {
      context.handle(
        _deletedAtMeta,
        deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta),
      );
    }
    if (data.containsKey('sync_action')) {
      context.handle(
        _syncActionMeta,
        syncAction.isAcceptableOrUnknown(data['sync_action']!, _syncActionMeta),
      );
    }
    if (data.containsKey('sync_retry_count')) {
      context.handle(
        _syncRetryCountMeta,
        syncRetryCount.isAcceptableOrUnknown(
          data['sync_retry_count']!,
          _syncRetryCountMeta,
        ),
      );
    }
    if (data.containsKey('sync_error')) {
      context.handle(
        _syncErrorMeta,
        syncError.isAcceptableOrUnknown(data['sync_error']!, _syncErrorMeta),
      );
    }
    if (data.containsKey('last_sync_attempt')) {
      context.handle(
        _lastSyncAttemptMeta,
        lastSyncAttempt.isAcceptableOrUnknown(
          data['last_sync_attempt']!,
          _lastSyncAttemptMeta,
        ),
      );
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('report_quantity_i_d')) {
      context.handle(
        _reportQuantityIDMeta,
        reportQuantityID.isAcceptableOrUnknown(
          data['report_quantity_i_d']!,
          _reportQuantityIDMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_reportQuantityIDMeta);
    }
    if (data.containsKey('segment_number')) {
      context.handle(
        _segmentNumberMeta,
        segmentNumber.isAcceptableOrUnknown(
          data['segment_number']!,
          _segmentNumberMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_segmentNumberMeta);
    }
    if (data.containsKey('start_distance')) {
      context.handle(
        _startDistanceMeta,
        startDistance.isAcceptableOrUnknown(
          data['start_distance']!,
          _startDistanceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_startDistanceMeta);
    }
    if (data.containsKey('end_distance')) {
      context.handle(
        _endDistanceMeta,
        endDistance.isAcceptableOrUnknown(
          data['end_distance']!,
          _endDistanceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_endDistanceMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
    {reportQuantityID, segmentNumber},
  ];
  @override
  ReportSegmentRecord map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReportSegmentRecord(
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
      deletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deleted_at'],
      ),
      syncAction: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_action'],
      ),
      syncRetryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}sync_retry_count'],
      )!,
      syncError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_error'],
      ),
      lastSyncAttempt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_attempt'],
      ),
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      reportQuantityID: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}report_quantity_i_d'],
      )!,
      segmentNumber: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}segment_number'],
      )!,
      startDistance: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}start_distance'],
      )!,
      endDistance: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}end_distance'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ReportSegmentsTable createAlias(String alias) {
    return $ReportSegmentsTable(attachedDatabase, alias);
  }
}

class ReportSegmentRecord extends DataClass
    implements Insertable<ReportSegmentRecord> {
  final bool isSynced;
  final DateTime? deletedAt;
  final String? syncAction;
  final int syncRetryCount;
  final String? syncError;
  final DateTime? lastSyncAttempt;
  final int id;
  final int reportQuantityID;
  final int segmentNumber;
  final double startDistance;
  final double endDistance;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ReportSegmentRecord({
    required this.isSynced,
    this.deletedAt,
    this.syncAction,
    required this.syncRetryCount,
    this.syncError,
    this.lastSyncAttempt,
    required this.id,
    required this.reportQuantityID,
    required this.segmentNumber,
    required this.startDistance,
    required this.endDistance,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['is_synced'] = Variable<bool>(isSynced);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncAction != null) {
      map['sync_action'] = Variable<String>(syncAction);
    }
    map['sync_retry_count'] = Variable<int>(syncRetryCount);
    if (!nullToAbsent || syncError != null) {
      map['sync_error'] = Variable<String>(syncError);
    }
    if (!nullToAbsent || lastSyncAttempt != null) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt);
    }
    map['id'] = Variable<int>(id);
    map['report_quantity_i_d'] = Variable<int>(reportQuantityID);
    map['segment_number'] = Variable<int>(segmentNumber);
    map['start_distance'] = Variable<double>(startDistance);
    map['end_distance'] = Variable<double>(endDistance);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ReportSegmentsCompanion toCompanion(bool nullToAbsent) {
    return ReportSegmentsCompanion(
      isSynced: Value(isSynced),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncAction: syncAction == null && nullToAbsent
          ? const Value.absent()
          : Value(syncAction),
      syncRetryCount: Value(syncRetryCount),
      syncError: syncError == null && nullToAbsent
          ? const Value.absent()
          : Value(syncError),
      lastSyncAttempt: lastSyncAttempt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncAttempt),
      id: Value(id),
      reportQuantityID: Value(reportQuantityID),
      segmentNumber: Value(segmentNumber),
      startDistance: Value(startDistance),
      endDistance: Value(endDistance),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ReportSegmentRecord.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReportSegmentRecord(
      isSynced: serializer.fromJson<bool>(json['isSynced']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncAction: serializer.fromJson<String?>(json['syncAction']),
      syncRetryCount: serializer.fromJson<int>(json['syncRetryCount']),
      syncError: serializer.fromJson<String?>(json['syncError']),
      lastSyncAttempt: serializer.fromJson<DateTime?>(json['lastSyncAttempt']),
      id: serializer.fromJson<int>(json['id']),
      reportQuantityID: serializer.fromJson<int>(json['reportQuantityID']),
      segmentNumber: serializer.fromJson<int>(json['segmentNumber']),
      startDistance: serializer.fromJson<double>(json['startDistance']),
      endDistance: serializer.fromJson<double>(json['endDistance']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isSynced': serializer.toJson<bool>(isSynced),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncAction': serializer.toJson<String?>(syncAction),
      'syncRetryCount': serializer.toJson<int>(syncRetryCount),
      'syncError': serializer.toJson<String?>(syncError),
      'lastSyncAttempt': serializer.toJson<DateTime?>(lastSyncAttempt),
      'id': serializer.toJson<int>(id),
      'reportQuantityID': serializer.toJson<int>(reportQuantityID),
      'segmentNumber': serializer.toJson<int>(segmentNumber),
      'startDistance': serializer.toJson<double>(startDistance),
      'endDistance': serializer.toJson<double>(endDistance),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ReportSegmentRecord copyWith({
    bool? isSynced,
    Value<DateTime?> deletedAt = const Value.absent(),
    Value<String?> syncAction = const Value.absent(),
    int? syncRetryCount,
    Value<String?> syncError = const Value.absent(),
    Value<DateTime?> lastSyncAttempt = const Value.absent(),
    int? id,
    int? reportQuantityID,
    int? segmentNumber,
    double? startDistance,
    double? endDistance,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => ReportSegmentRecord(
    isSynced: isSynced ?? this.isSynced,
    deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
    syncAction: syncAction.present ? syncAction.value : this.syncAction,
    syncRetryCount: syncRetryCount ?? this.syncRetryCount,
    syncError: syncError.present ? syncError.value : this.syncError,
    lastSyncAttempt: lastSyncAttempt.present
        ? lastSyncAttempt.value
        : this.lastSyncAttempt,
    id: id ?? this.id,
    reportQuantityID: reportQuantityID ?? this.reportQuantityID,
    segmentNumber: segmentNumber ?? this.segmentNumber,
    startDistance: startDistance ?? this.startDistance,
    endDistance: endDistance ?? this.endDistance,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ReportSegmentRecord copyWithCompanion(ReportSegmentsCompanion data) {
    return ReportSegmentRecord(
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncAction: data.syncAction.present
          ? data.syncAction.value
          : this.syncAction,
      syncRetryCount: data.syncRetryCount.present
          ? data.syncRetryCount.value
          : this.syncRetryCount,
      syncError: data.syncError.present ? data.syncError.value : this.syncError,
      lastSyncAttempt: data.lastSyncAttempt.present
          ? data.lastSyncAttempt.value
          : this.lastSyncAttempt,
      id: data.id.present ? data.id.value : this.id,
      reportQuantityID: data.reportQuantityID.present
          ? data.reportQuantityID.value
          : this.reportQuantityID,
      segmentNumber: data.segmentNumber.present
          ? data.segmentNumber.value
          : this.segmentNumber,
      startDistance: data.startDistance.present
          ? data.startDistance.value
          : this.startDistance,
      endDistance: data.endDistance.present
          ? data.endDistance.value
          : this.endDistance,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReportSegmentRecord(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('reportQuantityID: $reportQuantityID, ')
          ..write('segmentNumber: $segmentNumber, ')
          ..write('startDistance: $startDistance, ')
          ..write('endDistance: $endDistance, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    isSynced,
    deletedAt,
    syncAction,
    syncRetryCount,
    syncError,
    lastSyncAttempt,
    id,
    reportQuantityID,
    segmentNumber,
    startDistance,
    endDistance,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReportSegmentRecord &&
          other.isSynced == this.isSynced &&
          other.deletedAt == this.deletedAt &&
          other.syncAction == this.syncAction &&
          other.syncRetryCount == this.syncRetryCount &&
          other.syncError == this.syncError &&
          other.lastSyncAttempt == this.lastSyncAttempt &&
          other.id == this.id &&
          other.reportQuantityID == this.reportQuantityID &&
          other.segmentNumber == this.segmentNumber &&
          other.startDistance == this.startDistance &&
          other.endDistance == this.endDistance &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ReportSegmentsCompanion extends UpdateCompanion<ReportSegmentRecord> {
  final Value<bool> isSynced;
  final Value<DateTime?> deletedAt;
  final Value<String?> syncAction;
  final Value<int> syncRetryCount;
  final Value<String?> syncError;
  final Value<DateTime?> lastSyncAttempt;
  final Value<int> id;
  final Value<int> reportQuantityID;
  final Value<int> segmentNumber;
  final Value<double> startDistance;
  final Value<double> endDistance;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ReportSegmentsCompanion({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    this.reportQuantityID = const Value.absent(),
    this.segmentNumber = const Value.absent(),
    this.startDistance = const Value.absent(),
    this.endDistance = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ReportSegmentsCompanion.insert({
    this.isSynced = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncAction = const Value.absent(),
    this.syncRetryCount = const Value.absent(),
    this.syncError = const Value.absent(),
    this.lastSyncAttempt = const Value.absent(),
    this.id = const Value.absent(),
    required int reportQuantityID,
    required int segmentNumber,
    required double startDistance,
    required double endDistance,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : reportQuantityID = Value(reportQuantityID),
       segmentNumber = Value(segmentNumber),
       startDistance = Value(startDistance),
       endDistance = Value(endDistance),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ReportSegmentRecord> custom({
    Expression<bool>? isSynced,
    Expression<DateTime>? deletedAt,
    Expression<String>? syncAction,
    Expression<int>? syncRetryCount,
    Expression<String>? syncError,
    Expression<DateTime>? lastSyncAttempt,
    Expression<int>? id,
    Expression<int>? reportQuantityID,
    Expression<int>? segmentNumber,
    Expression<double>? startDistance,
    Expression<double>? endDistance,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (isSynced != null) 'is_synced': isSynced,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncAction != null) 'sync_action': syncAction,
      if (syncRetryCount != null) 'sync_retry_count': syncRetryCount,
      if (syncError != null) 'sync_error': syncError,
      if (lastSyncAttempt != null) 'last_sync_attempt': lastSyncAttempt,
      if (id != null) 'id': id,
      if (reportQuantityID != null) 'report_quantity_i_d': reportQuantityID,
      if (segmentNumber != null) 'segment_number': segmentNumber,
      if (startDistance != null) 'start_distance': startDistance,
      if (endDistance != null) 'end_distance': endDistance,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ReportSegmentsCompanion copyWith({
    Value<bool>? isSynced,
    Value<DateTime?>? deletedAt,
    Value<String?>? syncAction,
    Value<int>? syncRetryCount,
    Value<String?>? syncError,
    Value<DateTime?>? lastSyncAttempt,
    Value<int>? id,
    Value<int>? reportQuantityID,
    Value<int>? segmentNumber,
    Value<double>? startDistance,
    Value<double>? endDistance,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
  }) {
    return ReportSegmentsCompanion(
      isSynced: isSynced ?? this.isSynced,
      deletedAt: deletedAt ?? this.deletedAt,
      syncAction: syncAction ?? this.syncAction,
      syncRetryCount: syncRetryCount ?? this.syncRetryCount,
      syncError: syncError ?? this.syncError,
      lastSyncAttempt: lastSyncAttempt ?? this.lastSyncAttempt,
      id: id ?? this.id,
      reportQuantityID: reportQuantityID ?? this.reportQuantityID,
      segmentNumber: segmentNumber ?? this.segmentNumber,
      startDistance: startDistance ?? this.startDistance,
      endDistance: endDistance ?? this.endDistance,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncAction.present) {
      map['sync_action'] = Variable<String>(syncAction.value);
    }
    if (syncRetryCount.present) {
      map['sync_retry_count'] = Variable<int>(syncRetryCount.value);
    }
    if (syncError.present) {
      map['sync_error'] = Variable<String>(syncError.value);
    }
    if (lastSyncAttempt.present) {
      map['last_sync_attempt'] = Variable<DateTime>(lastSyncAttempt.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (reportQuantityID.present) {
      map['report_quantity_i_d'] = Variable<int>(reportQuantityID.value);
    }
    if (segmentNumber.present) {
      map['segment_number'] = Variable<int>(segmentNumber.value);
    }
    if (startDistance.present) {
      map['start_distance'] = Variable<double>(startDistance.value);
    }
    if (endDistance.present) {
      map['end_distance'] = Variable<double>(endDistance.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReportSegmentsCompanion(')
          ..write('isSynced: $isSynced, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncAction: $syncAction, ')
          ..write('syncRetryCount: $syncRetryCount, ')
          ..write('syncError: $syncError, ')
          ..write('lastSyncAttempt: $lastSyncAttempt, ')
          ..write('id: $id, ')
          ..write('reportQuantityID: $reportQuantityID, ')
          ..write('segmentNumber: $segmentNumber, ')
          ..write('startDistance: $startDistance, ')
          ..write('endDistance: $endDistance, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  _$AppDatabase.connect(DatabaseConnection c) : super.connect(c);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $AdminsTable admins = $AdminsTable(this);
  late final $SyncQueueTable syncQueue = $SyncQueueTable(this);
  late final $ImageSyncQueueTable imageSyncQueue = $ImageSyncQueueTable(this);
  late final $FilesTable files = $FilesTable(this);
  late final $RolesTable roles = $RolesTable(this);
  late final $PermissionsTable permissions = $PermissionsTable(this);
  late final $CompaniesTable companies = $CompaniesTable(this);
  late final $WorkScopesTable workScopes = $WorkScopesTable(this);
  late final $WorkQuantityTypesTable workQuantityTypes =
      $WorkQuantityTypesTable(this);
  late final $WorkQuantityFieldsTable workQuantityFields =
      $WorkQuantityFieldsTable(this);
  late final $WorkQuantityFieldOptionsTable workQuantityFieldOptions =
      $WorkQuantityFieldOptionsTable(this);
  late final $WorkScopeEquipmentsTable workScopeEquipments =
      $WorkScopeEquipmentsTable(this);
  late final $WorkScopeEquipmentTable workScopeEquipment =
      $WorkScopeEquipmentTable(this);
  late final $CountriesTable countries = $CountriesTable(this);
  late final $ProvincesTable provinces = $ProvincesTable(this);
  late final $DistrictsTable districts = $DistrictsTable(this);
  late final $RoadCategoriesTable roadCategories = $RoadCategoriesTable(this);
  late final $RoadsTable roads = $RoadsTable(this);
  late final $PackagesTable packages = $PackagesTable(this);
  late final $PackageRoadsTable packageRoads = $PackageRoadsTable(this);
  late final $DailyReportsTable dailyReports = $DailyReportsTable(this);
  late final $ReportEquipmentsTable reportEquipments = $ReportEquipmentsTable(
    this,
  );
  late final $ReportQuantitiesTable reportQuantities = $ReportQuantitiesTable(
    this,
  );
  late final $ReportQuantityValuesTable reportQuantityValues =
      $ReportQuantityValuesTable(this);
  late final $ReportSegmentsTable reportSegments = $ReportSegmentsTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    admins,
    syncQueue,
    imageSyncQueue,
    files,
    roles,
    permissions,
    companies,
    workScopes,
    workQuantityTypes,
    workQuantityFields,
    workQuantityFieldOptions,
    workScopeEquipments,
    workScopeEquipment,
    countries,
    provinces,
    districts,
    roadCategories,
    roads,
    packages,
    packageRoads,
    dailyReports,
    reportEquipments,
    reportQuantities,
    reportQuantityValues,
    reportSegments,
  ];
}

typedef $$AdminsTableCreateCompanionBuilder =
    AdminsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String phone,
      Value<String?> firstName,
      Value<String?> lastName,
      Value<String?> email,
      required DateTime updatedAt,
      required DateTime createdAt,
    });
typedef $$AdminsTableUpdateCompanionBuilder =
    AdminsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> phone,
      Value<String?> firstName,
      Value<String?> lastName,
      Value<String?> email,
      Value<DateTime> updatedAt,
      Value<DateTime> createdAt,
    });

class $$AdminsTableFilterComposer
    extends Composer<_$AppDatabase, $AdminsTable> {
  $$AdminsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get firstName => $composableBuilder(
    column: $table.firstName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastName => $composableBuilder(
    column: $table.lastName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AdminsTableOrderingComposer
    extends Composer<_$AppDatabase, $AdminsTable> {
  $$AdminsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get firstName => $composableBuilder(
    column: $table.firstName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastName => $composableBuilder(
    column: $table.lastName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AdminsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AdminsTable> {
  $$AdminsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get firstName =>
      $composableBuilder(column: $table.firstName, builder: (column) => column);

  GeneratedColumn<String> get lastName =>
      $composableBuilder(column: $table.lastName, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$AdminsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AdminsTable,
          AdminRecord,
          $$AdminsTableFilterComposer,
          $$AdminsTableOrderingComposer,
          $$AdminsTableAnnotationComposer,
          $$AdminsTableCreateCompanionBuilder,
          $$AdminsTableUpdateCompanionBuilder,
          (
            AdminRecord,
            BaseReferences<_$AppDatabase, $AdminsTable, AdminRecord>,
          ),
          AdminRecord,
          PrefetchHooks Function()
        > {
  $$AdminsTableTableManager(_$AppDatabase db, $AdminsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AdminsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AdminsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AdminsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> phone = const Value.absent(),
                Value<String?> firstName = const Value.absent(),
                Value<String?> lastName = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
              }) => AdminsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                phone: phone,
                firstName: firstName,
                lastName: lastName,
                email: email,
                updatedAt: updatedAt,
                createdAt: createdAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String phone,
                Value<String?> firstName = const Value.absent(),
                Value<String?> lastName = const Value.absent(),
                Value<String?> email = const Value.absent(),
                required DateTime updatedAt,
                required DateTime createdAt,
              }) => AdminsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                phone: phone,
                firstName: firstName,
                lastName: lastName,
                email: email,
                updatedAt: updatedAt,
                createdAt: createdAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AdminsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AdminsTable,
      AdminRecord,
      $$AdminsTableFilterComposer,
      $$AdminsTableOrderingComposer,
      $$AdminsTableAnnotationComposer,
      $$AdminsTableCreateCompanionBuilder,
      $$AdminsTableUpdateCompanionBuilder,
      (AdminRecord, BaseReferences<_$AppDatabase, $AdminsTable, AdminRecord>),
      AdminRecord,
      PrefetchHooks Function()
    >;
typedef $$SyncQueueTableCreateCompanionBuilder =
    SyncQueueCompanion Function({
      Value<int> id,
      required String entityType,
      required String entityUid,
      required String action,
      Value<String?> payload,
      Value<int> priority,
      Value<int> retryCount,
      Value<String?> error,
      required DateTime createdAt,
      Value<DateTime?> scheduledAt,
      Value<bool> isProcessed,
    });
typedef $$SyncQueueTableUpdateCompanionBuilder =
    SyncQueueCompanion Function({
      Value<int> id,
      Value<String> entityType,
      Value<String> entityUid,
      Value<String> action,
      Value<String?> payload,
      Value<int> priority,
      Value<int> retryCount,
      Value<String?> error,
      Value<DateTime> createdAt,
      Value<DateTime?> scheduledAt,
      Value<bool> isProcessed,
    });

class $$SyncQueueTableFilterComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityUid => $composableBuilder(
    column: $table.entityUid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get priority => $composableBuilder(
    column: $table.priority,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get error => $composableBuilder(
    column: $table.error,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get scheduledAt => $composableBuilder(
    column: $table.scheduledAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isProcessed => $composableBuilder(
    column: $table.isProcessed,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncQueueTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityUid => $composableBuilder(
    column: $table.entityUid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get priority => $composableBuilder(
    column: $table.priority,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get error => $composableBuilder(
    column: $table.error,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get scheduledAt => $composableBuilder(
    column: $table.scheduledAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isProcessed => $composableBuilder(
    column: $table.isProcessed,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncQueueTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityUid =>
      $composableBuilder(column: $table.entityUid, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get payload =>
      $composableBuilder(column: $table.payload, builder: (column) => column);

  GeneratedColumn<int> get priority =>
      $composableBuilder(column: $table.priority, builder: (column) => column);

  GeneratedColumn<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get error =>
      $composableBuilder(column: $table.error, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get scheduledAt => $composableBuilder(
    column: $table.scheduledAt,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isProcessed => $composableBuilder(
    column: $table.isProcessed,
    builder: (column) => column,
  );
}

class $$SyncQueueTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncQueueTable,
          SyncQueueRecord,
          $$SyncQueueTableFilterComposer,
          $$SyncQueueTableOrderingComposer,
          $$SyncQueueTableAnnotationComposer,
          $$SyncQueueTableCreateCompanionBuilder,
          $$SyncQueueTableUpdateCompanionBuilder,
          (
            SyncQueueRecord,
            BaseReferences<_$AppDatabase, $SyncQueueTable, SyncQueueRecord>,
          ),
          SyncQueueRecord,
          PrefetchHooks Function()
        > {
  $$SyncQueueTableTableManager(_$AppDatabase db, $SyncQueueTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncQueueTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncQueueTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncQueueTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityUid = const Value.absent(),
                Value<String> action = const Value.absent(),
                Value<String?> payload = const Value.absent(),
                Value<int> priority = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<String?> error = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> scheduledAt = const Value.absent(),
                Value<bool> isProcessed = const Value.absent(),
              }) => SyncQueueCompanion(
                id: id,
                entityType: entityType,
                entityUid: entityUid,
                action: action,
                payload: payload,
                priority: priority,
                retryCount: retryCount,
                error: error,
                createdAt: createdAt,
                scheduledAt: scheduledAt,
                isProcessed: isProcessed,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String entityType,
                required String entityUid,
                required String action,
                Value<String?> payload = const Value.absent(),
                Value<int> priority = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<String?> error = const Value.absent(),
                required DateTime createdAt,
                Value<DateTime?> scheduledAt = const Value.absent(),
                Value<bool> isProcessed = const Value.absent(),
              }) => SyncQueueCompanion.insert(
                id: id,
                entityType: entityType,
                entityUid: entityUid,
                action: action,
                payload: payload,
                priority: priority,
                retryCount: retryCount,
                error: error,
                createdAt: createdAt,
                scheduledAt: scheduledAt,
                isProcessed: isProcessed,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncQueueTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncQueueTable,
      SyncQueueRecord,
      $$SyncQueueTableFilterComposer,
      $$SyncQueueTableOrderingComposer,
      $$SyncQueueTableAnnotationComposer,
      $$SyncQueueTableCreateCompanionBuilder,
      $$SyncQueueTableUpdateCompanionBuilder,
      (
        SyncQueueRecord,
        BaseReferences<_$AppDatabase, $SyncQueueTable, SyncQueueRecord>,
      ),
      SyncQueueRecord,
      PrefetchHooks Function()
    >;
typedef $$ImageSyncQueueTableCreateCompanionBuilder =
    ImageSyncQueueCompanion Function({
      Value<int> id,
      required String entityType,
      required String entityUID,
      required String contextField,
      required int sequence,
      required String localFilePath,
      required String fileName,
      required String mimeType,
      required int fileSize,
      required String companyUID,
      required String uploadedByUID,
      required String syncStatus,
      Value<int> retryCount,
      Value<int> maxRetries,
      Value<String?> fileUID,
      Value<String?> s3Key,
      Value<String?> s3Url,
      Value<String?> error,
      Value<DateTime> createdAt,
      Value<DateTime?> lastAttemptAt,
    });
typedef $$ImageSyncQueueTableUpdateCompanionBuilder =
    ImageSyncQueueCompanion Function({
      Value<int> id,
      Value<String> entityType,
      Value<String> entityUID,
      Value<String> contextField,
      Value<int> sequence,
      Value<String> localFilePath,
      Value<String> fileName,
      Value<String> mimeType,
      Value<int> fileSize,
      Value<String> companyUID,
      Value<String> uploadedByUID,
      Value<String> syncStatus,
      Value<int> retryCount,
      Value<int> maxRetries,
      Value<String?> fileUID,
      Value<String?> s3Key,
      Value<String?> s3Url,
      Value<String?> error,
      Value<DateTime> createdAt,
      Value<DateTime?> lastAttemptAt,
    });

class $$ImageSyncQueueTableFilterComposer
    extends Composer<_$AppDatabase, $ImageSyncQueueTable> {
  $$ImageSyncQueueTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityUID => $composableBuilder(
    column: $table.entityUID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get contextField => $composableBuilder(
    column: $table.contextField,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get localFilePath => $composableBuilder(
    column: $table.localFilePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fileName => $composableBuilder(
    column: $table.fileName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get mimeType => $composableBuilder(
    column: $table.mimeType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fileSize => $composableBuilder(
    column: $table.fileSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get companyUID => $composableBuilder(
    column: $table.companyUID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uploadedByUID => $composableBuilder(
    column: $table.uploadedByUID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxRetries => $composableBuilder(
    column: $table.maxRetries,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fileUID => $composableBuilder(
    column: $table.fileUID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get s3Key => $composableBuilder(
    column: $table.s3Key,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get s3Url => $composableBuilder(
    column: $table.s3Url,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get error => $composableBuilder(
    column: $table.error,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ImageSyncQueueTableOrderingComposer
    extends Composer<_$AppDatabase, $ImageSyncQueueTable> {
  $$ImageSyncQueueTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityUID => $composableBuilder(
    column: $table.entityUID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get contextField => $composableBuilder(
    column: $table.contextField,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get localFilePath => $composableBuilder(
    column: $table.localFilePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fileName => $composableBuilder(
    column: $table.fileName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get mimeType => $composableBuilder(
    column: $table.mimeType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fileSize => $composableBuilder(
    column: $table.fileSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get companyUID => $composableBuilder(
    column: $table.companyUID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uploadedByUID => $composableBuilder(
    column: $table.uploadedByUID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxRetries => $composableBuilder(
    column: $table.maxRetries,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fileUID => $composableBuilder(
    column: $table.fileUID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get s3Key => $composableBuilder(
    column: $table.s3Key,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get s3Url => $composableBuilder(
    column: $table.s3Url,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get error => $composableBuilder(
    column: $table.error,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ImageSyncQueueTableAnnotationComposer
    extends Composer<_$AppDatabase, $ImageSyncQueueTable> {
  $$ImageSyncQueueTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityUID =>
      $composableBuilder(column: $table.entityUID, builder: (column) => column);

  GeneratedColumn<String> get contextField => $composableBuilder(
    column: $table.contextField,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sequence =>
      $composableBuilder(column: $table.sequence, builder: (column) => column);

  GeneratedColumn<String> get localFilePath => $composableBuilder(
    column: $table.localFilePath,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fileName =>
      $composableBuilder(column: $table.fileName, builder: (column) => column);

  GeneratedColumn<String> get mimeType =>
      $composableBuilder(column: $table.mimeType, builder: (column) => column);

  GeneratedColumn<int> get fileSize =>
      $composableBuilder(column: $table.fileSize, builder: (column) => column);

  GeneratedColumn<String> get companyUID => $composableBuilder(
    column: $table.companyUID,
    builder: (column) => column,
  );

  GeneratedColumn<String> get uploadedByUID => $composableBuilder(
    column: $table.uploadedByUID,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncStatus => $composableBuilder(
    column: $table.syncStatus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get maxRetries => $composableBuilder(
    column: $table.maxRetries,
    builder: (column) => column,
  );

  GeneratedColumn<String> get fileUID =>
      $composableBuilder(column: $table.fileUID, builder: (column) => column);

  GeneratedColumn<String> get s3Key =>
      $composableBuilder(column: $table.s3Key, builder: (column) => column);

  GeneratedColumn<String> get s3Url =>
      $composableBuilder(column: $table.s3Url, builder: (column) => column);

  GeneratedColumn<String> get error =>
      $composableBuilder(column: $table.error, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastAttemptAt => $composableBuilder(
    column: $table.lastAttemptAt,
    builder: (column) => column,
  );
}

class $$ImageSyncQueueTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ImageSyncQueueTable,
          ImageSyncQueueRecord,
          $$ImageSyncQueueTableFilterComposer,
          $$ImageSyncQueueTableOrderingComposer,
          $$ImageSyncQueueTableAnnotationComposer,
          $$ImageSyncQueueTableCreateCompanionBuilder,
          $$ImageSyncQueueTableUpdateCompanionBuilder,
          (
            ImageSyncQueueRecord,
            BaseReferences<
              _$AppDatabase,
              $ImageSyncQueueTable,
              ImageSyncQueueRecord
            >,
          ),
          ImageSyncQueueRecord,
          PrefetchHooks Function()
        > {
  $$ImageSyncQueueTableTableManager(
    _$AppDatabase db,
    $ImageSyncQueueTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ImageSyncQueueTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ImageSyncQueueTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ImageSyncQueueTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityUID = const Value.absent(),
                Value<String> contextField = const Value.absent(),
                Value<int> sequence = const Value.absent(),
                Value<String> localFilePath = const Value.absent(),
                Value<String> fileName = const Value.absent(),
                Value<String> mimeType = const Value.absent(),
                Value<int> fileSize = const Value.absent(),
                Value<String> companyUID = const Value.absent(),
                Value<String> uploadedByUID = const Value.absent(),
                Value<String> syncStatus = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<int> maxRetries = const Value.absent(),
                Value<String?> fileUID = const Value.absent(),
                Value<String?> s3Key = const Value.absent(),
                Value<String?> s3Url = const Value.absent(),
                Value<String?> error = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> lastAttemptAt = const Value.absent(),
              }) => ImageSyncQueueCompanion(
                id: id,
                entityType: entityType,
                entityUID: entityUID,
                contextField: contextField,
                sequence: sequence,
                localFilePath: localFilePath,
                fileName: fileName,
                mimeType: mimeType,
                fileSize: fileSize,
                companyUID: companyUID,
                uploadedByUID: uploadedByUID,
                syncStatus: syncStatus,
                retryCount: retryCount,
                maxRetries: maxRetries,
                fileUID: fileUID,
                s3Key: s3Key,
                s3Url: s3Url,
                error: error,
                createdAt: createdAt,
                lastAttemptAt: lastAttemptAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String entityType,
                required String entityUID,
                required String contextField,
                required int sequence,
                required String localFilePath,
                required String fileName,
                required String mimeType,
                required int fileSize,
                required String companyUID,
                required String uploadedByUID,
                required String syncStatus,
                Value<int> retryCount = const Value.absent(),
                Value<int> maxRetries = const Value.absent(),
                Value<String?> fileUID = const Value.absent(),
                Value<String?> s3Key = const Value.absent(),
                Value<String?> s3Url = const Value.absent(),
                Value<String?> error = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> lastAttemptAt = const Value.absent(),
              }) => ImageSyncQueueCompanion.insert(
                id: id,
                entityType: entityType,
                entityUID: entityUID,
                contextField: contextField,
                sequence: sequence,
                localFilePath: localFilePath,
                fileName: fileName,
                mimeType: mimeType,
                fileSize: fileSize,
                companyUID: companyUID,
                uploadedByUID: uploadedByUID,
                syncStatus: syncStatus,
                retryCount: retryCount,
                maxRetries: maxRetries,
                fileUID: fileUID,
                s3Key: s3Key,
                s3Url: s3Url,
                error: error,
                createdAt: createdAt,
                lastAttemptAt: lastAttemptAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ImageSyncQueueTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ImageSyncQueueTable,
      ImageSyncQueueRecord,
      $$ImageSyncQueueTableFilterComposer,
      $$ImageSyncQueueTableOrderingComposer,
      $$ImageSyncQueueTableAnnotationComposer,
      $$ImageSyncQueueTableCreateCompanionBuilder,
      $$ImageSyncQueueTableUpdateCompanionBuilder,
      (
        ImageSyncQueueRecord,
        BaseReferences<
          _$AppDatabase,
          $ImageSyncQueueTable,
          ImageSyncQueueRecord
        >,
      ),
      ImageSyncQueueRecord,
      PrefetchHooks Function()
    >;
typedef $$FilesTableCreateCompanionBuilder =
    FilesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String fileName,
      required String s3Url,
      required String mimeType,
      required int size,
      Value<int?> sequence,
      required int companyID,
      required String contextType,
      Value<String?> contextField,
      Value<int?> dailyReportID,
      required int uploadedByID,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$FilesTableUpdateCompanionBuilder =
    FilesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> fileName,
      Value<String> s3Url,
      Value<String> mimeType,
      Value<int> size,
      Value<int?> sequence,
      Value<int> companyID,
      Value<String> contextType,
      Value<String?> contextField,
      Value<int?> dailyReportID,
      Value<int> uploadedByID,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$FilesTableFilterComposer extends Composer<_$AppDatabase, $FilesTable> {
  $$FilesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fileName => $composableBuilder(
    column: $table.fileName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get s3Url => $composableBuilder(
    column: $table.s3Url,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get mimeType => $composableBuilder(
    column: $table.mimeType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get size => $composableBuilder(
    column: $table.size,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get companyID => $composableBuilder(
    column: $table.companyID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get contextType => $composableBuilder(
    column: $table.contextType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get contextField => $composableBuilder(
    column: $table.contextField,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get uploadedByID => $composableBuilder(
    column: $table.uploadedByID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FilesTableOrderingComposer
    extends Composer<_$AppDatabase, $FilesTable> {
  $$FilesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fileName => $composableBuilder(
    column: $table.fileName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get s3Url => $composableBuilder(
    column: $table.s3Url,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get mimeType => $composableBuilder(
    column: $table.mimeType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get size => $composableBuilder(
    column: $table.size,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sequence => $composableBuilder(
    column: $table.sequence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get companyID => $composableBuilder(
    column: $table.companyID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get contextType => $composableBuilder(
    column: $table.contextType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get contextField => $composableBuilder(
    column: $table.contextField,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get uploadedByID => $composableBuilder(
    column: $table.uploadedByID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FilesTableAnnotationComposer
    extends Composer<_$AppDatabase, $FilesTable> {
  $$FilesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get fileName =>
      $composableBuilder(column: $table.fileName, builder: (column) => column);

  GeneratedColumn<String> get s3Url =>
      $composableBuilder(column: $table.s3Url, builder: (column) => column);

  GeneratedColumn<String> get mimeType =>
      $composableBuilder(column: $table.mimeType, builder: (column) => column);

  GeneratedColumn<int> get size =>
      $composableBuilder(column: $table.size, builder: (column) => column);

  GeneratedColumn<int> get sequence =>
      $composableBuilder(column: $table.sequence, builder: (column) => column);

  GeneratedColumn<int> get companyID =>
      $composableBuilder(column: $table.companyID, builder: (column) => column);

  GeneratedColumn<String> get contextType => $composableBuilder(
    column: $table.contextType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get contextField => $composableBuilder(
    column: $table.contextField,
    builder: (column) => column,
  );

  GeneratedColumn<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get uploadedByID => $composableBuilder(
    column: $table.uploadedByID,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$FilesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FilesTable,
          FileRecord,
          $$FilesTableFilterComposer,
          $$FilesTableOrderingComposer,
          $$FilesTableAnnotationComposer,
          $$FilesTableCreateCompanionBuilder,
          $$FilesTableUpdateCompanionBuilder,
          (FileRecord, BaseReferences<_$AppDatabase, $FilesTable, FileRecord>),
          FileRecord,
          PrefetchHooks Function()
        > {
  $$FilesTableTableManager(_$AppDatabase db, $FilesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FilesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FilesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FilesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> fileName = const Value.absent(),
                Value<String> s3Url = const Value.absent(),
                Value<String> mimeType = const Value.absent(),
                Value<int> size = const Value.absent(),
                Value<int?> sequence = const Value.absent(),
                Value<int> companyID = const Value.absent(),
                Value<String> contextType = const Value.absent(),
                Value<String?> contextField = const Value.absent(),
                Value<int?> dailyReportID = const Value.absent(),
                Value<int> uploadedByID = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => FilesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                fileName: fileName,
                s3Url: s3Url,
                mimeType: mimeType,
                size: size,
                sequence: sequence,
                companyID: companyID,
                contextType: contextType,
                contextField: contextField,
                dailyReportID: dailyReportID,
                uploadedByID: uploadedByID,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String fileName,
                required String s3Url,
                required String mimeType,
                required int size,
                Value<int?> sequence = const Value.absent(),
                required int companyID,
                required String contextType,
                Value<String?> contextField = const Value.absent(),
                Value<int?> dailyReportID = const Value.absent(),
                required int uploadedByID,
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => FilesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                fileName: fileName,
                s3Url: s3Url,
                mimeType: mimeType,
                size: size,
                sequence: sequence,
                companyID: companyID,
                contextType: contextType,
                contextField: contextField,
                dailyReportID: dailyReportID,
                uploadedByID: uploadedByID,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FilesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FilesTable,
      FileRecord,
      $$FilesTableFilterComposer,
      $$FilesTableOrderingComposer,
      $$FilesTableAnnotationComposer,
      $$FilesTableCreateCompanionBuilder,
      $$FilesTableUpdateCompanionBuilder,
      (FileRecord, BaseReferences<_$AppDatabase, $FilesTable, FileRecord>),
      FileRecord,
      PrefetchHooks Function()
    >;
typedef $$RolesTableCreateCompanionBuilder =
    RolesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      Value<String?> description,
      required int companyID,
      Value<bool> isSystemRole,
      Value<bool> isActive,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$RolesTableUpdateCompanionBuilder =
    RolesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String?> description,
      Value<int> companyID,
      Value<bool> isSystemRole,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$RolesTableFilterComposer extends Composer<_$AppDatabase, $RolesTable> {
  $$RolesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get companyID => $composableBuilder(
    column: $table.companyID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSystemRole => $composableBuilder(
    column: $table.isSystemRole,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$RolesTableOrderingComposer
    extends Composer<_$AppDatabase, $RolesTable> {
  $$RolesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get companyID => $composableBuilder(
    column: $table.companyID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSystemRole => $composableBuilder(
    column: $table.isSystemRole,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RolesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RolesTable> {
  $$RolesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<int> get companyID =>
      $composableBuilder(column: $table.companyID, builder: (column) => column);

  GeneratedColumn<bool> get isSystemRole => $composableBuilder(
    column: $table.isSystemRole,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$RolesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RolesTable,
          RoleRecord,
          $$RolesTableFilterComposer,
          $$RolesTableOrderingComposer,
          $$RolesTableAnnotationComposer,
          $$RolesTableCreateCompanionBuilder,
          $$RolesTableUpdateCompanionBuilder,
          (RoleRecord, BaseReferences<_$AppDatabase, $RolesTable, RoleRecord>),
          RoleRecord,
          PrefetchHooks Function()
        > {
  $$RolesTableTableManager(_$AppDatabase db, $RolesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RolesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RolesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RolesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<int> companyID = const Value.absent(),
                Value<bool> isSystemRole = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => RolesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                description: description,
                companyID: companyID,
                isSystemRole: isSystemRole,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                Value<String?> description = const Value.absent(),
                required int companyID,
                Value<bool> isSystemRole = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => RolesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                description: description,
                companyID: companyID,
                isSystemRole: isSystemRole,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$RolesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RolesTable,
      RoleRecord,
      $$RolesTableFilterComposer,
      $$RolesTableOrderingComposer,
      $$RolesTableAnnotationComposer,
      $$RolesTableCreateCompanionBuilder,
      $$RolesTableUpdateCompanionBuilder,
      (RoleRecord, BaseReferences<_$AppDatabase, $RolesTable, RoleRecord>),
      RoleRecord,
      PrefetchHooks Function()
    >;
typedef $$PermissionsTableCreateCompanionBuilder =
    PermissionsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String code,
      required String name,
      Value<String?> description,
      required String category,
      required String scope,
      required int roleID,
    });
typedef $$PermissionsTableUpdateCompanionBuilder =
    PermissionsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> code,
      Value<String> name,
      Value<String?> description,
      Value<String> category,
      Value<String> scope,
      Value<int> roleID,
    });

class $$PermissionsTableFilterComposer
    extends Composer<_$AppDatabase, $PermissionsTable> {
  $$PermissionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get scope => $composableBuilder(
    column: $table.scope,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get roleID => $composableBuilder(
    column: $table.roleID,
    builder: (column) => ColumnFilters(column),
  );
}

class $$PermissionsTableOrderingComposer
    extends Composer<_$AppDatabase, $PermissionsTable> {
  $$PermissionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get scope => $composableBuilder(
    column: $table.scope,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get roleID => $composableBuilder(
    column: $table.roleID,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PermissionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PermissionsTable> {
  $$PermissionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<String> get scope =>
      $composableBuilder(column: $table.scope, builder: (column) => column);

  GeneratedColumn<int> get roleID =>
      $composableBuilder(column: $table.roleID, builder: (column) => column);
}

class $$PermissionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PermissionsTable,
          PermissionRecord,
          $$PermissionsTableFilterComposer,
          $$PermissionsTableOrderingComposer,
          $$PermissionsTableAnnotationComposer,
          $$PermissionsTableCreateCompanionBuilder,
          $$PermissionsTableUpdateCompanionBuilder,
          (
            PermissionRecord,
            BaseReferences<_$AppDatabase, $PermissionsTable, PermissionRecord>,
          ),
          PermissionRecord,
          PrefetchHooks Function()
        > {
  $$PermissionsTableTableManager(_$AppDatabase db, $PermissionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PermissionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PermissionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PermissionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<String> scope = const Value.absent(),
                Value<int> roleID = const Value.absent(),
              }) => PermissionsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                code: code,
                name: name,
                description: description,
                category: category,
                scope: scope,
                roleID: roleID,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String code,
                required String name,
                Value<String?> description = const Value.absent(),
                required String category,
                required String scope,
                required int roleID,
              }) => PermissionsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                code: code,
                name: name,
                description: description,
                category: category,
                scope: scope,
                roleID: roleID,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$PermissionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PermissionsTable,
      PermissionRecord,
      $$PermissionsTableFilterComposer,
      $$PermissionsTableOrderingComposer,
      $$PermissionsTableAnnotationComposer,
      $$PermissionsTableCreateCompanionBuilder,
      $$PermissionsTableUpdateCompanionBuilder,
      (
        PermissionRecord,
        BaseReferences<_$AppDatabase, $PermissionsTable, PermissionRecord>,
      ),
      PermissionRecord,
      PrefetchHooks Function()
    >;
typedef $$CompaniesTableCreateCompanionBuilder =
    CompaniesCompanion Function({
      Value<int> id,
      required String uid,
      required String name,
      Value<String?> regNo,
      Value<String?> cidbNo,
      Value<String?> address,
      Value<String?> postalCode,
      Value<String?> city,
      Value<String?> state,
      Value<String?> country,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> website,
      required String companyType,
      required int ownerID,
      Value<String?> defaultBankAcc,
      Value<String?> defaultBankAccType,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<DateTime?> deletedAt,
      Value<String?> adminRoleUid,
      Value<String?> adminRoleName,
      Value<bool> bumiputera,
      Value<String?> einvoiceTinNo,
      Value<DateTime?> registrationDate,
    });
typedef $$CompaniesTableUpdateCompanionBuilder =
    CompaniesCompanion Function({
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String?> regNo,
      Value<String?> cidbNo,
      Value<String?> address,
      Value<String?> postalCode,
      Value<String?> city,
      Value<String?> state,
      Value<String?> country,
      Value<String?> phone,
      Value<String?> email,
      Value<String?> website,
      Value<String> companyType,
      Value<int> ownerID,
      Value<String?> defaultBankAcc,
      Value<String?> defaultBankAccType,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<DateTime?> deletedAt,
      Value<String?> adminRoleUid,
      Value<String?> adminRoleName,
      Value<bool> bumiputera,
      Value<String?> einvoiceTinNo,
      Value<DateTime?> registrationDate,
    });

class $$CompaniesTableFilterComposer
    extends Composer<_$AppDatabase, $CompaniesTable> {
  $$CompaniesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get regNo => $composableBuilder(
    column: $table.regNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get cidbNo => $composableBuilder(
    column: $table.cidbNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get postalCode => $composableBuilder(
    column: $table.postalCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get city => $composableBuilder(
    column: $table.city,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get state => $composableBuilder(
    column: $table.state,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get country => $composableBuilder(
    column: $table.country,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get website => $composableBuilder(
    column: $table.website,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get companyType => $composableBuilder(
    column: $table.companyType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get ownerID => $composableBuilder(
    column: $table.ownerID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get defaultBankAcc => $composableBuilder(
    column: $table.defaultBankAcc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get defaultBankAccType => $composableBuilder(
    column: $table.defaultBankAccType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get adminRoleUid => $composableBuilder(
    column: $table.adminRoleUid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get adminRoleName => $composableBuilder(
    column: $table.adminRoleName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get bumiputera => $composableBuilder(
    column: $table.bumiputera,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get einvoiceTinNo => $composableBuilder(
    column: $table.einvoiceTinNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get registrationDate => $composableBuilder(
    column: $table.registrationDate,
    builder: (column) => ColumnFilters(column),
  );
}

class $$CompaniesTableOrderingComposer
    extends Composer<_$AppDatabase, $CompaniesTable> {
  $$CompaniesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get regNo => $composableBuilder(
    column: $table.regNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get cidbNo => $composableBuilder(
    column: $table.cidbNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get postalCode => $composableBuilder(
    column: $table.postalCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get city => $composableBuilder(
    column: $table.city,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get state => $composableBuilder(
    column: $table.state,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get country => $composableBuilder(
    column: $table.country,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get website => $composableBuilder(
    column: $table.website,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get companyType => $composableBuilder(
    column: $table.companyType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get ownerID => $composableBuilder(
    column: $table.ownerID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get defaultBankAcc => $composableBuilder(
    column: $table.defaultBankAcc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get defaultBankAccType => $composableBuilder(
    column: $table.defaultBankAccType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get adminRoleUid => $composableBuilder(
    column: $table.adminRoleUid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get adminRoleName => $composableBuilder(
    column: $table.adminRoleName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get bumiputera => $composableBuilder(
    column: $table.bumiputera,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get einvoiceTinNo => $composableBuilder(
    column: $table.einvoiceTinNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get registrationDate => $composableBuilder(
    column: $table.registrationDate,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CompaniesTableAnnotationComposer
    extends Composer<_$AppDatabase, $CompaniesTable> {
  $$CompaniesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get regNo =>
      $composableBuilder(column: $table.regNo, builder: (column) => column);

  GeneratedColumn<String> get cidbNo =>
      $composableBuilder(column: $table.cidbNo, builder: (column) => column);

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get postalCode => $composableBuilder(
    column: $table.postalCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get city =>
      $composableBuilder(column: $table.city, builder: (column) => column);

  GeneratedColumn<String> get state =>
      $composableBuilder(column: $table.state, builder: (column) => column);

  GeneratedColumn<String> get country =>
      $composableBuilder(column: $table.country, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get website =>
      $composableBuilder(column: $table.website, builder: (column) => column);

  GeneratedColumn<String> get companyType => $composableBuilder(
    column: $table.companyType,
    builder: (column) => column,
  );

  GeneratedColumn<int> get ownerID =>
      $composableBuilder(column: $table.ownerID, builder: (column) => column);

  GeneratedColumn<String> get defaultBankAcc => $composableBuilder(
    column: $table.defaultBankAcc,
    builder: (column) => column,
  );

  GeneratedColumn<String> get defaultBankAccType => $composableBuilder(
    column: $table.defaultBankAccType,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get adminRoleUid => $composableBuilder(
    column: $table.adminRoleUid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get adminRoleName => $composableBuilder(
    column: $table.adminRoleName,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get bumiputera => $composableBuilder(
    column: $table.bumiputera,
    builder: (column) => column,
  );

  GeneratedColumn<String> get einvoiceTinNo => $composableBuilder(
    column: $table.einvoiceTinNo,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get registrationDate => $composableBuilder(
    column: $table.registrationDate,
    builder: (column) => column,
  );
}

class $$CompaniesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CompaniesTable,
          CompanyRecord,
          $$CompaniesTableFilterComposer,
          $$CompaniesTableOrderingComposer,
          $$CompaniesTableAnnotationComposer,
          $$CompaniesTableCreateCompanionBuilder,
          $$CompaniesTableUpdateCompanionBuilder,
          (
            CompanyRecord,
            BaseReferences<_$AppDatabase, $CompaniesTable, CompanyRecord>,
          ),
          CompanyRecord,
          PrefetchHooks Function()
        > {
  $$CompaniesTableTableManager(_$AppDatabase db, $CompaniesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CompaniesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CompaniesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CompaniesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> regNo = const Value.absent(),
                Value<String?> cidbNo = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> postalCode = const Value.absent(),
                Value<String?> city = const Value.absent(),
                Value<String?> state = const Value.absent(),
                Value<String?> country = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> website = const Value.absent(),
                Value<String> companyType = const Value.absent(),
                Value<int> ownerID = const Value.absent(),
                Value<String?> defaultBankAcc = const Value.absent(),
                Value<String?> defaultBankAccType = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> adminRoleUid = const Value.absent(),
                Value<String?> adminRoleName = const Value.absent(),
                Value<bool> bumiputera = const Value.absent(),
                Value<String?> einvoiceTinNo = const Value.absent(),
                Value<DateTime?> registrationDate = const Value.absent(),
              }) => CompaniesCompanion(
                id: id,
                uid: uid,
                name: name,
                regNo: regNo,
                cidbNo: cidbNo,
                address: address,
                postalCode: postalCode,
                city: city,
                state: state,
                country: country,
                phone: phone,
                email: email,
                website: website,
                companyType: companyType,
                ownerID: ownerID,
                defaultBankAcc: defaultBankAcc,
                defaultBankAccType: defaultBankAccType,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                adminRoleUid: adminRoleUid,
                adminRoleName: adminRoleName,
                bumiputera: bumiputera,
                einvoiceTinNo: einvoiceTinNo,
                registrationDate: registrationDate,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                Value<String?> regNo = const Value.absent(),
                Value<String?> cidbNo = const Value.absent(),
                Value<String?> address = const Value.absent(),
                Value<String?> postalCode = const Value.absent(),
                Value<String?> city = const Value.absent(),
                Value<String?> state = const Value.absent(),
                Value<String?> country = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> website = const Value.absent(),
                required String companyType,
                required int ownerID,
                Value<String?> defaultBankAcc = const Value.absent(),
                Value<String?> defaultBankAccType = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> adminRoleUid = const Value.absent(),
                Value<String?> adminRoleName = const Value.absent(),
                Value<bool> bumiputera = const Value.absent(),
                Value<String?> einvoiceTinNo = const Value.absent(),
                Value<DateTime?> registrationDate = const Value.absent(),
              }) => CompaniesCompanion.insert(
                id: id,
                uid: uid,
                name: name,
                regNo: regNo,
                cidbNo: cidbNo,
                address: address,
                postalCode: postalCode,
                city: city,
                state: state,
                country: country,
                phone: phone,
                email: email,
                website: website,
                companyType: companyType,
                ownerID: ownerID,
                defaultBankAcc: defaultBankAcc,
                defaultBankAccType: defaultBankAccType,
                createdAt: createdAt,
                updatedAt: updatedAt,
                deletedAt: deletedAt,
                adminRoleUid: adminRoleUid,
                adminRoleName: adminRoleName,
                bumiputera: bumiputera,
                einvoiceTinNo: einvoiceTinNo,
                registrationDate: registrationDate,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$CompaniesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CompaniesTable,
      CompanyRecord,
      $$CompaniesTableFilterComposer,
      $$CompaniesTableOrderingComposer,
      $$CompaniesTableAnnotationComposer,
      $$CompaniesTableCreateCompanionBuilder,
      $$CompaniesTableUpdateCompanionBuilder,
      (
        CompanyRecord,
        BaseReferences<_$AppDatabase, $CompaniesTable, CompanyRecord>,
      ),
      CompanyRecord,
      PrefetchHooks Function()
    >;
typedef $$WorkScopesTableCreateCompanionBuilder =
    WorkScopesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      required String code,
      required String description,
      Value<bool> allowMultipleQuantities,
      required DateTime createdAt,
      required DateTime updatedAt,
      required int companyID,
    });
typedef $$WorkScopesTableUpdateCompanionBuilder =
    WorkScopesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String> code,
      Value<String> description,
      Value<bool> allowMultipleQuantities,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> companyID,
    });

class $$WorkScopesTableFilterComposer
    extends Composer<_$AppDatabase, $WorkScopesTable> {
  $$WorkScopesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get allowMultipleQuantities => $composableBuilder(
    column: $table.allowMultipleQuantities,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get companyID => $composableBuilder(
    column: $table.companyID,
    builder: (column) => ColumnFilters(column),
  );
}

class $$WorkScopesTableOrderingComposer
    extends Composer<_$AppDatabase, $WorkScopesTable> {
  $$WorkScopesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get allowMultipleQuantities => $composableBuilder(
    column: $table.allowMultipleQuantities,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get companyID => $composableBuilder(
    column: $table.companyID,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$WorkScopesTableAnnotationComposer
    extends Composer<_$AppDatabase, $WorkScopesTable> {
  $$WorkScopesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get allowMultipleQuantities => $composableBuilder(
    column: $table.allowMultipleQuantities,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get companyID =>
      $composableBuilder(column: $table.companyID, builder: (column) => column);
}

class $$WorkScopesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $WorkScopesTable,
          WorkScopeRecord,
          $$WorkScopesTableFilterComposer,
          $$WorkScopesTableOrderingComposer,
          $$WorkScopesTableAnnotationComposer,
          $$WorkScopesTableCreateCompanionBuilder,
          $$WorkScopesTableUpdateCompanionBuilder,
          (
            WorkScopeRecord,
            BaseReferences<_$AppDatabase, $WorkScopesTable, WorkScopeRecord>,
          ),
          WorkScopeRecord,
          PrefetchHooks Function()
        > {
  $$WorkScopesTableTableManager(_$AppDatabase db, $WorkScopesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WorkScopesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WorkScopesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WorkScopesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> description = const Value.absent(),
                Value<bool> allowMultipleQuantities = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> companyID = const Value.absent(),
              }) => WorkScopesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                code: code,
                description: description,
                allowMultipleQuantities: allowMultipleQuantities,
                createdAt: createdAt,
                updatedAt: updatedAt,
                companyID: companyID,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                required String code,
                required String description,
                Value<bool> allowMultipleQuantities = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
                required int companyID,
              }) => WorkScopesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                code: code,
                description: description,
                allowMultipleQuantities: allowMultipleQuantities,
                createdAt: createdAt,
                updatedAt: updatedAt,
                companyID: companyID,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$WorkScopesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $WorkScopesTable,
      WorkScopeRecord,
      $$WorkScopesTableFilterComposer,
      $$WorkScopesTableOrderingComposer,
      $$WorkScopesTableAnnotationComposer,
      $$WorkScopesTableCreateCompanionBuilder,
      $$WorkScopesTableUpdateCompanionBuilder,
      (
        WorkScopeRecord,
        BaseReferences<_$AppDatabase, $WorkScopesTable, WorkScopeRecord>,
      ),
      WorkScopeRecord,
      PrefetchHooks Function()
    >;
typedef $$WorkQuantityTypesTableCreateCompanionBuilder =
    WorkQuantityTypesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      required String code,
      required int displayOrder,
      Value<bool> hasSegmentBreakdown,
      Value<int?> segmentSize,
      Value<int?> maxSegmentLength,
      required int workScopeID,
    });
typedef $$WorkQuantityTypesTableUpdateCompanionBuilder =
    WorkQuantityTypesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String> code,
      Value<int> displayOrder,
      Value<bool> hasSegmentBreakdown,
      Value<int?> segmentSize,
      Value<int?> maxSegmentLength,
      Value<int> workScopeID,
    });

class $$WorkQuantityTypesTableFilterComposer
    extends Composer<_$AppDatabase, $WorkQuantityTypesTable> {
  $$WorkQuantityTypesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hasSegmentBreakdown => $composableBuilder(
    column: $table.hasSegmentBreakdown,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get segmentSize => $composableBuilder(
    column: $table.segmentSize,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxSegmentLength => $composableBuilder(
    column: $table.maxSegmentLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => ColumnFilters(column),
  );
}

class $$WorkQuantityTypesTableOrderingComposer
    extends Composer<_$AppDatabase, $WorkQuantityTypesTable> {
  $$WorkQuantityTypesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hasSegmentBreakdown => $composableBuilder(
    column: $table.hasSegmentBreakdown,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get segmentSize => $composableBuilder(
    column: $table.segmentSize,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxSegmentLength => $composableBuilder(
    column: $table.maxSegmentLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$WorkQuantityTypesTableAnnotationComposer
    extends Composer<_$AppDatabase, $WorkQuantityTypesTable> {
  $$WorkQuantityTypesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get hasSegmentBreakdown => $composableBuilder(
    column: $table.hasSegmentBreakdown,
    builder: (column) => column,
  );

  GeneratedColumn<int> get segmentSize => $composableBuilder(
    column: $table.segmentSize,
    builder: (column) => column,
  );

  GeneratedColumn<int> get maxSegmentLength => $composableBuilder(
    column: $table.maxSegmentLength,
    builder: (column) => column,
  );

  GeneratedColumn<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => column,
  );
}

class $$WorkQuantityTypesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $WorkQuantityTypesTable,
          WorkQuantityTypeRecord,
          $$WorkQuantityTypesTableFilterComposer,
          $$WorkQuantityTypesTableOrderingComposer,
          $$WorkQuantityTypesTableAnnotationComposer,
          $$WorkQuantityTypesTableCreateCompanionBuilder,
          $$WorkQuantityTypesTableUpdateCompanionBuilder,
          (
            WorkQuantityTypeRecord,
            BaseReferences<
              _$AppDatabase,
              $WorkQuantityTypesTable,
              WorkQuantityTypeRecord
            >,
          ),
          WorkQuantityTypeRecord,
          PrefetchHooks Function()
        > {
  $$WorkQuantityTypesTableTableManager(
    _$AppDatabase db,
    $WorkQuantityTypesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WorkQuantityTypesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WorkQuantityTypesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WorkQuantityTypesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<bool> hasSegmentBreakdown = const Value.absent(),
                Value<int?> segmentSize = const Value.absent(),
                Value<int?> maxSegmentLength = const Value.absent(),
                Value<int> workScopeID = const Value.absent(),
              }) => WorkQuantityTypesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                code: code,
                displayOrder: displayOrder,
                hasSegmentBreakdown: hasSegmentBreakdown,
                segmentSize: segmentSize,
                maxSegmentLength: maxSegmentLength,
                workScopeID: workScopeID,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                required String code,
                required int displayOrder,
                Value<bool> hasSegmentBreakdown = const Value.absent(),
                Value<int?> segmentSize = const Value.absent(),
                Value<int?> maxSegmentLength = const Value.absent(),
                required int workScopeID,
              }) => WorkQuantityTypesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                code: code,
                displayOrder: displayOrder,
                hasSegmentBreakdown: hasSegmentBreakdown,
                segmentSize: segmentSize,
                maxSegmentLength: maxSegmentLength,
                workScopeID: workScopeID,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$WorkQuantityTypesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $WorkQuantityTypesTable,
      WorkQuantityTypeRecord,
      $$WorkQuantityTypesTableFilterComposer,
      $$WorkQuantityTypesTableOrderingComposer,
      $$WorkQuantityTypesTableAnnotationComposer,
      $$WorkQuantityTypesTableCreateCompanionBuilder,
      $$WorkQuantityTypesTableUpdateCompanionBuilder,
      (
        WorkQuantityTypeRecord,
        BaseReferences<
          _$AppDatabase,
          $WorkQuantityTypesTable,
          WorkQuantityTypeRecord
        >,
      ),
      WorkQuantityTypeRecord,
      PrefetchHooks Function()
    >;
typedef $$WorkQuantityFieldsTableCreateCompanionBuilder =
    WorkQuantityFieldsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      required String code,
      required String fieldType,
      Value<String?> unit,
      Value<String?> validationRules,
      required int displayOrder,
      Value<bool> isRequired,
      Value<bool> isForSegment,
      Value<String?> defaultValue,
      Value<String?> placeholder,
      Value<String?> helpText,
      required int quantityTypeID,
    });
typedef $$WorkQuantityFieldsTableUpdateCompanionBuilder =
    WorkQuantityFieldsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String> code,
      Value<String> fieldType,
      Value<String?> unit,
      Value<String?> validationRules,
      Value<int> displayOrder,
      Value<bool> isRequired,
      Value<bool> isForSegment,
      Value<String?> defaultValue,
      Value<String?> placeholder,
      Value<String?> helpText,
      Value<int> quantityTypeID,
    });

class $$WorkQuantityFieldsTableFilterComposer
    extends Composer<_$AppDatabase, $WorkQuantityFieldsTable> {
  $$WorkQuantityFieldsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fieldType => $composableBuilder(
    column: $table.fieldType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get validationRules => $composableBuilder(
    column: $table.validationRules,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isForSegment => $composableBuilder(
    column: $table.isForSegment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get defaultValue => $composableBuilder(
    column: $table.defaultValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get placeholder => $composableBuilder(
    column: $table.placeholder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get helpText => $composableBuilder(
    column: $table.helpText,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantityTypeID => $composableBuilder(
    column: $table.quantityTypeID,
    builder: (column) => ColumnFilters(column),
  );
}

class $$WorkQuantityFieldsTableOrderingComposer
    extends Composer<_$AppDatabase, $WorkQuantityFieldsTable> {
  $$WorkQuantityFieldsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fieldType => $composableBuilder(
    column: $table.fieldType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get unit => $composableBuilder(
    column: $table.unit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get validationRules => $composableBuilder(
    column: $table.validationRules,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isForSegment => $composableBuilder(
    column: $table.isForSegment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get defaultValue => $composableBuilder(
    column: $table.defaultValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get placeholder => $composableBuilder(
    column: $table.placeholder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get helpText => $composableBuilder(
    column: $table.helpText,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantityTypeID => $composableBuilder(
    column: $table.quantityTypeID,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$WorkQuantityFieldsTableAnnotationComposer
    extends Composer<_$AppDatabase, $WorkQuantityFieldsTable> {
  $$WorkQuantityFieldsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get fieldType =>
      $composableBuilder(column: $table.fieldType, builder: (column) => column);

  GeneratedColumn<String> get unit =>
      $composableBuilder(column: $table.unit, builder: (column) => column);

  GeneratedColumn<String> get validationRules => $composableBuilder(
    column: $table.validationRules,
    builder: (column) => column,
  );

  GeneratedColumn<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isRequired => $composableBuilder(
    column: $table.isRequired,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isForSegment => $composableBuilder(
    column: $table.isForSegment,
    builder: (column) => column,
  );

  GeneratedColumn<String> get defaultValue => $composableBuilder(
    column: $table.defaultValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get placeholder => $composableBuilder(
    column: $table.placeholder,
    builder: (column) => column,
  );

  GeneratedColumn<String> get helpText =>
      $composableBuilder(column: $table.helpText, builder: (column) => column);

  GeneratedColumn<int> get quantityTypeID => $composableBuilder(
    column: $table.quantityTypeID,
    builder: (column) => column,
  );
}

class $$WorkQuantityFieldsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $WorkQuantityFieldsTable,
          WorkQuantityFieldRecord,
          $$WorkQuantityFieldsTableFilterComposer,
          $$WorkQuantityFieldsTableOrderingComposer,
          $$WorkQuantityFieldsTableAnnotationComposer,
          $$WorkQuantityFieldsTableCreateCompanionBuilder,
          $$WorkQuantityFieldsTableUpdateCompanionBuilder,
          (
            WorkQuantityFieldRecord,
            BaseReferences<
              _$AppDatabase,
              $WorkQuantityFieldsTable,
              WorkQuantityFieldRecord
            >,
          ),
          WorkQuantityFieldRecord,
          PrefetchHooks Function()
        > {
  $$WorkQuantityFieldsTableTableManager(
    _$AppDatabase db,
    $WorkQuantityFieldsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WorkQuantityFieldsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WorkQuantityFieldsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WorkQuantityFieldsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> code = const Value.absent(),
                Value<String> fieldType = const Value.absent(),
                Value<String?> unit = const Value.absent(),
                Value<String?> validationRules = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<bool> isRequired = const Value.absent(),
                Value<bool> isForSegment = const Value.absent(),
                Value<String?> defaultValue = const Value.absent(),
                Value<String?> placeholder = const Value.absent(),
                Value<String?> helpText = const Value.absent(),
                Value<int> quantityTypeID = const Value.absent(),
              }) => WorkQuantityFieldsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                code: code,
                fieldType: fieldType,
                unit: unit,
                validationRules: validationRules,
                displayOrder: displayOrder,
                isRequired: isRequired,
                isForSegment: isForSegment,
                defaultValue: defaultValue,
                placeholder: placeholder,
                helpText: helpText,
                quantityTypeID: quantityTypeID,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                required String code,
                required String fieldType,
                Value<String?> unit = const Value.absent(),
                Value<String?> validationRules = const Value.absent(),
                required int displayOrder,
                Value<bool> isRequired = const Value.absent(),
                Value<bool> isForSegment = const Value.absent(),
                Value<String?> defaultValue = const Value.absent(),
                Value<String?> placeholder = const Value.absent(),
                Value<String?> helpText = const Value.absent(),
                required int quantityTypeID,
              }) => WorkQuantityFieldsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                code: code,
                fieldType: fieldType,
                unit: unit,
                validationRules: validationRules,
                displayOrder: displayOrder,
                isRequired: isRequired,
                isForSegment: isForSegment,
                defaultValue: defaultValue,
                placeholder: placeholder,
                helpText: helpText,
                quantityTypeID: quantityTypeID,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$WorkQuantityFieldsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $WorkQuantityFieldsTable,
      WorkQuantityFieldRecord,
      $$WorkQuantityFieldsTableFilterComposer,
      $$WorkQuantityFieldsTableOrderingComposer,
      $$WorkQuantityFieldsTableAnnotationComposer,
      $$WorkQuantityFieldsTableCreateCompanionBuilder,
      $$WorkQuantityFieldsTableUpdateCompanionBuilder,
      (
        WorkQuantityFieldRecord,
        BaseReferences<
          _$AppDatabase,
          $WorkQuantityFieldsTable,
          WorkQuantityFieldRecord
        >,
      ),
      WorkQuantityFieldRecord,
      PrefetchHooks Function()
    >;
typedef $$WorkQuantityFieldOptionsTableCreateCompanionBuilder =
    WorkQuantityFieldOptionsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String value,
      required int displayOrder,
      required int fieldID,
    });
typedef $$WorkQuantityFieldOptionsTableUpdateCompanionBuilder =
    WorkQuantityFieldOptionsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> value,
      Value<int> displayOrder,
      Value<int> fieldID,
    });

class $$WorkQuantityFieldOptionsTableFilterComposer
    extends Composer<_$AppDatabase, $WorkQuantityFieldOptionsTable> {
  $$WorkQuantityFieldOptionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fieldID => $composableBuilder(
    column: $table.fieldID,
    builder: (column) => ColumnFilters(column),
  );
}

class $$WorkQuantityFieldOptionsTableOrderingComposer
    extends Composer<_$AppDatabase, $WorkQuantityFieldOptionsTable> {
  $$WorkQuantityFieldOptionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fieldID => $composableBuilder(
    column: $table.fieldID,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$WorkQuantityFieldOptionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $WorkQuantityFieldOptionsTable> {
  $$WorkQuantityFieldOptionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);

  GeneratedColumn<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => column,
  );

  GeneratedColumn<int> get fieldID =>
      $composableBuilder(column: $table.fieldID, builder: (column) => column);
}

class $$WorkQuantityFieldOptionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $WorkQuantityFieldOptionsTable,
          WorkQuantityFieldOptionRecord,
          $$WorkQuantityFieldOptionsTableFilterComposer,
          $$WorkQuantityFieldOptionsTableOrderingComposer,
          $$WorkQuantityFieldOptionsTableAnnotationComposer,
          $$WorkQuantityFieldOptionsTableCreateCompanionBuilder,
          $$WorkQuantityFieldOptionsTableUpdateCompanionBuilder,
          (
            WorkQuantityFieldOptionRecord,
            BaseReferences<
              _$AppDatabase,
              $WorkQuantityFieldOptionsTable,
              WorkQuantityFieldOptionRecord
            >,
          ),
          WorkQuantityFieldOptionRecord,
          PrefetchHooks Function()
        > {
  $$WorkQuantityFieldOptionsTableTableManager(
    _$AppDatabase db,
    $WorkQuantityFieldOptionsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WorkQuantityFieldOptionsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$WorkQuantityFieldOptionsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$WorkQuantityFieldOptionsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> value = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<int> fieldID = const Value.absent(),
              }) => WorkQuantityFieldOptionsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                value: value,
                displayOrder: displayOrder,
                fieldID: fieldID,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String value,
                required int displayOrder,
                required int fieldID,
              }) => WorkQuantityFieldOptionsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                value: value,
                displayOrder: displayOrder,
                fieldID: fieldID,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$WorkQuantityFieldOptionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $WorkQuantityFieldOptionsTable,
      WorkQuantityFieldOptionRecord,
      $$WorkQuantityFieldOptionsTableFilterComposer,
      $$WorkQuantityFieldOptionsTableOrderingComposer,
      $$WorkQuantityFieldOptionsTableAnnotationComposer,
      $$WorkQuantityFieldOptionsTableCreateCompanionBuilder,
      $$WorkQuantityFieldOptionsTableUpdateCompanionBuilder,
      (
        WorkQuantityFieldOptionRecord,
        BaseReferences<
          _$AppDatabase,
          $WorkQuantityFieldOptionsTable,
          WorkQuantityFieldOptionRecord
        >,
      ),
      WorkQuantityFieldOptionRecord,
      PrefetchHooks Function()
    >;
typedef $$WorkScopeEquipmentsTableCreateCompanionBuilder =
    WorkScopeEquipmentsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      required String code,
    });
typedef $$WorkScopeEquipmentsTableUpdateCompanionBuilder =
    WorkScopeEquipmentsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String> code,
    });

class $$WorkScopeEquipmentsTableFilterComposer
    extends Composer<_$AppDatabase, $WorkScopeEquipmentsTable> {
  $$WorkScopeEquipmentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnFilters(column),
  );
}

class $$WorkScopeEquipmentsTableOrderingComposer
    extends Composer<_$AppDatabase, $WorkScopeEquipmentsTable> {
  $$WorkScopeEquipmentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get code => $composableBuilder(
    column: $table.code,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$WorkScopeEquipmentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $WorkScopeEquipmentsTable> {
  $$WorkScopeEquipmentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);
}

class $$WorkScopeEquipmentsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $WorkScopeEquipmentsTable,
          WorkScopeEquipmentsRecord,
          $$WorkScopeEquipmentsTableFilterComposer,
          $$WorkScopeEquipmentsTableOrderingComposer,
          $$WorkScopeEquipmentsTableAnnotationComposer,
          $$WorkScopeEquipmentsTableCreateCompanionBuilder,
          $$WorkScopeEquipmentsTableUpdateCompanionBuilder,
          (
            WorkScopeEquipmentsRecord,
            BaseReferences<
              _$AppDatabase,
              $WorkScopeEquipmentsTable,
              WorkScopeEquipmentsRecord
            >,
          ),
          WorkScopeEquipmentsRecord,
          PrefetchHooks Function()
        > {
  $$WorkScopeEquipmentsTableTableManager(
    _$AppDatabase db,
    $WorkScopeEquipmentsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WorkScopeEquipmentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WorkScopeEquipmentsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$WorkScopeEquipmentsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> code = const Value.absent(),
              }) => WorkScopeEquipmentsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                code: code,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                required String code,
              }) => WorkScopeEquipmentsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                code: code,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$WorkScopeEquipmentsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $WorkScopeEquipmentsTable,
      WorkScopeEquipmentsRecord,
      $$WorkScopeEquipmentsTableFilterComposer,
      $$WorkScopeEquipmentsTableOrderingComposer,
      $$WorkScopeEquipmentsTableAnnotationComposer,
      $$WorkScopeEquipmentsTableCreateCompanionBuilder,
      $$WorkScopeEquipmentsTableUpdateCompanionBuilder,
      (
        WorkScopeEquipmentsRecord,
        BaseReferences<
          _$AppDatabase,
          $WorkScopeEquipmentsTable,
          WorkScopeEquipmentsRecord
        >,
      ),
      WorkScopeEquipmentsRecord,
      PrefetchHooks Function()
    >;
typedef $$WorkScopeEquipmentTableCreateCompanionBuilder =
    WorkScopeEquipmentCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required int workScopeID,
      required int workEquipmentID,
    });
typedef $$WorkScopeEquipmentTableUpdateCompanionBuilder =
    WorkScopeEquipmentCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<int> workScopeID,
      Value<int> workEquipmentID,
    });

class $$WorkScopeEquipmentTableFilterComposer
    extends Composer<_$AppDatabase, $WorkScopeEquipmentTable> {
  $$WorkScopeEquipmentTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get workEquipmentID => $composableBuilder(
    column: $table.workEquipmentID,
    builder: (column) => ColumnFilters(column),
  );
}

class $$WorkScopeEquipmentTableOrderingComposer
    extends Composer<_$AppDatabase, $WorkScopeEquipmentTable> {
  $$WorkScopeEquipmentTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get workEquipmentID => $composableBuilder(
    column: $table.workEquipmentID,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$WorkScopeEquipmentTableAnnotationComposer
    extends Composer<_$AppDatabase, $WorkScopeEquipmentTable> {
  $$WorkScopeEquipmentTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get workEquipmentID => $composableBuilder(
    column: $table.workEquipmentID,
    builder: (column) => column,
  );
}

class $$WorkScopeEquipmentTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $WorkScopeEquipmentTable,
          WorkScopeEquipmentRecord,
          $$WorkScopeEquipmentTableFilterComposer,
          $$WorkScopeEquipmentTableOrderingComposer,
          $$WorkScopeEquipmentTableAnnotationComposer,
          $$WorkScopeEquipmentTableCreateCompanionBuilder,
          $$WorkScopeEquipmentTableUpdateCompanionBuilder,
          (
            WorkScopeEquipmentRecord,
            BaseReferences<
              _$AppDatabase,
              $WorkScopeEquipmentTable,
              WorkScopeEquipmentRecord
            >,
          ),
          WorkScopeEquipmentRecord,
          PrefetchHooks Function()
        > {
  $$WorkScopeEquipmentTableTableManager(
    _$AppDatabase db,
    $WorkScopeEquipmentTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WorkScopeEquipmentTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WorkScopeEquipmentTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WorkScopeEquipmentTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<int> workScopeID = const Value.absent(),
                Value<int> workEquipmentID = const Value.absent(),
              }) => WorkScopeEquipmentCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                workScopeID: workScopeID,
                workEquipmentID: workEquipmentID,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required int workScopeID,
                required int workEquipmentID,
              }) => WorkScopeEquipmentCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                workScopeID: workScopeID,
                workEquipmentID: workEquipmentID,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$WorkScopeEquipmentTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $WorkScopeEquipmentTable,
      WorkScopeEquipmentRecord,
      $$WorkScopeEquipmentTableFilterComposer,
      $$WorkScopeEquipmentTableOrderingComposer,
      $$WorkScopeEquipmentTableAnnotationComposer,
      $$WorkScopeEquipmentTableCreateCompanionBuilder,
      $$WorkScopeEquipmentTableUpdateCompanionBuilder,
      (
        WorkScopeEquipmentRecord,
        BaseReferences<
          _$AppDatabase,
          $WorkScopeEquipmentTable,
          WorkScopeEquipmentRecord
        >,
      ),
      WorkScopeEquipmentRecord,
      PrefetchHooks Function()
    >;
typedef $$CountriesTableCreateCompanionBuilder =
    CountriesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$CountriesTableUpdateCompanionBuilder =
    CountriesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$CountriesTableFilterComposer
    extends Composer<_$AppDatabase, $CountriesTable> {
  $$CountriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$CountriesTableOrderingComposer
    extends Composer<_$AppDatabase, $CountriesTable> {
  $$CountriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CountriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $CountriesTable> {
  $$CountriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$CountriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CountriesTable,
          CountryRecord,
          $$CountriesTableFilterComposer,
          $$CountriesTableOrderingComposer,
          $$CountriesTableAnnotationComposer,
          $$CountriesTableCreateCompanionBuilder,
          $$CountriesTableUpdateCompanionBuilder,
          (
            CountryRecord,
            BaseReferences<_$AppDatabase, $CountriesTable, CountryRecord>,
          ),
          CountryRecord,
          PrefetchHooks Function()
        > {
  $$CountriesTableTableManager(_$AppDatabase db, $CountriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CountriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CountriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CountriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => CountriesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => CountriesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$CountriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CountriesTable,
      CountryRecord,
      $$CountriesTableFilterComposer,
      $$CountriesTableOrderingComposer,
      $$CountriesTableAnnotationComposer,
      $$CountriesTableCreateCompanionBuilder,
      $$CountriesTableUpdateCompanionBuilder,
      (
        CountryRecord,
        BaseReferences<_$AppDatabase, $CountriesTable, CountryRecord>,
      ),
      CountryRecord,
      PrefetchHooks Function()
    >;
typedef $$ProvincesTableCreateCompanionBuilder =
    ProvincesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      required int countryID,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$ProvincesTableUpdateCompanionBuilder =
    ProvincesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<int> countryID,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$ProvincesTableFilterComposer
    extends Composer<_$AppDatabase, $ProvincesTable> {
  $$ProvincesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get countryID => $composableBuilder(
    column: $table.countryID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ProvincesTableOrderingComposer
    extends Composer<_$AppDatabase, $ProvincesTable> {
  $$ProvincesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get countryID => $composableBuilder(
    column: $table.countryID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ProvincesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ProvincesTable> {
  $$ProvincesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get countryID =>
      $composableBuilder(column: $table.countryID, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ProvincesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ProvincesTable,
          ProvinceRecord,
          $$ProvincesTableFilterComposer,
          $$ProvincesTableOrderingComposer,
          $$ProvincesTableAnnotationComposer,
          $$ProvincesTableCreateCompanionBuilder,
          $$ProvincesTableUpdateCompanionBuilder,
          (
            ProvinceRecord,
            BaseReferences<_$AppDatabase, $ProvincesTable, ProvinceRecord>,
          ),
          ProvinceRecord,
          PrefetchHooks Function()
        > {
  $$ProvincesTableTableManager(_$AppDatabase db, $ProvincesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ProvincesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ProvincesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ProvincesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> countryID = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => ProvincesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                countryID: countryID,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                required int countryID,
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => ProvincesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                countryID: countryID,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ProvincesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ProvincesTable,
      ProvinceRecord,
      $$ProvincesTableFilterComposer,
      $$ProvincesTableOrderingComposer,
      $$ProvincesTableAnnotationComposer,
      $$ProvincesTableCreateCompanionBuilder,
      $$ProvincesTableUpdateCompanionBuilder,
      (
        ProvinceRecord,
        BaseReferences<_$AppDatabase, $ProvincesTable, ProvinceRecord>,
      ),
      ProvinceRecord,
      PrefetchHooks Function()
    >;
typedef $$DistrictsTableCreateCompanionBuilder =
    DistrictsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      required int stateId,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$DistrictsTableUpdateCompanionBuilder =
    DistrictsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<int> stateId,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$DistrictsTableFilterComposer
    extends Composer<_$AppDatabase, $DistrictsTable> {
  $$DistrictsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get stateId => $composableBuilder(
    column: $table.stateId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$DistrictsTableOrderingComposer
    extends Composer<_$AppDatabase, $DistrictsTable> {
  $$DistrictsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get stateId => $composableBuilder(
    column: $table.stateId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$DistrictsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DistrictsTable> {
  $$DistrictsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get stateId =>
      $composableBuilder(column: $table.stateId, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$DistrictsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DistrictsTable,
          DistrictRecord,
          $$DistrictsTableFilterComposer,
          $$DistrictsTableOrderingComposer,
          $$DistrictsTableAnnotationComposer,
          $$DistrictsTableCreateCompanionBuilder,
          $$DistrictsTableUpdateCompanionBuilder,
          (
            DistrictRecord,
            BaseReferences<_$AppDatabase, $DistrictsTable, DistrictRecord>,
          ),
          DistrictRecord,
          PrefetchHooks Function()
        > {
  $$DistrictsTableTableManager(_$AppDatabase db, $DistrictsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DistrictsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DistrictsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DistrictsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> stateId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => DistrictsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                stateId: stateId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                required int stateId,
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => DistrictsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                stateId: stateId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$DistrictsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DistrictsTable,
      DistrictRecord,
      $$DistrictsTableFilterComposer,
      $$DistrictsTableOrderingComposer,
      $$DistrictsTableAnnotationComposer,
      $$DistrictsTableCreateCompanionBuilder,
      $$DistrictsTableUpdateCompanionBuilder,
      (
        DistrictRecord,
        BaseReferences<_$AppDatabase, $DistrictsTable, DistrictRecord>,
      ),
      DistrictRecord,
      PrefetchHooks Function()
    >;
typedef $$RoadCategoriesTableCreateCompanionBuilder =
    RoadCategoriesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$RoadCategoriesTableUpdateCompanionBuilder =
    RoadCategoriesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$RoadCategoriesTableFilterComposer
    extends Composer<_$AppDatabase, $RoadCategoriesTable> {
  $$RoadCategoriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$RoadCategoriesTableOrderingComposer
    extends Composer<_$AppDatabase, $RoadCategoriesTable> {
  $$RoadCategoriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RoadCategoriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RoadCategoriesTable> {
  $$RoadCategoriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$RoadCategoriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RoadCategoriesTable,
          RoadCategoryRecord,
          $$RoadCategoriesTableFilterComposer,
          $$RoadCategoriesTableOrderingComposer,
          $$RoadCategoriesTableAnnotationComposer,
          $$RoadCategoriesTableCreateCompanionBuilder,
          $$RoadCategoriesTableUpdateCompanionBuilder,
          (
            RoadCategoryRecord,
            BaseReferences<
              _$AppDatabase,
              $RoadCategoriesTable,
              RoadCategoryRecord
            >,
          ),
          RoadCategoryRecord,
          PrefetchHooks Function()
        > {
  $$RoadCategoriesTableTableManager(
    _$AppDatabase db,
    $RoadCategoriesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RoadCategoriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RoadCategoriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RoadCategoriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => RoadCategoriesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => RoadCategoriesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$RoadCategoriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RoadCategoriesTable,
      RoadCategoryRecord,
      $$RoadCategoriesTableFilterComposer,
      $$RoadCategoriesTableOrderingComposer,
      $$RoadCategoriesTableAnnotationComposer,
      $$RoadCategoriesTableCreateCompanionBuilder,
      $$RoadCategoriesTableUpdateCompanionBuilder,
      (
        RoadCategoryRecord,
        BaseReferences<_$AppDatabase, $RoadCategoriesTable, RoadCategoryRecord>,
      ),
      RoadCategoryRecord,
      PrefetchHooks Function()
    >;
typedef $$RoadsTableCreateCompanionBuilder =
    RoadsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      Value<String?> roadNo,
      Value<double?> sectionStart,
      Value<double?> sectionFinish,
      Value<int?> mainCategoryId,
      Value<int?> secondaryCategoryId,
      required int districtId,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$RoadsTableUpdateCompanionBuilder =
    RoadsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String?> roadNo,
      Value<double?> sectionStart,
      Value<double?> sectionFinish,
      Value<int?> mainCategoryId,
      Value<int?> secondaryCategoryId,
      Value<int> districtId,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$RoadsTableFilterComposer extends Composer<_$AppDatabase, $RoadsTable> {
  $$RoadsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roadNo => $composableBuilder(
    column: $table.roadNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sectionStart => $composableBuilder(
    column: $table.sectionStart,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sectionFinish => $composableBuilder(
    column: $table.sectionFinish,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mainCategoryId => $composableBuilder(
    column: $table.mainCategoryId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get secondaryCategoryId => $composableBuilder(
    column: $table.secondaryCategoryId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get districtId => $composableBuilder(
    column: $table.districtId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$RoadsTableOrderingComposer
    extends Composer<_$AppDatabase, $RoadsTable> {
  $$RoadsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roadNo => $composableBuilder(
    column: $table.roadNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sectionStart => $composableBuilder(
    column: $table.sectionStart,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sectionFinish => $composableBuilder(
    column: $table.sectionFinish,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mainCategoryId => $composableBuilder(
    column: $table.mainCategoryId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get secondaryCategoryId => $composableBuilder(
    column: $table.secondaryCategoryId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get districtId => $composableBuilder(
    column: $table.districtId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$RoadsTableAnnotationComposer
    extends Composer<_$AppDatabase, $RoadsTable> {
  $$RoadsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get roadNo =>
      $composableBuilder(column: $table.roadNo, builder: (column) => column);

  GeneratedColumn<double> get sectionStart => $composableBuilder(
    column: $table.sectionStart,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sectionFinish => $composableBuilder(
    column: $table.sectionFinish,
    builder: (column) => column,
  );

  GeneratedColumn<int> get mainCategoryId => $composableBuilder(
    column: $table.mainCategoryId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get secondaryCategoryId => $composableBuilder(
    column: $table.secondaryCategoryId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get districtId => $composableBuilder(
    column: $table.districtId,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$RoadsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RoadsTable,
          RoadRecord,
          $$RoadsTableFilterComposer,
          $$RoadsTableOrderingComposer,
          $$RoadsTableAnnotationComposer,
          $$RoadsTableCreateCompanionBuilder,
          $$RoadsTableUpdateCompanionBuilder,
          (RoadRecord, BaseReferences<_$AppDatabase, $RoadsTable, RoadRecord>),
          RoadRecord,
          PrefetchHooks Function()
        > {
  $$RoadsTableTableManager(_$AppDatabase db, $RoadsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RoadsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RoadsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RoadsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> roadNo = const Value.absent(),
                Value<double?> sectionStart = const Value.absent(),
                Value<double?> sectionFinish = const Value.absent(),
                Value<int?> mainCategoryId = const Value.absent(),
                Value<int?> secondaryCategoryId = const Value.absent(),
                Value<int> districtId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => RoadsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                roadNo: roadNo,
                sectionStart: sectionStart,
                sectionFinish: sectionFinish,
                mainCategoryId: mainCategoryId,
                secondaryCategoryId: secondaryCategoryId,
                districtId: districtId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                Value<String?> roadNo = const Value.absent(),
                Value<double?> sectionStart = const Value.absent(),
                Value<double?> sectionFinish = const Value.absent(),
                Value<int?> mainCategoryId = const Value.absent(),
                Value<int?> secondaryCategoryId = const Value.absent(),
                required int districtId,
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => RoadsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                roadNo: roadNo,
                sectionStart: sectionStart,
                sectionFinish: sectionFinish,
                mainCategoryId: mainCategoryId,
                secondaryCategoryId: secondaryCategoryId,
                districtId: districtId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$RoadsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RoadsTable,
      RoadRecord,
      $$RoadsTableFilterComposer,
      $$RoadsTableOrderingComposer,
      $$RoadsTableAnnotationComposer,
      $$RoadsTableCreateCompanionBuilder,
      $$RoadsTableUpdateCompanionBuilder,
      (RoadRecord, BaseReferences<_$AppDatabase, $RoadsTable, RoadRecord>),
      RoadRecord,
      PrefetchHooks Function()
    >;
typedef $$PackagesTableCreateCompanionBuilder =
    PackagesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      Value<String?> description,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$PackagesTableUpdateCompanionBuilder =
    PackagesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String?> description,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$PackagesTableFilterComposer
    extends Composer<_$AppDatabase, $PackagesTable> {
  $$PackagesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$PackagesTableOrderingComposer
    extends Composer<_$AppDatabase, $PackagesTable> {
  $$PackagesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PackagesTableAnnotationComposer
    extends Composer<_$AppDatabase, $PackagesTable> {
  $$PackagesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$PackagesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PackagesTable,
          PackageRecord,
          $$PackagesTableFilterComposer,
          $$PackagesTableOrderingComposer,
          $$PackagesTableAnnotationComposer,
          $$PackagesTableCreateCompanionBuilder,
          $$PackagesTableUpdateCompanionBuilder,
          (
            PackageRecord,
            BaseReferences<_$AppDatabase, $PackagesTable, PackageRecord>,
          ),
          PackageRecord,
          PrefetchHooks Function()
        > {
  $$PackagesTableTableManager(_$AppDatabase db, $PackagesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PackagesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PackagesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PackagesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => PackagesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                description: description,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                Value<String?> description = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => PackagesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                description: description,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$PackagesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PackagesTable,
      PackageRecord,
      $$PackagesTableFilterComposer,
      $$PackagesTableOrderingComposer,
      $$PackagesTableAnnotationComposer,
      $$PackagesTableCreateCompanionBuilder,
      $$PackagesTableUpdateCompanionBuilder,
      (
        PackageRecord,
        BaseReferences<_$AppDatabase, $PackagesTable, PackageRecord>,
      ),
      PackageRecord,
      PrefetchHooks Function()
    >;
typedef $$PackageRoadsTableCreateCompanionBuilder =
    PackageRoadsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String roadUID,
      Value<double?> sectionStart,
      Value<double?> sectionFinish,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$PackageRoadsTableUpdateCompanionBuilder =
    PackageRoadsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> roadUID,
      Value<double?> sectionStart,
      Value<double?> sectionFinish,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$PackageRoadsTableFilterComposer
    extends Composer<_$AppDatabase, $PackageRoadsTable> {
  $$PackageRoadsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roadUID => $composableBuilder(
    column: $table.roadUID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sectionStart => $composableBuilder(
    column: $table.sectionStart,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sectionFinish => $composableBuilder(
    column: $table.sectionFinish,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$PackageRoadsTableOrderingComposer
    extends Composer<_$AppDatabase, $PackageRoadsTable> {
  $$PackageRoadsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roadUID => $composableBuilder(
    column: $table.roadUID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sectionStart => $composableBuilder(
    column: $table.sectionStart,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sectionFinish => $composableBuilder(
    column: $table.sectionFinish,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PackageRoadsTableAnnotationComposer
    extends Composer<_$AppDatabase, $PackageRoadsTable> {
  $$PackageRoadsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get roadUID =>
      $composableBuilder(column: $table.roadUID, builder: (column) => column);

  GeneratedColumn<double> get sectionStart => $composableBuilder(
    column: $table.sectionStart,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sectionFinish => $composableBuilder(
    column: $table.sectionFinish,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$PackageRoadsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PackageRoadsTable,
          PackageRoadRecord,
          $$PackageRoadsTableFilterComposer,
          $$PackageRoadsTableOrderingComposer,
          $$PackageRoadsTableAnnotationComposer,
          $$PackageRoadsTableCreateCompanionBuilder,
          $$PackageRoadsTableUpdateCompanionBuilder,
          (
            PackageRoadRecord,
            BaseReferences<
              _$AppDatabase,
              $PackageRoadsTable,
              PackageRoadRecord
            >,
          ),
          PackageRoadRecord,
          PrefetchHooks Function()
        > {
  $$PackageRoadsTableTableManager(_$AppDatabase db, $PackageRoadsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PackageRoadsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PackageRoadsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PackageRoadsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> roadUID = const Value.absent(),
                Value<double?> sectionStart = const Value.absent(),
                Value<double?> sectionFinish = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => PackageRoadsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                roadUID: roadUID,
                sectionStart: sectionStart,
                sectionFinish: sectionFinish,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String roadUID,
                Value<double?> sectionStart = const Value.absent(),
                Value<double?> sectionFinish = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => PackageRoadsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                roadUID: roadUID,
                sectionStart: sectionStart,
                sectionFinish: sectionFinish,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$PackageRoadsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PackageRoadsTable,
      PackageRoadRecord,
      $$PackageRoadsTableFilterComposer,
      $$PackageRoadsTableOrderingComposer,
      $$PackageRoadsTableAnnotationComposer,
      $$PackageRoadsTableCreateCompanionBuilder,
      $$PackageRoadsTableUpdateCompanionBuilder,
      (
        PackageRoadRecord,
        BaseReferences<_$AppDatabase, $PackageRoadsTable, PackageRoadRecord>,
      ),
      PackageRoadRecord,
      PrefetchHooks Function()
    >;
typedef $$DailyReportsTableCreateCompanionBuilder =
    DailyReportsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String uid,
      required String name,
      Value<String?> notes,
      required String weatherCondition,
      Value<bool> workPerformed,
      Value<double?> longitude,
      Value<double?> latitude,
      required int companyID,
      Value<int?> contractRelationID,
      Value<String> status,
      Value<int?> approvedByID,
      Value<DateTime?> approvedAt,
      Value<String?> rejectionReason,
      required int workScopeID,
      required int roadID,
      Value<int?> totalWorkers,
      Value<double?> fromSection,
      Value<double?> toSection,
      required int createdByID,
      required DateTime createdAt,
      required DateTime updatedAt,
      Value<String?> workScopeData,
      Value<String?> roadData,
      Value<String?> equipmentsData,
      Value<String?> reportQuantitiesData,
    });
typedef $$DailyReportsTableUpdateCompanionBuilder =
    DailyReportsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> uid,
      Value<String> name,
      Value<String?> notes,
      Value<String> weatherCondition,
      Value<bool> workPerformed,
      Value<double?> longitude,
      Value<double?> latitude,
      Value<int> companyID,
      Value<int?> contractRelationID,
      Value<String> status,
      Value<int?> approvedByID,
      Value<DateTime?> approvedAt,
      Value<String?> rejectionReason,
      Value<int> workScopeID,
      Value<int> roadID,
      Value<int?> totalWorkers,
      Value<double?> fromSection,
      Value<double?> toSection,
      Value<int> createdByID,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<String?> workScopeData,
      Value<String?> roadData,
      Value<String?> equipmentsData,
      Value<String?> reportQuantitiesData,
    });

class $$DailyReportsTableFilterComposer
    extends Composer<_$AppDatabase, $DailyReportsTable> {
  $$DailyReportsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get weatherCondition => $composableBuilder(
    column: $table.weatherCondition,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get workPerformed => $composableBuilder(
    column: $table.workPerformed,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get companyID => $composableBuilder(
    column: $table.companyID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get contractRelationID => $composableBuilder(
    column: $table.contractRelationID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get approvedByID => $composableBuilder(
    column: $table.approvedByID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get approvedAt => $composableBuilder(
    column: $table.approvedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get rejectionReason => $composableBuilder(
    column: $table.rejectionReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get roadID => $composableBuilder(
    column: $table.roadID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalWorkers => $composableBuilder(
    column: $table.totalWorkers,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get fromSection => $composableBuilder(
    column: $table.fromSection,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get toSection => $composableBuilder(
    column: $table.toSection,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdByID => $composableBuilder(
    column: $table.createdByID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get workScopeData => $composableBuilder(
    column: $table.workScopeData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get roadData => $composableBuilder(
    column: $table.roadData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get equipmentsData => $composableBuilder(
    column: $table.equipmentsData,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reportQuantitiesData => $composableBuilder(
    column: $table.reportQuantitiesData,
    builder: (column) => ColumnFilters(column),
  );
}

class $$DailyReportsTableOrderingComposer
    extends Composer<_$AppDatabase, $DailyReportsTable> {
  $$DailyReportsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uid => $composableBuilder(
    column: $table.uid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get weatherCondition => $composableBuilder(
    column: $table.weatherCondition,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get workPerformed => $composableBuilder(
    column: $table.workPerformed,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get companyID => $composableBuilder(
    column: $table.companyID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get contractRelationID => $composableBuilder(
    column: $table.contractRelationID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get approvedByID => $composableBuilder(
    column: $table.approvedByID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get approvedAt => $composableBuilder(
    column: $table.approvedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get rejectionReason => $composableBuilder(
    column: $table.rejectionReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get roadID => $composableBuilder(
    column: $table.roadID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalWorkers => $composableBuilder(
    column: $table.totalWorkers,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get fromSection => $composableBuilder(
    column: $table.fromSection,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get toSection => $composableBuilder(
    column: $table.toSection,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdByID => $composableBuilder(
    column: $table.createdByID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get workScopeData => $composableBuilder(
    column: $table.workScopeData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get roadData => $composableBuilder(
    column: $table.roadData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get equipmentsData => $composableBuilder(
    column: $table.equipmentsData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reportQuantitiesData => $composableBuilder(
    column: $table.reportQuantitiesData,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$DailyReportsTableAnnotationComposer
    extends Composer<_$AppDatabase, $DailyReportsTable> {
  $$DailyReportsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uid =>
      $composableBuilder(column: $table.uid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get weatherCondition => $composableBuilder(
    column: $table.weatherCondition,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get workPerformed => $composableBuilder(
    column: $table.workPerformed,
    builder: (column) => column,
  );

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<int> get companyID =>
      $composableBuilder(column: $table.companyID, builder: (column) => column);

  GeneratedColumn<int> get contractRelationID => $composableBuilder(
    column: $table.contractRelationID,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get approvedByID => $composableBuilder(
    column: $table.approvedByID,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get approvedAt => $composableBuilder(
    column: $table.approvedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get rejectionReason => $composableBuilder(
    column: $table.rejectionReason,
    builder: (column) => column,
  );

  GeneratedColumn<int> get workScopeID => $composableBuilder(
    column: $table.workScopeID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get roadID =>
      $composableBuilder(column: $table.roadID, builder: (column) => column);

  GeneratedColumn<int> get totalWorkers => $composableBuilder(
    column: $table.totalWorkers,
    builder: (column) => column,
  );

  GeneratedColumn<double> get fromSection => $composableBuilder(
    column: $table.fromSection,
    builder: (column) => column,
  );

  GeneratedColumn<double> get toSection =>
      $composableBuilder(column: $table.toSection, builder: (column) => column);

  GeneratedColumn<int> get createdByID => $composableBuilder(
    column: $table.createdByID,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<String> get workScopeData => $composableBuilder(
    column: $table.workScopeData,
    builder: (column) => column,
  );

  GeneratedColumn<String> get roadData =>
      $composableBuilder(column: $table.roadData, builder: (column) => column);

  GeneratedColumn<String> get equipmentsData => $composableBuilder(
    column: $table.equipmentsData,
    builder: (column) => column,
  );

  GeneratedColumn<String> get reportQuantitiesData => $composableBuilder(
    column: $table.reportQuantitiesData,
    builder: (column) => column,
  );
}

class $$DailyReportsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $DailyReportsTable,
          DailyReportRecord,
          $$DailyReportsTableFilterComposer,
          $$DailyReportsTableOrderingComposer,
          $$DailyReportsTableAnnotationComposer,
          $$DailyReportsTableCreateCompanionBuilder,
          $$DailyReportsTableUpdateCompanionBuilder,
          (
            DailyReportRecord,
            BaseReferences<
              _$AppDatabase,
              $DailyReportsTable,
              DailyReportRecord
            >,
          ),
          DailyReportRecord,
          PrefetchHooks Function()
        > {
  $$DailyReportsTableTableManager(_$AppDatabase db, $DailyReportsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$DailyReportsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$DailyReportsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$DailyReportsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> uid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String> weatherCondition = const Value.absent(),
                Value<bool> workPerformed = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                Value<int> companyID = const Value.absent(),
                Value<int?> contractRelationID = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<int?> approvedByID = const Value.absent(),
                Value<DateTime?> approvedAt = const Value.absent(),
                Value<String?> rejectionReason = const Value.absent(),
                Value<int> workScopeID = const Value.absent(),
                Value<int> roadID = const Value.absent(),
                Value<int?> totalWorkers = const Value.absent(),
                Value<double?> fromSection = const Value.absent(),
                Value<double?> toSection = const Value.absent(),
                Value<int> createdByID = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<String?> workScopeData = const Value.absent(),
                Value<String?> roadData = const Value.absent(),
                Value<String?> equipmentsData = const Value.absent(),
                Value<String?> reportQuantitiesData = const Value.absent(),
              }) => DailyReportsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                notes: notes,
                weatherCondition: weatherCondition,
                workPerformed: workPerformed,
                longitude: longitude,
                latitude: latitude,
                companyID: companyID,
                contractRelationID: contractRelationID,
                status: status,
                approvedByID: approvedByID,
                approvedAt: approvedAt,
                rejectionReason: rejectionReason,
                workScopeID: workScopeID,
                roadID: roadID,
                totalWorkers: totalWorkers,
                fromSection: fromSection,
                toSection: toSection,
                createdByID: createdByID,
                createdAt: createdAt,
                updatedAt: updatedAt,
                workScopeData: workScopeData,
                roadData: roadData,
                equipmentsData: equipmentsData,
                reportQuantitiesData: reportQuantitiesData,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String uid,
                required String name,
                Value<String?> notes = const Value.absent(),
                required String weatherCondition,
                Value<bool> workPerformed = const Value.absent(),
                Value<double?> longitude = const Value.absent(),
                Value<double?> latitude = const Value.absent(),
                required int companyID,
                Value<int?> contractRelationID = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<int?> approvedByID = const Value.absent(),
                Value<DateTime?> approvedAt = const Value.absent(),
                Value<String?> rejectionReason = const Value.absent(),
                required int workScopeID,
                required int roadID,
                Value<int?> totalWorkers = const Value.absent(),
                Value<double?> fromSection = const Value.absent(),
                Value<double?> toSection = const Value.absent(),
                required int createdByID,
                required DateTime createdAt,
                required DateTime updatedAt,
                Value<String?> workScopeData = const Value.absent(),
                Value<String?> roadData = const Value.absent(),
                Value<String?> equipmentsData = const Value.absent(),
                Value<String?> reportQuantitiesData = const Value.absent(),
              }) => DailyReportsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                uid: uid,
                name: name,
                notes: notes,
                weatherCondition: weatherCondition,
                workPerformed: workPerformed,
                longitude: longitude,
                latitude: latitude,
                companyID: companyID,
                contractRelationID: contractRelationID,
                status: status,
                approvedByID: approvedByID,
                approvedAt: approvedAt,
                rejectionReason: rejectionReason,
                workScopeID: workScopeID,
                roadID: roadID,
                totalWorkers: totalWorkers,
                fromSection: fromSection,
                toSection: toSection,
                createdByID: createdByID,
                createdAt: createdAt,
                updatedAt: updatedAt,
                workScopeData: workScopeData,
                roadData: roadData,
                equipmentsData: equipmentsData,
                reportQuantitiesData: reportQuantitiesData,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$DailyReportsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $DailyReportsTable,
      DailyReportRecord,
      $$DailyReportsTableFilterComposer,
      $$DailyReportsTableOrderingComposer,
      $$DailyReportsTableAnnotationComposer,
      $$DailyReportsTableCreateCompanionBuilder,
      $$DailyReportsTableUpdateCompanionBuilder,
      (
        DailyReportRecord,
        BaseReferences<_$AppDatabase, $DailyReportsTable, DailyReportRecord>,
      ),
      DailyReportRecord,
      PrefetchHooks Function()
    >;
typedef $$ReportEquipmentsTableCreateCompanionBuilder =
    ReportEquipmentsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String reportType,
      Value<int?> dailyReportID,
      required int workEquipmentID,
      required int addedByID,
      required DateTime createdAt,
    });
typedef $$ReportEquipmentsTableUpdateCompanionBuilder =
    ReportEquipmentsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> reportType,
      Value<int?> dailyReportID,
      Value<int> workEquipmentID,
      Value<int> addedByID,
      Value<DateTime> createdAt,
    });

class $$ReportEquipmentsTableFilterComposer
    extends Composer<_$AppDatabase, $ReportEquipmentsTable> {
  $$ReportEquipmentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reportType => $composableBuilder(
    column: $table.reportType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get workEquipmentID => $composableBuilder(
    column: $table.workEquipmentID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get addedByID => $composableBuilder(
    column: $table.addedByID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ReportEquipmentsTableOrderingComposer
    extends Composer<_$AppDatabase, $ReportEquipmentsTable> {
  $$ReportEquipmentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reportType => $composableBuilder(
    column: $table.reportType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get workEquipmentID => $composableBuilder(
    column: $table.workEquipmentID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get addedByID => $composableBuilder(
    column: $table.addedByID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ReportEquipmentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ReportEquipmentsTable> {
  $$ReportEquipmentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get reportType => $composableBuilder(
    column: $table.reportType,
    builder: (column) => column,
  );

  GeneratedColumn<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get workEquipmentID => $composableBuilder(
    column: $table.workEquipmentID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get addedByID =>
      $composableBuilder(column: $table.addedByID, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$ReportEquipmentsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ReportEquipmentsTable,
          ReportEquipmentRecord,
          $$ReportEquipmentsTableFilterComposer,
          $$ReportEquipmentsTableOrderingComposer,
          $$ReportEquipmentsTableAnnotationComposer,
          $$ReportEquipmentsTableCreateCompanionBuilder,
          $$ReportEquipmentsTableUpdateCompanionBuilder,
          (
            ReportEquipmentRecord,
            BaseReferences<
              _$AppDatabase,
              $ReportEquipmentsTable,
              ReportEquipmentRecord
            >,
          ),
          ReportEquipmentRecord,
          PrefetchHooks Function()
        > {
  $$ReportEquipmentsTableTableManager(
    _$AppDatabase db,
    $ReportEquipmentsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReportEquipmentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReportEquipmentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReportEquipmentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> reportType = const Value.absent(),
                Value<int?> dailyReportID = const Value.absent(),
                Value<int> workEquipmentID = const Value.absent(),
                Value<int> addedByID = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
              }) => ReportEquipmentsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                reportType: reportType,
                dailyReportID: dailyReportID,
                workEquipmentID: workEquipmentID,
                addedByID: addedByID,
                createdAt: createdAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String reportType,
                Value<int?> dailyReportID = const Value.absent(),
                required int workEquipmentID,
                required int addedByID,
                required DateTime createdAt,
              }) => ReportEquipmentsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                reportType: reportType,
                dailyReportID: dailyReportID,
                workEquipmentID: workEquipmentID,
                addedByID: addedByID,
                createdAt: createdAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ReportEquipmentsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ReportEquipmentsTable,
      ReportEquipmentRecord,
      $$ReportEquipmentsTableFilterComposer,
      $$ReportEquipmentsTableOrderingComposer,
      $$ReportEquipmentsTableAnnotationComposer,
      $$ReportEquipmentsTableCreateCompanionBuilder,
      $$ReportEquipmentsTableUpdateCompanionBuilder,
      (
        ReportEquipmentRecord,
        BaseReferences<
          _$AppDatabase,
          $ReportEquipmentsTable,
          ReportEquipmentRecord
        >,
      ),
      ReportEquipmentRecord,
      PrefetchHooks Function()
    >;
typedef $$ReportQuantitiesTableCreateCompanionBuilder =
    ReportQuantitiesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required String reportType,
      Value<int?> dailyReportID,
      required int quantityTypeID,
      Value<int> sequenceNo,
      Value<double?> totalLength,
      Value<String?> notes,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$ReportQuantitiesTableUpdateCompanionBuilder =
    ReportQuantitiesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<String> reportType,
      Value<int?> dailyReportID,
      Value<int> quantityTypeID,
      Value<int> sequenceNo,
      Value<double?> totalLength,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$ReportQuantitiesTableFilterComposer
    extends Composer<_$AppDatabase, $ReportQuantitiesTable> {
  $$ReportQuantitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reportType => $composableBuilder(
    column: $table.reportType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantityTypeID => $composableBuilder(
    column: $table.quantityTypeID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get sequenceNo => $composableBuilder(
    column: $table.sequenceNo,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get totalLength => $composableBuilder(
    column: $table.totalLength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ReportQuantitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $ReportQuantitiesTable> {
  $$ReportQuantitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reportType => $composableBuilder(
    column: $table.reportType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantityTypeID => $composableBuilder(
    column: $table.quantityTypeID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get sequenceNo => $composableBuilder(
    column: $table.sequenceNo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get totalLength => $composableBuilder(
    column: $table.totalLength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ReportQuantitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ReportQuantitiesTable> {
  $$ReportQuantitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get reportType => $composableBuilder(
    column: $table.reportType,
    builder: (column) => column,
  );

  GeneratedColumn<int> get dailyReportID => $composableBuilder(
    column: $table.dailyReportID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get quantityTypeID => $composableBuilder(
    column: $table.quantityTypeID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get sequenceNo => $composableBuilder(
    column: $table.sequenceNo,
    builder: (column) => column,
  );

  GeneratedColumn<double> get totalLength => $composableBuilder(
    column: $table.totalLength,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ReportQuantitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ReportQuantitiesTable,
          ReportQuantityRecord,
          $$ReportQuantitiesTableFilterComposer,
          $$ReportQuantitiesTableOrderingComposer,
          $$ReportQuantitiesTableAnnotationComposer,
          $$ReportQuantitiesTableCreateCompanionBuilder,
          $$ReportQuantitiesTableUpdateCompanionBuilder,
          (
            ReportQuantityRecord,
            BaseReferences<
              _$AppDatabase,
              $ReportQuantitiesTable,
              ReportQuantityRecord
            >,
          ),
          ReportQuantityRecord,
          PrefetchHooks Function()
        > {
  $$ReportQuantitiesTableTableManager(
    _$AppDatabase db,
    $ReportQuantitiesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReportQuantitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReportQuantitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReportQuantitiesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<String> reportType = const Value.absent(),
                Value<int?> dailyReportID = const Value.absent(),
                Value<int> quantityTypeID = const Value.absent(),
                Value<int> sequenceNo = const Value.absent(),
                Value<double?> totalLength = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => ReportQuantitiesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                reportType: reportType,
                dailyReportID: dailyReportID,
                quantityTypeID: quantityTypeID,
                sequenceNo: sequenceNo,
                totalLength: totalLength,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required String reportType,
                Value<int?> dailyReportID = const Value.absent(),
                required int quantityTypeID,
                Value<int> sequenceNo = const Value.absent(),
                Value<double?> totalLength = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => ReportQuantitiesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                reportType: reportType,
                dailyReportID: dailyReportID,
                quantityTypeID: quantityTypeID,
                sequenceNo: sequenceNo,
                totalLength: totalLength,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ReportQuantitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ReportQuantitiesTable,
      ReportQuantityRecord,
      $$ReportQuantitiesTableFilterComposer,
      $$ReportQuantitiesTableOrderingComposer,
      $$ReportQuantitiesTableAnnotationComposer,
      $$ReportQuantitiesTableCreateCompanionBuilder,
      $$ReportQuantitiesTableUpdateCompanionBuilder,
      (
        ReportQuantityRecord,
        BaseReferences<
          _$AppDatabase,
          $ReportQuantitiesTable,
          ReportQuantityRecord
        >,
      ),
      ReportQuantityRecord,
      PrefetchHooks Function()
    >;
typedef $$ReportQuantityValuesTableCreateCompanionBuilder =
    ReportQuantityValuesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<int?> reportQuantityID,
      Value<int?> segmentID,
      required int quantityFieldID,
      required String value,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$ReportQuantityValuesTableUpdateCompanionBuilder =
    ReportQuantityValuesCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<int?> reportQuantityID,
      Value<int?> segmentID,
      Value<int> quantityFieldID,
      Value<String> value,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$ReportQuantityValuesTableFilterComposer
    extends Composer<_$AppDatabase, $ReportQuantityValuesTable> {
  $$ReportQuantityValuesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get reportQuantityID => $composableBuilder(
    column: $table.reportQuantityID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get segmentID => $composableBuilder(
    column: $table.segmentID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantityFieldID => $composableBuilder(
    column: $table.quantityFieldID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ReportQuantityValuesTableOrderingComposer
    extends Composer<_$AppDatabase, $ReportQuantityValuesTable> {
  $$ReportQuantityValuesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get reportQuantityID => $composableBuilder(
    column: $table.reportQuantityID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get segmentID => $composableBuilder(
    column: $table.segmentID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantityFieldID => $composableBuilder(
    column: $table.quantityFieldID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ReportQuantityValuesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ReportQuantityValuesTable> {
  $$ReportQuantityValuesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get reportQuantityID => $composableBuilder(
    column: $table.reportQuantityID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get segmentID =>
      $composableBuilder(column: $table.segmentID, builder: (column) => column);

  GeneratedColumn<int> get quantityFieldID => $composableBuilder(
    column: $table.quantityFieldID,
    builder: (column) => column,
  );

  GeneratedColumn<String> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ReportQuantityValuesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ReportQuantityValuesTable,
          ReportQuantityValueRecord,
          $$ReportQuantityValuesTableFilterComposer,
          $$ReportQuantityValuesTableOrderingComposer,
          $$ReportQuantityValuesTableAnnotationComposer,
          $$ReportQuantityValuesTableCreateCompanionBuilder,
          $$ReportQuantityValuesTableUpdateCompanionBuilder,
          (
            ReportQuantityValueRecord,
            BaseReferences<
              _$AppDatabase,
              $ReportQuantityValuesTable,
              ReportQuantityValueRecord
            >,
          ),
          ReportQuantityValueRecord,
          PrefetchHooks Function()
        > {
  $$ReportQuantityValuesTableTableManager(
    _$AppDatabase db,
    $ReportQuantityValuesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReportQuantityValuesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReportQuantityValuesTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$ReportQuantityValuesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<int?> reportQuantityID = const Value.absent(),
                Value<int?> segmentID = const Value.absent(),
                Value<int> quantityFieldID = const Value.absent(),
                Value<String> value = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => ReportQuantityValuesCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                reportQuantityID: reportQuantityID,
                segmentID: segmentID,
                quantityFieldID: quantityFieldID,
                value: value,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<int?> reportQuantityID = const Value.absent(),
                Value<int?> segmentID = const Value.absent(),
                required int quantityFieldID,
                required String value,
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => ReportQuantityValuesCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                reportQuantityID: reportQuantityID,
                segmentID: segmentID,
                quantityFieldID: quantityFieldID,
                value: value,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ReportQuantityValuesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ReportQuantityValuesTable,
      ReportQuantityValueRecord,
      $$ReportQuantityValuesTableFilterComposer,
      $$ReportQuantityValuesTableOrderingComposer,
      $$ReportQuantityValuesTableAnnotationComposer,
      $$ReportQuantityValuesTableCreateCompanionBuilder,
      $$ReportQuantityValuesTableUpdateCompanionBuilder,
      (
        ReportQuantityValueRecord,
        BaseReferences<
          _$AppDatabase,
          $ReportQuantityValuesTable,
          ReportQuantityValueRecord
        >,
      ),
      ReportQuantityValueRecord,
      PrefetchHooks Function()
    >;
typedef $$ReportSegmentsTableCreateCompanionBuilder =
    ReportSegmentsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      required int reportQuantityID,
      required int segmentNumber,
      required double startDistance,
      required double endDistance,
      required DateTime createdAt,
      required DateTime updatedAt,
    });
typedef $$ReportSegmentsTableUpdateCompanionBuilder =
    ReportSegmentsCompanion Function({
      Value<bool> isSynced,
      Value<DateTime?> deletedAt,
      Value<String?> syncAction,
      Value<int> syncRetryCount,
      Value<String?> syncError,
      Value<DateTime?> lastSyncAttempt,
      Value<int> id,
      Value<int> reportQuantityID,
      Value<int> segmentNumber,
      Value<double> startDistance,
      Value<double> endDistance,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
    });

class $$ReportSegmentsTableFilterComposer
    extends Composer<_$AppDatabase, $ReportSegmentsTable> {
  $$ReportSegmentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get reportQuantityID => $composableBuilder(
    column: $table.reportQuantityID,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get segmentNumber => $composableBuilder(
    column: $table.segmentNumber,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get startDistance => $composableBuilder(
    column: $table.startDistance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get endDistance => $composableBuilder(
    column: $table.endDistance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ReportSegmentsTableOrderingComposer
    extends Composer<_$AppDatabase, $ReportSegmentsTable> {
  $$ReportSegmentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
    column: $table.deletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncError => $composableBuilder(
    column: $table.syncError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get reportQuantityID => $composableBuilder(
    column: $table.reportQuantityID,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get segmentNumber => $composableBuilder(
    column: $table.segmentNumber,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get startDistance => $composableBuilder(
    column: $table.startDistance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get endDistance => $composableBuilder(
    column: $table.endDistance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ReportSegmentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ReportSegmentsTable> {
  $$ReportSegmentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<String> get syncAction => $composableBuilder(
    column: $table.syncAction,
    builder: (column) => column,
  );

  GeneratedColumn<int> get syncRetryCount => $composableBuilder(
    column: $table.syncRetryCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncError =>
      $composableBuilder(column: $table.syncError, builder: (column) => column);

  GeneratedColumn<DateTime> get lastSyncAttempt => $composableBuilder(
    column: $table.lastSyncAttempt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get reportQuantityID => $composableBuilder(
    column: $table.reportQuantityID,
    builder: (column) => column,
  );

  GeneratedColumn<int> get segmentNumber => $composableBuilder(
    column: $table.segmentNumber,
    builder: (column) => column,
  );

  GeneratedColumn<double> get startDistance => $composableBuilder(
    column: $table.startDistance,
    builder: (column) => column,
  );

  GeneratedColumn<double> get endDistance => $composableBuilder(
    column: $table.endDistance,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ReportSegmentsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ReportSegmentsTable,
          ReportSegmentRecord,
          $$ReportSegmentsTableFilterComposer,
          $$ReportSegmentsTableOrderingComposer,
          $$ReportSegmentsTableAnnotationComposer,
          $$ReportSegmentsTableCreateCompanionBuilder,
          $$ReportSegmentsTableUpdateCompanionBuilder,
          (
            ReportSegmentRecord,
            BaseReferences<
              _$AppDatabase,
              $ReportSegmentsTable,
              ReportSegmentRecord
            >,
          ),
          ReportSegmentRecord,
          PrefetchHooks Function()
        > {
  $$ReportSegmentsTableTableManager(
    _$AppDatabase db,
    $ReportSegmentsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReportSegmentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReportSegmentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReportSegmentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<int> reportQuantityID = const Value.absent(),
                Value<int> segmentNumber = const Value.absent(),
                Value<double> startDistance = const Value.absent(),
                Value<double> endDistance = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => ReportSegmentsCompanion(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                reportQuantityID: reportQuantityID,
                segmentNumber: segmentNumber,
                startDistance: startDistance,
                endDistance: endDistance,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<bool> isSynced = const Value.absent(),
                Value<DateTime?> deletedAt = const Value.absent(),
                Value<String?> syncAction = const Value.absent(),
                Value<int> syncRetryCount = const Value.absent(),
                Value<String?> syncError = const Value.absent(),
                Value<DateTime?> lastSyncAttempt = const Value.absent(),
                Value<int> id = const Value.absent(),
                required int reportQuantityID,
                required int segmentNumber,
                required double startDistance,
                required double endDistance,
                required DateTime createdAt,
                required DateTime updatedAt,
              }) => ReportSegmentsCompanion.insert(
                isSynced: isSynced,
                deletedAt: deletedAt,
                syncAction: syncAction,
                syncRetryCount: syncRetryCount,
                syncError: syncError,
                lastSyncAttempt: lastSyncAttempt,
                id: id,
                reportQuantityID: reportQuantityID,
                segmentNumber: segmentNumber,
                startDistance: startDistance,
                endDistance: endDistance,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ReportSegmentsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ReportSegmentsTable,
      ReportSegmentRecord,
      $$ReportSegmentsTableFilterComposer,
      $$ReportSegmentsTableOrderingComposer,
      $$ReportSegmentsTableAnnotationComposer,
      $$ReportSegmentsTableCreateCompanionBuilder,
      $$ReportSegmentsTableUpdateCompanionBuilder,
      (
        ReportSegmentRecord,
        BaseReferences<
          _$AppDatabase,
          $ReportSegmentsTable,
          ReportSegmentRecord
        >,
      ),
      ReportSegmentRecord,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$AdminsTableTableManager get admins =>
      $$AdminsTableTableManager(_db, _db.admins);
  $$SyncQueueTableTableManager get syncQueue =>
      $$SyncQueueTableTableManager(_db, _db.syncQueue);
  $$ImageSyncQueueTableTableManager get imageSyncQueue =>
      $$ImageSyncQueueTableTableManager(_db, _db.imageSyncQueue);
  $$FilesTableTableManager get files =>
      $$FilesTableTableManager(_db, _db.files);
  $$RolesTableTableManager get roles =>
      $$RolesTableTableManager(_db, _db.roles);
  $$PermissionsTableTableManager get permissions =>
      $$PermissionsTableTableManager(_db, _db.permissions);
  $$CompaniesTableTableManager get companies =>
      $$CompaniesTableTableManager(_db, _db.companies);
  $$WorkScopesTableTableManager get workScopes =>
      $$WorkScopesTableTableManager(_db, _db.workScopes);
  $$WorkQuantityTypesTableTableManager get workQuantityTypes =>
      $$WorkQuantityTypesTableTableManager(_db, _db.workQuantityTypes);
  $$WorkQuantityFieldsTableTableManager get workQuantityFields =>
      $$WorkQuantityFieldsTableTableManager(_db, _db.workQuantityFields);
  $$WorkQuantityFieldOptionsTableTableManager get workQuantityFieldOptions =>
      $$WorkQuantityFieldOptionsTableTableManager(
        _db,
        _db.workQuantityFieldOptions,
      );
  $$WorkScopeEquipmentsTableTableManager get workScopeEquipments =>
      $$WorkScopeEquipmentsTableTableManager(_db, _db.workScopeEquipments);
  $$WorkScopeEquipmentTableTableManager get workScopeEquipment =>
      $$WorkScopeEquipmentTableTableManager(_db, _db.workScopeEquipment);
  $$CountriesTableTableManager get countries =>
      $$CountriesTableTableManager(_db, _db.countries);
  $$ProvincesTableTableManager get provinces =>
      $$ProvincesTableTableManager(_db, _db.provinces);
  $$DistrictsTableTableManager get districts =>
      $$DistrictsTableTableManager(_db, _db.districts);
  $$RoadCategoriesTableTableManager get roadCategories =>
      $$RoadCategoriesTableTableManager(_db, _db.roadCategories);
  $$RoadsTableTableManager get roads =>
      $$RoadsTableTableManager(_db, _db.roads);
  $$PackagesTableTableManager get packages =>
      $$PackagesTableTableManager(_db, _db.packages);
  $$PackageRoadsTableTableManager get packageRoads =>
      $$PackageRoadsTableTableManager(_db, _db.packageRoads);
  $$DailyReportsTableTableManager get dailyReports =>
      $$DailyReportsTableTableManager(_db, _db.dailyReports);
  $$ReportEquipmentsTableTableManager get reportEquipments =>
      $$ReportEquipmentsTableTableManager(_db, _db.reportEquipments);
  $$ReportQuantitiesTableTableManager get reportQuantities =>
      $$ReportQuantitiesTableTableManager(_db, _db.reportQuantities);
  $$ReportQuantityValuesTableTableManager get reportQuantityValues =>
      $$ReportQuantityValuesTableTableManager(_db, _db.reportQuantityValues);
  $$ReportSegmentsTableTableManager get reportSegments =>
      $$ReportSegmentsTableTableManager(_db, _db.reportSegments);
}
